
USBModem.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000572  00800100  000038ae  00003942  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000038ae  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000b05  00800672  00800672  00003eb4  2**0
                  ALLOC
  3 .debug_aranges 00000518  00000000  00000000  00003eb4  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000da8  00000000  00000000  000043cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00004e90  00000000  00000000  00005174  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000018ca  00000000  00000000  0000a004  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00005073  00000000  00000000  0000b8ce  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000007f0  00000000  00000000  00010944  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001ee9  00000000  00000000  00011134  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    0000269e  00000000  00000000  0001301d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000005f0  00000000  00000000  000156bb  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:

	Debug("\r\n");
}

bool device_queue_full(void)						// TODO: Figure out how to return a proper value here
{
       0:	4b c0       	rjmp	.+150    	; 0x98 <__ctors_end>
Purpose:  transmit string from program memory to UART1
Input:    program memory string to be transmitted
Returns:  none
**************************************************************************/
void uart1_puts_p(const char *progmem_s )
{
       2:	00 00       	nop
	else
		return false;
}

bool modem_RxBufferEmpty()
{
       4:	70 c0       	rjmp	.+224    	; 0xe6 <__bad_interrupt>
   //return ((crcvalue >> 8) ^ b);
}

// Add character to the new packet & update the checksum
void AddToPacket(unsigned char c)
{
       6:	00 00       	nop
 *
 * \sa timer_reset()
 */
void
timer_restart(struct timer *t)
{
       8:	6e c0       	rjmp	.+220    	; 0xe6 <__bad_interrupt>

static u16_t ipid;           /* Ths ipid variable is an increasing
				number that is used for the IP ID
				field. */

void uip_setipid(u16_t id) { ipid = id; }
       a:	00 00       	nop
	
	return USB_Host_SendControlRequest(Buffer);
}

uint8_t USB_Host_ClearPipeStall(uint8_t EndpointNum)
{
       c:	6c c0       	rjmp	.+216    	; 0xe6 <__bad_interrupt>
uint8_t Pipe_Discard_Stream(uint16_t Length
#if !defined(NO_STREAM_CALLBACKS)
                                 , StreamCallbackPtr_t Callback
#endif
								 )
{
       e:	00 00       	nop
{
	USB_GetNextDescriptorOfType(BytesRem, CurrConfigLoc, AfterType);
	
	if (*BytesRem)
	  USB_GetNextDescriptorOfType(BytesRem, CurrConfigLoc, Type);
}
      10:	6a c0       	rjmp	.+212    	; 0xe6 <__bad_interrupt>
      12:	00 00       	nop
      14:	68 c0       	rjmp	.+208    	; 0xe6 <__bad_interrupt>
      16:	00 00       	nop
      18:	66 c0       	rjmp	.+204    	; 0xe6 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	64 c0       	rjmp	.+200    	; 0xe6 <__bad_interrupt>
      1e:	00 00       	nop
      20:	62 c0       	rjmp	.+196    	; 0xe6 <__bad_interrupt>
      22:	00 00       	nop
      24:	60 c0       	rjmp	.+192    	; 0xe6 <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 21 1b 	jmp	0x3642	; 0x3642 <__vector_10>
      2c:	5c c0       	rjmp	.+184    	; 0xe6 <__bad_interrupt>
      2e:	00 00       	nop
      30:	b5 c0       	rjmp	.+362    	; 0x19c <__vector_12>
      32:	00 00       	nop
      34:	58 c0       	rjmp	.+176    	; 0xe6 <__bad_interrupt>
      36:	00 00       	nop
      38:	56 c0       	rjmp	.+172    	; 0xe6 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	54 c0       	rjmp	.+168    	; 0xe6 <__bad_interrupt>
      3e:	00 00       	nop
      40:	52 c0       	rjmp	.+164    	; 0xe6 <__bad_interrupt>
      42:	00 00       	nop
      44:	6a c0       	rjmp	.+212    	; 0x11a <__vector_17>
      46:	00 00       	nop
      48:	4e c0       	rjmp	.+156    	; 0xe6 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	4c c0       	rjmp	.+152    	; 0xe6 <__bad_interrupt>
      4e:	00 00       	nop
      50:	4a c0       	rjmp	.+148    	; 0xe6 <__bad_interrupt>
      52:	00 00       	nop
      54:	48 c0       	rjmp	.+144    	; 0xe6 <__bad_interrupt>
      56:	00 00       	nop
      58:	46 c0       	rjmp	.+140    	; 0xe6 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	0c 94 d6 14 	jmp	0x29ac	; 0x29ac <__vector_23>
      60:	42 c0       	rjmp	.+132    	; 0xe6 <__bad_interrupt>
      62:	00 00       	nop
      64:	2d c6       	rjmp	.+3162   	; 0xcc0 <__vector_25>
      66:	00 00       	nop
      68:	5a c6       	rjmp	.+3252   	; 0xd1e <__vector_26>
      6a:	00 00       	nop
      6c:	3c c0       	rjmp	.+120    	; 0xe6 <__bad_interrupt>
      6e:	00 00       	nop
      70:	3a c0       	rjmp	.+116    	; 0xe6 <__bad_interrupt>
      72:	00 00       	nop
      74:	38 c0       	rjmp	.+112    	; 0xe6 <__bad_interrupt>
      76:	00 00       	nop
      78:	36 c0       	rjmp	.+108    	; 0xe6 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	34 c0       	rjmp	.+104    	; 0xe6 <__bad_interrupt>
      7e:	00 00       	nop
      80:	32 c0       	rjmp	.+100    	; 0xe6 <__bad_interrupt>
      82:	00 00       	nop
      84:	30 c0       	rjmp	.+96     	; 0xe6 <__bad_interrupt>
      86:	00 00       	nop
      88:	2e c0       	rjmp	.+92     	; 0xe6 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2c c0       	rjmp	.+88     	; 0xe6 <__bad_interrupt>
      8e:	00 00       	nop
      90:	2a c0       	rjmp	.+84     	; 0xe6 <__bad_interrupt>
      92:	00 00       	nop
      94:	28 c0       	rjmp	.+80     	; 0xe6 <__bad_interrupt>
      96:	00 00       	nop

00000098 <__ctors_end>:
      98:	11 24       	eor	r1, r1
      9a:	1f be       	out	0x3f, r1	; 63
      9c:	cf ef       	ldi	r28, 0xFF	; 255
      9e:	d0 e2       	ldi	r29, 0x20	; 32
      a0:	de bf       	out	0x3e, r29	; 62
      a2:	cd bf       	out	0x3d, r28	; 61

000000a4 <wdt_init>:
}

// Once the watchdog is enabled, then it stays enabled, even after a reset! 
// A function needs to be added to the .init3 section (i.e. during the startup code, before main()) to disable the watchdog early enough so it does not continually reset the AVR.
void wdt_init(void)
{
      a4:	14 be       	out	0x34, r1	; 52
    MCUSR = 0;
    wdt_disable();
      a6:	88 e1       	ldi	r24, 0x18	; 24
      a8:	0f b6       	in	r0, 0x3f	; 63
      aa:	f8 94       	cli
      ac:	80 93 60 00 	sts	0x0060, r24
      b0:	10 92 60 00 	sts	0x0060, r1
      b4:	0f be       	out	0x3f, r0	; 63

000000b6 <__do_copy_data>:
      b6:	16 e0       	ldi	r17, 0x06	; 6
      b8:	a0 e0       	ldi	r26, 0x00	; 0
      ba:	b1 e0       	ldi	r27, 0x01	; 1
      bc:	ee ea       	ldi	r30, 0xAE	; 174
      be:	f8 e3       	ldi	r31, 0x38	; 56
      c0:	00 e0       	ldi	r16, 0x00	; 0
      c2:	0b bf       	out	0x3b, r16	; 59
      c4:	02 c0       	rjmp	.+4      	; 0xca <__do_copy_data+0x14>
      c6:	07 90       	elpm	r0, Z+
      c8:	0d 92       	st	X+, r0
      ca:	a2 37       	cpi	r26, 0x72	; 114
      cc:	b1 07       	cpc	r27, r17
      ce:	d9 f7       	brne	.-10     	; 0xc6 <__do_copy_data+0x10>

000000d0 <__do_clear_bss>:
      d0:	11 e1       	ldi	r17, 0x11	; 17
      d2:	a2 e7       	ldi	r26, 0x72	; 114
      d4:	b6 e0       	ldi	r27, 0x06	; 6
      d6:	01 c0       	rjmp	.+2      	; 0xda <.do_clear_bss_start>

000000d8 <.do_clear_bss_loop>:
      d8:	1d 92       	st	X+, r1

000000da <.do_clear_bss_start>:
      da:	a7 37       	cpi	r26, 0x77	; 119
      dc:	b1 07       	cpc	r27, r17
      de:	e1 f7       	brne	.-8      	; 0xd8 <.do_clear_bss_loop>
      e0:	aa d3       	rcall	.+1876   	; 0x836 <main>
      e2:	0c 94 55 1c 	jmp	0x38aa	; 0x38aa <_exit>

000000e6 <__bad_interrupt>:
      e6:	8c cf       	rjmp	.-232    	; 0x0 <__vectors>

000000e8 <memcpy>:
      e8:	fb 01       	movw	r30, r22
      ea:	dc 01       	movw	r26, r24
      ec:	02 c0       	rjmp	.+4      	; 0xf2 <memcpy+0xa>
      ee:	01 90       	ld	r0, Z+
      f0:	0d 92       	st	X+, r0
      f2:	41 50       	subi	r20, 0x01	; 1
      f4:	50 40       	sbci	r21, 0x00	; 0
      f6:	d8 f7       	brcc	.-10     	; 0xee <memcpy+0x6>
      f8:	08 95       	ret

000000fa <strcmp>:
      fa:	fb 01       	movw	r30, r22
      fc:	dc 01       	movw	r26, r24
      fe:	8d 91       	ld	r24, X+
     100:	01 90       	ld	r0, Z+
     102:	80 19       	sub	r24, r0
     104:	01 10       	cpse	r0, r1
     106:	d9 f3       	breq	.-10     	; 0xfe <strcmp+0x4>
     108:	99 0b       	sbc	r25, r25
     10a:	08 95       	ret

0000010c <strcpy>:
     10c:	fb 01       	movw	r30, r22
     10e:	dc 01       	movw	r26, r24
     110:	01 90       	ld	r0, Z+
     112:	0d 92       	st	X+, r0
     114:	00 20       	and	r0, r0
     116:	e1 f7       	brne	.-8      	; 0x110 <strcpy+0x4>
     118:	08 95       	ret

0000011a <__vector_17>:
#define TIME_SET(a) TIME = a								// Set 10 millisecond counter to value 'a'
#define UART_BAUD_RATE 19200

// Interrupt Handlers
ISR(TIMER1_COMPA_vect)										// Timer 1 interrupt handler
{
     11a:	1f 92       	push	r1
     11c:	0f 92       	push	r0
     11e:	0f b6       	in	r0, 0x3f	; 63
     120:	0f 92       	push	r0
     122:	11 24       	eor	r1, r1
     124:	8f 93       	push	r24
     126:	9f 93       	push	r25
	TIME++;
     128:	80 91 a0 0a 	lds	r24, 0x0AA0
     12c:	90 91 a1 0a 	lds	r25, 0x0AA1
     130:	01 96       	adiw	r24, 0x01	; 1
     132:	90 93 a1 0a 	sts	0x0AA1, r25
     136:	80 93 a0 0a 	sts	0x0AA0, r24
}
     13a:	9f 91       	pop	r25
     13c:	8f 91       	pop	r24
     13e:	0f 90       	pop	r0
     140:	0f be       	out	0x3f, r0	; 63
     142:	0f 90       	pop	r0
     144:	1f 90       	pop	r1
     146:	18 95       	reti

00000148 <Debug>:
	if (DebugMode == 1)
		uart1_putc(DebugText);
}

void Debug(char *DebugText)
{
     148:	9c 01       	movw	r18, r24
	if (DebugMode == 1)
     14a:	80 91 73 06 	lds	r24, 0x0673
     14e:	81 30       	cpi	r24, 0x01	; 1
     150:	11 f4       	brne	.+4      	; 0x156 <Debug+0xe>
		uart1_puts(DebugText);
     152:	c9 01       	movw	r24, r18
     154:	5c c6       	rjmp	.+3256   	; 0xe0e <uart1_puts>
     156:	08 95       	ret

00000158 <EVENT_USB_Host_DeviceEnumerationFailed>:

// Event handler for the USB_DeviceEnumerationFailed event. This indicates that a problem occurred while
// enumerating an attached USB device.
void EVENT_USB_Host_DeviceEnumerationFailed(const uint8_t ErrorCode, const uint8_t SubErrorCode)
{
	Debug("Enumeration failed\r\n");
     158:	80 e0       	ldi	r24, 0x00	; 0
     15a:	91 e0       	ldi	r25, 0x01	; 1
     15c:	f5 df       	rcall	.-22     	; 0x148 <Debug>
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     15e:	8b b1       	in	r24, 0x0b	; 11
     160:	8f 70       	andi	r24, 0x0F	; 15
     162:	80 69       	ori	r24, 0x90	; 144
     164:	8b b9       	out	0x0b, r24	; 11
	  //                       " -- Error Code %d\r\n"
	    //                     " -- Sub Error Code %d\r\n"
	      //                   " -- In State %d\r\n" ESC_FG_WHITE), ErrorCode, SubErrorCode, USB_HostState);
	
	LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
}
     166:	08 95       	ret

00000168 <EVENT_USB_Host_DeviceEnumerationComplete>:

// Event handler for the USB_DeviceEnumerationComplete event. This indicates that a device has been successfully
//  enumerated by the host and is now ready to be used by the application.
void EVENT_USB_Host_DeviceEnumerationComplete(void)
{
	Debug("Enumeration complete\r\n");
     168:	85 e1       	ldi	r24, 0x15	; 21
     16a:	91 e0       	ldi	r25, 0x01	; 1
     16c:	ed df       	rcall	.-38     	; 0x148 <Debug>
     16e:	8b b1       	in	r24, 0x0b	; 11
     170:	8f 70       	andi	r24, 0x0F	; 15
     172:	80 66       	ori	r24, 0x60	; 96
     174:	8b b9       	out	0x0b, r24	; 11
	LEDs_SetAllLEDs(LEDMASK_USB_READY);
}
     176:	08 95       	ret

00000178 <EVENT_USB_Host_DeviceUnattached>:
// Event handler for the USB_DeviceUnattached event. This indicates that a device has been removed from the host, and
//  stops the library USB task management process.
void EVENT_USB_Host_DeviceUnattached(void)
{
	//puts_P(PSTR(ESC_FG_GREEN "\r\nDevice Unattached.\r\n" ESC_FG_WHITE));
	Debug("Device Unattached\r\n");
     178:	8c e2       	ldi	r24, 0x2C	; 44
     17a:	91 e0       	ldi	r25, 0x01	; 1
     17c:	e5 df       	rcall	.-54     	; 0x148 <Debug>
     17e:	8b b1       	in	r24, 0x0b	; 11
     180:	8f 70       	andi	r24, 0x0F	; 15
     182:	80 61       	ori	r24, 0x10	; 16
     184:	8b b9       	out	0x0b, r24	; 11
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
	ConnectedState = 0;
     186:	10 92 72 06 	sts	0x0672, r1
}
     18a:	08 95       	ret

0000018c <EVENT_USB_Host_DeviceAttached>:
// starts the library USB task to begin the enumeration and USB management process.
 
void EVENT_USB_Host_DeviceAttached(void)
{
	//puts_P(PSTR(ESC_FG_GREEN "Device Attached.\r\n" ESC_FG_WHITE));
	Debug("Device Attached\r\n");
     18c:	80 e4       	ldi	r24, 0x40	; 64
     18e:	91 e0       	ldi	r25, 0x01	; 1
     190:	db df       	rcall	.-74     	; 0x148 <Debug>
     192:	8b b1       	in	r24, 0x0b	; 11
     194:	8f 70       	andi	r24, 0x0F	; 15
     196:	80 6a       	ori	r24, 0xA0	; 160
     198:	8b b9       	out	0x0b, r24	; 11
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
}
     19a:	08 95       	ret

0000019c <__vector_12>:
{
	TIME++;
}

ISR(WDT_vect)												// Watchdog Timer interrupt handler
{
     19c:	1f 92       	push	r1
     19e:	0f 92       	push	r0
     1a0:	0f b6       	in	r0, 0x3f	; 63
     1a2:	0f 92       	push	r0
     1a4:	0b b6       	in	r0, 0x3b	; 59
     1a6:	0f 92       	push	r0
     1a8:	11 24       	eor	r1, r1
     1aa:	2f 93       	push	r18
     1ac:	3f 93       	push	r19
     1ae:	4f 93       	push	r20
     1b0:	5f 93       	push	r21
     1b2:	6f 93       	push	r22
     1b4:	7f 93       	push	r23
     1b6:	8f 93       	push	r24
     1b8:	9f 93       	push	r25
     1ba:	af 93       	push	r26
     1bc:	bf 93       	push	r27
     1be:	ef 93       	push	r30
     1c0:	ff 93       	push	r31
	if (++WatchdogTicks >= 23)								// 23 * 8s = 3 minutes. If we've received no data in 3 minutes reboot.
     1c2:	80 91 74 06 	lds	r24, 0x0674
     1c6:	8f 5f       	subi	r24, 0xFF	; 255
     1c8:	80 93 74 06 	sts	0x0674, r24
     1cc:	87 31       	cpi	r24, 0x17	; 23
     1ce:	30 f0       	brcs	.+12     	; 0x1dc <__vector_12+0x40>
	{
		WDTCSR = _BV(WDCE) | _BV(WDE);						// Set watchdog timer to reboot rather than interrupt next time it fires
     1d0:	88 e1       	ldi	r24, 0x18	; 24
     1d2:	80 93 60 00 	sts	0x0060, r24
		Debug("Watchdog reboot\r\n");
     1d6:	82 e5       	ldi	r24, 0x52	; 82
     1d8:	91 e0       	ldi	r25, 0x01	; 1
     1da:	b6 df       	rcall	.-148    	; 0x148 <Debug>
	}
}
     1dc:	ff 91       	pop	r31
     1de:	ef 91       	pop	r30
     1e0:	bf 91       	pop	r27
     1e2:	af 91       	pop	r26
     1e4:	9f 91       	pop	r25
     1e6:	8f 91       	pop	r24
     1e8:	7f 91       	pop	r23
     1ea:	6f 91       	pop	r22
     1ec:	5f 91       	pop	r21
     1ee:	4f 91       	pop	r20
     1f0:	3f 91       	pop	r19
     1f2:	2f 91       	pop	r18
     1f4:	0f 90       	pop	r0
     1f6:	0b be       	out	0x3b, r0	; 59
     1f8:	0f 90       	pop	r0
     1fa:	0f be       	out	0x3f, r0	; 63
     1fc:	0f 90       	pop	r0
     1fe:	1f 90       	pop	r1
     200:	18 95       	reti

00000202 <DebugChar>:
	// Freeze notification IN pipe after use
	Pipe_Freeze();
}

void DebugChar(char DebugText)
{
     202:	98 2f       	mov	r25, r24
	if (DebugMode == 1)
     204:	80 91 73 06 	lds	r24, 0x0673
     208:	81 30       	cpi	r24, 0x01	; 1
     20a:	11 f4       	brne	.+4      	; 0x210 <DebugChar+0xe>
		uart1_putc(DebugText);
     20c:	89 2f       	mov	r24, r25
     20e:	ea c5       	rjmp	.+3028   	; 0xde4 <uart1_putc>
     210:	08 95       	ret

00000212 <PrintHex>:
	if (DebugMode == 1)
		uart1_puts(DebugText);
}

void PrintHex(unsigned char c)
{
     212:	1f 93       	push	r17
     214:	18 2f       	mov	r17, r24
	if ((c >> 4) > 9)
     216:	82 95       	swap	r24
     218:	8f 70       	andi	r24, 0x0F	; 15
     21a:	8a 30       	cpi	r24, 0x0A	; 10
     21c:	10 f0       	brcs	.+4      	; 0x222 <PrintHex+0x10>
		DebugChar((c >> 4) + 'a' - 10);
     21e:	89 5a       	subi	r24, 0xA9	; 169
     220:	01 c0       	rjmp	.+2      	; 0x224 <PrintHex+0x12>
	else
		DebugChar((c >> 4) + '0');
     222:	80 5d       	subi	r24, 0xD0	; 208
     224:	ee df       	rcall	.-36     	; 0x202 <DebugChar>

	if ((c & 0x0f) > 9)
     226:	81 2f       	mov	r24, r17
     228:	90 e0       	ldi	r25, 0x00	; 0
     22a:	8f 70       	andi	r24, 0x0F	; 15
     22c:	90 70       	andi	r25, 0x00	; 0
     22e:	21 2f       	mov	r18, r17
     230:	2f 70       	andi	r18, 0x0F	; 15
     232:	0a 97       	sbiw	r24, 0x0a	; 10
     234:	1c f0       	brlt	.+6      	; 0x23c <PrintHex+0x2a>
		DebugChar((c & 0x0f) + 'a' - 10);
     236:	82 2f       	mov	r24, r18
     238:	89 5a       	subi	r24, 0xA9	; 169
     23a:	02 c0       	rjmp	.+4      	; 0x240 <PrintHex+0x2e>
	else
		DebugChar((c & 0x0f) + '0');
     23c:	82 2f       	mov	r24, r18
     23e:	80 5d       	subi	r24, 0xD0	; 208
     240:	e0 df       	rcall	.-64     	; 0x202 <DebugChar>

	DebugChar(' ');
     242:	80 e2       	ldi	r24, 0x20	; 32
     244:	de df       	rcall	.-68     	; 0x202 <DebugChar>
}
     246:	1f 91       	pop	r17
     248:	08 95       	ret

0000024a <device_enqueue>:
		c = uart1_getc();
	}	
}

void device_enqueue(char *x, int len)
{
     24a:	ef 92       	push	r14
     24c:	ff 92       	push	r15
     24e:	0f 93       	push	r16
     250:	1f 93       	push	r17
     252:	cf 93       	push	r28
     254:	df 93       	push	r29
     256:	7c 01       	movw	r14, r24
     258:	8b 01       	movw	r16, r22
	Debug("\r\nData:\r\n");
     25a:	84 e6       	ldi	r24, 0x64	; 100
     25c:	91 e0       	ldi	r25, 0x01	; 1
     25e:	74 df       	rcall	.-280    	; 0x148 <Debug>
     260:	c0 e0       	ldi	r28, 0x00	; 0
     262:	d0 e0       	ldi	r29, 0x00	; 0
     264:	08 c0       	rjmp	.+16     	; 0x276 <device_enqueue+0x2c>

	for (int i = 0; i < len; i++)
	{
		WatchdogTicks = 0;							// Reset the watchdog count
     266:	10 92 74 06 	sts	0x0674, r1
		uart1_putc(*(x + i));
     26a:	f7 01       	movw	r30, r14
     26c:	ec 0f       	add	r30, r28
     26e:	fd 1f       	adc	r31, r29
     270:	80 81       	ld	r24, Z
     272:	b8 d5       	rcall	.+2928   	; 0xde4 <uart1_putc>

void device_enqueue(char *x, int len)
{
	Debug("\r\nData:\r\n");

	for (int i = 0; i < len; i++)
     274:	21 96       	adiw	r28, 0x01	; 1
     276:	c0 17       	cp	r28, r16
     278:	d1 07       	cpc	r29, r17
     27a:	ac f3       	brlt	.-22     	; 0x266 <device_enqueue+0x1c>
	{
		WatchdogTicks = 0;							// Reset the watchdog count
		uart1_putc(*(x + i));
	}

	Debug("\r\n");
     27c:	8e e6       	ldi	r24, 0x6E	; 110
     27e:	91 e0       	ldi	r25, 0x01	; 1
     280:	63 df       	rcall	.-314    	; 0x148 <Debug>
}
     282:	df 91       	pop	r29
     284:	cf 91       	pop	r28
     286:	1f 91       	pop	r17
     288:	0f 91       	pop	r16
     28a:	ff 90       	pop	r15
     28c:	ef 90       	pop	r14
     28e:	08 95       	ret

00000290 <SendDataToAndFromModem>:
		break;
	}
}

void SendDataToAndFromModem(void)
{
     290:	af 92       	push	r10
     292:	bf 92       	push	r11
     294:	cf 92       	push	r12
     296:	df 92       	push	r13
     298:	ef 92       	push	r14
     29a:	ff 92       	push	r15
     29c:	0f 93       	push	r16
     29e:	1f 93       	push	r17
     2a0:	df 93       	push	r29
     2a2:	cf 93       	push	r28
     2a4:	cd b7       	in	r28, 0x3d	; 61
     2a6:	de b7       	in	r29, 0x3e	; 62
     2a8:	c0 50       	subi	r28, 0x00	; 0
     2aa:	d1 40       	sbci	r29, 0x01	; 1
     2ac:	0f b6       	in	r0, 0x3f	; 63
     2ae:	f8 94       	cli
     2b0:	de bf       	out	0x3e, r29	; 62
     2b2:	0f be       	out	0x3f, r0	; 63
     2b4:	cd bf       	out	0x3d, r28	; 61
		Pipe_ClearIN();
	}
	
	// Freeze notification IN pipe after use
	Pipe_Freeze();
}
     2b6:	ad b6       	in	r10, 0x3d	; 61
     2b8:	be b6       	in	r11, 0x3e	; 62
{
	uint8_t ErrorCode;
	uint8_t Buffer[MODEM_TX_BUFFER_SIZE];
	uint16_t BufferLength = 0;

	if (USB_HostState != HOST_STATE_Configured)
     2ba:	80 91 76 11 	lds	r24, 0x1176
     2be:	8c 30       	cpi	r24, 0x0C	; 12
     2c0:	09 f0       	breq	.+2      	; 0x2c4 <SendDataToAndFromModem+0x34>
     2c2:	b4 c0       	rjmp	.+360    	; 0x42c <SendDataToAndFromModem+0x19c>
	////////////////////////////////
	// From Circular Buffer to Modem
	////////////////////////////////

	// Select the OUT data pipe for transmission
	Pipe_SelectPipe(CDC_DATAPIPE_OUT);
     2c4:	82 e0       	ldi	r24, 0x02	; 2
     2c6:	80 93 a7 00 	sts	0x00A7, r24
	Pipe_SetPipeToken(PIPE_TOKEN_OUT);
     2ca:	80 91 aa 00 	lds	r24, 0x00AA
     2ce:	8f 7c       	andi	r24, 0xCF	; 207
     2d0:	80 62       	ori	r24, 0x20	; 32
     2d2:	80 93 aa 00 	sts	0x00AA, r24
	Pipe_Unfreeze();
     2d6:	80 91 a9 00 	lds	r24, 0x00A9
     2da:	8f 7b       	andi	r24, 0xBF	; 191
     2dc:	80 93 a9 00 	sts	0x00A9, r24

	if (!modem_TxBufferEmpty())
     2e0:	d5 d5       	rcall	.+2986   	; 0xe8c <modem_TxBufferEmpty>
     2e2:	88 23       	and	r24, r24
     2e4:	59 f5       	brne	.+86     	; 0x33c <SendDataToAndFromModem+0xac>
	{
		if (!(Pipe_IsReadWriteAllowed()))
     2e6:	80 91 a6 00 	lds	r24, 0x00A6
     2ea:	85 fd       	sbrc	r24, 5
     2ec:	0e c0       	rjmp	.+28     	; 0x30a <SendDataToAndFromModem+0x7a>
		{
			Pipe_ClearOUT();
     2ee:	80 91 a6 00 	lds	r24, 0x00A6
     2f2:	98 2f       	mov	r25, r24
     2f4:	9b 7f       	andi	r25, 0xFB	; 251
     2f6:	90 93 a6 00 	sts	0x00A6, r25
     2fa:	8f 77       	andi	r24, 0x7F	; 127
     2fc:	80 93 a6 00 	sts	0x00A6, r24

			if ((ErrorCode = Pipe_WaitUntilReady()) != PIPE_READYWAIT_NoError)
     300:	0e 94 78 1a 	call	0x34f0	; 0x34f0 <Pipe_WaitUntilReady>
     304:	88 23       	and	r24, r24
     306:	09 f0       	breq	.+2      	; 0x30a <SendDataToAndFromModem+0x7a>
     308:	8c c0       	rjmp	.+280    	; 0x422 <SendDataToAndFromModem+0x192>
		  		return;
			}
		}

		// Copy from the circular buffer to a temporary transmission buffer		
		BufferLength = modem_getTxBuffer(Buffer, (char)sizeof(Buffer));
     30a:	8e 01       	movw	r16, r28
     30c:	0f 5f       	subi	r16, 0xFF	; 255
     30e:	1f 4f       	sbci	r17, 0xFF	; 255
     310:	c8 01       	movw	r24, r16
     312:	60 e0       	ldi	r22, 0x00	; 0
     314:	70 e0       	ldi	r23, 0x00	; 0
     316:	c4 d5       	rcall	.+2952   	; 0xea0 <modem_getTxBuffer>
     318:	bc 01       	movw	r22, r24

		if ((ErrorCode = Pipe_Write_Stream_LE(Buffer, BufferLength)) != PIPE_RWSTREAM_NoError)
     31a:	c8 01       	movw	r24, r16
     31c:	0e 94 a2 1a 	call	0x3544	; 0x3544 <Pipe_Write_Stream_LE>
     320:	88 23       	and	r24, r24
     322:	19 f0       	breq	.+6      	; 0x32a <SendDataToAndFromModem+0x9a>
			Debug("Error writing Pipe\r\n");
     324:	81 e7       	ldi	r24, 0x71	; 113
     326:	91 e0       	ldi	r25, 0x01	; 1
     328:	0f df       	rcall	.-482    	; 0x148 <Debug>

		// Send the data in the OUT pipe to the attached device
		Pipe_ClearOUT();
     32a:	80 91 a6 00 	lds	r24, 0x00A6
     32e:	98 2f       	mov	r25, r24
     330:	9b 7f       	andi	r25, 0xFB	; 251
     332:	90 93 a6 00 	sts	0x00A6, r25
     336:	8f 77       	andi	r24, 0x7F	; 127
     338:	80 93 a6 00 	sts	0x00A6, r24
	}

	// Freeze pipe after use
	Pipe_Freeze();
     33c:	80 91 a9 00 	lds	r24, 0x00A9
     340:	80 64       	ori	r24, 0x40	; 64
     342:	80 93 a9 00 	sts	0x00A9, r24
	////////////////////////////////
	// From Modem to Circular Buffer
	////////////////////////////////
	
	// Select the data IN pipe
	Pipe_SelectPipe(CDC_DATAPIPE_IN);
     346:	81 e0       	ldi	r24, 0x01	; 1
     348:	80 93 a7 00 	sts	0x00A7, r24
	Pipe_SetPipeToken(PIPE_TOKEN_IN);/////
     34c:	80 91 aa 00 	lds	r24, 0x00AA
     350:	8f 7c       	andi	r24, 0xCF	; 207
     352:	80 61       	ori	r24, 0x10	; 16
     354:	80 93 aa 00 	sts	0x00AA, r24
	Pipe_Unfreeze();
     358:	80 91 a9 00 	lds	r24, 0x00A9
     35c:	8f 7b       	andi	r24, 0xBF	; 191
     35e:	80 93 a9 00 	sts	0x00A9, r24

	// Check if data is in the pipe
	if (Pipe_IsINReceived())
     362:	80 91 a6 00 	lds	r24, 0x00A6
     366:	80 ff       	sbrs	r24, 0
     368:	42 c0       	rjmp	.+132    	; 0x3ee <SendDataToAndFromModem+0x15e>
	{
			// Re-freeze IN pipe after the packet has been received
			Pipe_Freeze();
     36a:	80 91 a9 00 	lds	r24, 0x00A9
     36e:	80 64       	ori	r24, 0x40	; 64
     370:	80 93 a9 00 	sts	0x00A9, r24

			// Check if data is in the pipe
			if (Pipe_IsReadWriteAllowed())
     374:	80 91 a6 00 	lds	r24, 0x00A6
     378:	85 ff       	sbrs	r24, 5
     37a:	39 c0       	rjmp	.+114    	; 0x3ee <SendDataToAndFromModem+0x15e>
     37c:	dd b6       	in	r13, 0x3d	; 61
     37e:	ce b6       	in	r12, 0x3e	; 62
			{
				// Get the length of the pipe data, and create a new temporary buffer to hold it
				BufferLength = Pipe_BytesInPipe();
     380:	00 91 f6 00 	lds	r16, 0x00F6
     384:	10 91 f7 00 	lds	r17, 0x00F7
     388:	0f 3f       	cpi	r16, 0xFF	; 255
     38a:	11 05       	cpc	r17, r1
     38c:	19 f0       	breq	.+6      	; 0x394 <SendDataToAndFromModem+0x104>
     38e:	10 f0       	brcs	.+4      	; 0x394 <SendDataToAndFromModem+0x104>
     390:	0f ef       	ldi	r16, 0xFF	; 255
     392:	10 e0       	ldi	r17, 0x00	; 0

				if (BufferLength >= MODEM_RX_BUFFER_SIZE)
					BufferLength = MODEM_RX_BUFFER_SIZE - 1;

				uint8_t Buffer[BufferLength];
     394:	8d b7       	in	r24, 0x3d	; 61
     396:	9e b7       	in	r25, 0x3e	; 62
     398:	80 1b       	sub	r24, r16
     39a:	91 0b       	sbc	r25, r17
     39c:	0f b6       	in	r0, 0x3f	; 63
     39e:	f8 94       	cli
     3a0:	9e bf       	out	0x3e, r25	; 62
     3a2:	0f be       	out	0x3f, r0	; 63
     3a4:	8d bf       	out	0x3d, r24	; 61
     3a6:	2d b7       	in	r18, 0x3d	; 61
     3a8:	3e b7       	in	r19, 0x3e	; 62
     3aa:	2f 5f       	subi	r18, 0xFF	; 255
     3ac:	3f 4f       	sbci	r19, 0xFF	; 255
		
				// Read in the pipe data to the temporary buffer
				if ((ErrorCode = Pipe_Read_Stream_LE(Buffer, BufferLength)) != PIPE_RWSTREAM_NoError)
     3ae:	f2 2e       	mov	r15, r18
     3b0:	e3 2e       	mov	r14, r19
     3b2:	c9 01       	movw	r24, r18
     3b4:	b8 01       	movw	r22, r16
     3b6:	0e 94 d9 1a 	call	0x35b2	; 0x35b2 <Pipe_Read_Stream_LE>
     3ba:	88 23       	and	r24, r24
     3bc:	19 f0       	breq	.+6      	; 0x3c4 <SendDataToAndFromModem+0x134>
					Debug("Error reading Pipe\r\n");
     3be:	86 e8       	ldi	r24, 0x86	; 134
     3c0:	91 e0       	ldi	r25, 0x01	; 1
     3c2:	c2 de       	rcall	.-636    	; 0x148 <Debug>
		
				// Clear the pipe after it is read, ready for the next packet
				Pipe_ClearIN();
     3c4:	80 91 a6 00 	lds	r24, 0x00A6
     3c8:	98 2f       	mov	r25, r24
     3ca:	9e 7f       	andi	r25, 0xFE	; 254
     3cc:	90 93 a6 00 	sts	0x00A6, r25
     3d0:	8f 77       	andi	r24, 0x7F	; 127
     3d2:	80 93 a6 00 	sts	0x00A6, r24

				// Copy the temporary buffer contents to the circular buffer
				modem_putRxBuffer(Buffer, BufferLength);
     3d6:	8f 2d       	mov	r24, r15
     3d8:	9e 2d       	mov	r25, r14
     3da:	b8 01       	movw	r22, r16
     3dc:	80 d5       	rcall	.+2816   	; 0xede <modem_putRxBuffer>
     3de:	2d 2d       	mov	r18, r13
     3e0:	3c 2d       	mov	r19, r12
     3e2:	c9 01       	movw	r24, r18
     3e4:	0f b6       	in	r0, 0x3f	; 63
     3e6:	f8 94       	cli
     3e8:	9e bf       	out	0x3e, r25	; 62
     3ea:	0f be       	out	0x3f, r0	; 63
     3ec:	8d bf       	out	0x3d, r24	; 61
			}
	}
	
	// Re-freeze IN pipe after use
	Pipe_Freeze();		
     3ee:	80 91 a9 00 	lds	r24, 0x00A9
     3f2:	80 64       	ori	r24, 0x40	; 64
     3f4:	80 93 a9 00 	sts	0x00A9, r24

	// Select and unfreeze the notification pipe
	Pipe_SelectPipe(CDC_NOTIFICATIONPIPE);
     3f8:	83 e0       	ldi	r24, 0x03	; 3
     3fa:	80 93 a7 00 	sts	0x00A7, r24
	Pipe_Unfreeze();
     3fe:	80 91 a9 00 	lds	r24, 0x00A9
     402:	8f 7b       	andi	r24, 0xBF	; 191
     404:	80 93 a9 00 	sts	0x00A9, r24
	
	// Check if data is in the pipe
	if (Pipe_IsINReceived())
     408:	80 91 a6 00 	lds	r24, 0x00A6
     40c:	80 ff       	sbrs	r24, 0
     40e:	09 c0       	rjmp	.+18     	; 0x422 <SendDataToAndFromModem+0x192>
	{
		// Discard the event notification
		Pipe_ClearIN();
     410:	80 91 a6 00 	lds	r24, 0x00A6
     414:	98 2f       	mov	r25, r24
     416:	9e 7f       	andi	r25, 0xFE	; 254
     418:	90 93 a6 00 	sts	0x00A6, r25
     41c:	8f 77       	andi	r24, 0x7F	; 127
     41e:	80 93 a6 00 	sts	0x00A6, r24
	}
	
	// Freeze notification IN pipe after use
	Pipe_Freeze();
     422:	80 91 a9 00 	lds	r24, 0x00A9
     426:	80 64       	ori	r24, 0x40	; 64
     428:	80 93 a9 00 	sts	0x00A9, r24
}
     42c:	0f b6       	in	r0, 0x3f	; 63
     42e:	f8 94       	cli
     430:	be be       	out	0x3e, r11	; 62
     432:	0f be       	out	0x3f, r0	; 63
     434:	ad be       	out	0x3d, r10	; 61
     436:	c0 50       	subi	r28, 0x00	; 0
     438:	df 4f       	sbci	r29, 0xFF	; 255
     43a:	0f b6       	in	r0, 0x3f	; 63
     43c:	f8 94       	cli
     43e:	de bf       	out	0x3e, r29	; 62
     440:	0f be       	out	0x3f, r0	; 63
     442:	cd bf       	out	0x3d, r28	; 61
     444:	cf 91       	pop	r28
     446:	df 91       	pop	r29
     448:	1f 91       	pop	r17
     44a:	0f 91       	pop	r16
     44c:	ff 90       	pop	r15
     44e:	ef 90       	pop	r14
     450:	df 90       	pop	r13
     452:	cf 90       	pop	r12
     454:	bf 90       	pop	r11
     456:	af 90       	pop	r10
     458:	08 95       	ret

0000045a <CDC_Host_Task>:
// data received from the attached CDC device and print it to the serial port.
void CDC_Host_Task(void)
{
	uint8_t ErrorCode;

	switch (USB_HostState)
     45a:	80 91 76 11 	lds	r24, 0x1176
     45e:	88 23       	and	r24, r24
     460:	21 f0       	breq	.+8      	; 0x46a <CDC_Host_Task+0x10>
     462:	8b 30       	cpi	r24, 0x0B	; 11
     464:	09 f0       	breq	.+2      	; 0x468 <CDC_Host_Task+0xe>
     466:	3b c0       	rjmp	.+118    	; 0x4de <CDC_Host_Task+0x84>
     468:	08 c0       	rjmp	.+16     	; 0x47a <CDC_Host_Task+0x20>
	{
		case HOST_STATE_WaitForDeviceRemoval:
				Debug("Waiting for device removal\r\n");
     46a:	8b e9       	ldi	r24, 0x9B	; 155
     46c:	91 e0       	ldi	r25, 0x01	; 1
     46e:	6c de       	rcall	.-808    	; 0x148 <Debug>

				// Wait until USB device disconnected
				while (USB_HostState == HOST_STATE_WaitForDeviceRemoval);
     470:	80 91 76 11 	lds	r24, 0x1176
     474:	88 23       	and	r24, r24
     476:	e1 f3       	breq	.-8      	; 0x470 <CDC_Host_Task+0x16>
     478:	08 95       	ret
		break;

		case HOST_STATE_Addressed:

			Debug("Sending configuration command\r\n");
     47a:	88 eb       	ldi	r24, 0xB8	; 184
     47c:	91 e0       	ldi	r25, 0x01	; 1
     47e:	64 de       	rcall	.-824    	; 0x148 <Debug>

			// Standard request to set the device configuration to configuration 1
			// For the Huawei modem, this will cause the device to disconnect and change modes
			USB_ControlRequest = (USB_Request_Header_t)
     480:	ae e6       	ldi	r26, 0x6E	; 110
     482:	b1 e1       	ldi	r27, 0x11	; 17
     484:	e8 ec       	ldi	r30, 0xC8	; 200
     486:	f4 e0       	ldi	r31, 0x04	; 4
     488:	88 e0       	ldi	r24, 0x08	; 8
     48a:	01 90       	ld	r0, Z+
     48c:	0d 92       	st	X+, r0
     48e:	81 50       	subi	r24, 0x01	; 1
     490:	e1 f7       	brne	.-8      	; 0x48a <CDC_Host_Task+0x30>
					.wIndex        = 0,
					.wLength       = 0,
				};

			// Select the control pipe for the request transfer
			Pipe_SelectPipe(PIPE_CONTROLPIPE);
     492:	10 92 a7 00 	sts	0x00A7, r1

			// Send the request and display any error
			if ((ErrorCode = USB_Host_SendControlRequest(NULL)) != HOST_SENDCONTROL_Successful)
     496:	80 e0       	ldi	r24, 0x00	; 0
     498:	90 e0       	ldi	r25, 0x00	; 0
     49a:	0e 94 63 18 	call	0x30c6	; 0x30c6 <USB_Host_SendControlRequest>
     49e:	88 23       	and	r24, r24
     4a0:	19 f0       	breq	.+6      	; 0x4a8 <CDC_Host_Task+0x4e>
			{
				Debug("Control Error (Set Configuration).\r\n");
     4a2:	88 ed       	ldi	r24, 0xD8	; 216
     4a4:	91 e0       	ldi	r25, 0x01	; 1
     4a6:	50 de       	rcall	.-864    	; 0x148 <Debug>
			}

			Debug("Looking for modem device...");
     4a8:	8d ef       	ldi	r24, 0xFD	; 253
     4aa:	91 e0       	ldi	r25, 0x01	; 1
     4ac:	4d de       	rcall	.-870    	; 0x148 <Debug>
			
			// Get and process the configuration descriptor data
			// First time through we expect an error. Once the device has re-attached it should be OK
			if ((ErrorCode = ProcessConfigurationDescriptor()) != SuccessfulConfigRead)
     4ae:	2b d3       	rcall	.+1622   	; 0xb06 <ProcessConfigurationDescriptor>
     4b0:	88 23       	and	r24, r24
     4b2:	79 f0       	breq	.+30     	; 0x4d2 <CDC_Host_Task+0x78>
			{
				if (ErrorCode == ControlError)
     4b4:	81 30       	cpi	r24, 0x01	; 1
     4b6:	19 f4       	brne	.+6      	; 0x4be <CDC_Host_Task+0x64>
				  Debug("Control Error (Get Configuration).\r\n");
     4b8:	89 e1       	ldi	r24, 0x19	; 25
     4ba:	92 e0       	ldi	r25, 0x02	; 2
     4bc:	02 c0       	rjmp	.+4      	; 0x4c2 <CDC_Host_Task+0x68>
				else
				  Debug("Not a modem device\r\n");
     4be:	8e e3       	ldi	r24, 0x3E	; 62
     4c0:	92 e0       	ldi	r25, 0x02	; 2
     4c2:	42 de       	rcall	.-892    	; 0x148 <Debug>
     4c4:	8b b1       	in	r24, 0x0b	; 11
     4c6:	8f 70       	andi	r24, 0x0F	; 15
     4c8:	80 69       	ori	r24, 0x90	; 144
     4ca:	8b b9       	out	0x0b, r24	; 11

				// Indicate error via status LEDs
				LEDs_SetAllLEDs(LEDMASK_USB_ERROR);

				// Wait until USB device disconnected
				USB_HostState = HOST_STATE_WaitForDeviceRemoval;
     4cc:	10 92 76 11 	sts	0x1176, r1
     4d0:	08 95       	ret
				break;
			}

			Debug("CDC Device Enumerated\r\n");
     4d2:	83 e5       	ldi	r24, 0x53	; 83
     4d4:	92 e0       	ldi	r25, 0x02	; 2
     4d6:	38 de       	rcall	.-912    	; 0x148 <Debug>

			USB_HostState = HOST_STATE_Configured;
     4d8:	8c e0       	ldi	r24, 0x0C	; 12
     4da:	80 93 76 11 	sts	0x1176, r24
     4de:	08 95       	ret

000004e0 <EVENT_USB_Host_HostError>:
}

// Event handler for the USB_HostError event. This indicates that a hardware error occurred while in host mode. */
void EVENT_USB_Host_HostError(const uint8_t ErrorCode)
{
	USB_ShutDown();
     4e0:	0e 94 c5 19 	call	0x338a	; 0x338a <USB_ShutDown>

	Debug("Host Mode Error\r\n");
     4e4:	8b e6       	ldi	r24, 0x6B	; 107
     4e6:	92 e0       	ldi	r25, 0x02	; 2
     4e8:	2f de       	rcall	.-930    	; 0x148 <Debug>
     4ea:	8b b1       	in	r24, 0x0b	; 11
     4ec:	8f 70       	andi	r24, 0x0F	; 15
     4ee:	80 69       	ori	r24, 0x90	; 144
     4f0:	8b b9       	out	0x0b, r24	; 11
     4f2:	ff cf       	rjmp	.-2      	; 0x4f2 <EVENT_USB_Host_HostError+0x12>

000004f4 <Dial>:
	"ATDT*99#\r\n",
	"PPP"											// PPP is a special case to transition to next state
};

void Dial(void)
{
     4f4:	0f 93       	push	r16
     4f6:	1f 93       	push	r17
     4f8:	df 93       	push	r29
     4fa:	cf 93       	push	r28
     4fc:	cd b7       	in	r28, 0x3d	; 61
     4fe:	de b7       	in	r29, 0x3e	; 62
     500:	c0 54       	subi	r28, 0x40	; 64
     502:	d0 40       	sbci	r29, 0x00	; 0
     504:	0f b6       	in	r0, 0x3f	; 63
     506:	f8 94       	cli
     508:	de bf       	out	0x3e, r29	; 62
     50a:	0f be       	out	0x3f, r0	; 63
     50c:	cd bf       	out	0x3d, r28	; 61
	char Command[64];
	int c;

	if (USB_HostState == HOST_STATE_Configured)	
     50e:	80 91 76 11 	lds	r24, 0x1176
     512:	8c 30       	cpi	r24, 0x0C	; 12
     514:	09 f0       	breq	.+2      	; 0x518 <Dial+0x24>
     516:	38 c0       	rjmp	.+112    	; 0x588 <Dial+0x94>
	{
		c = modem_getc();
     518:	9d d4       	rcall	.+2362   	; 0xe54 <modem_getc>
		
		if (c & MODEM_NO_DATA)
     51a:	90 fd       	sbrc	r25, 0
     51c:	02 c0       	rjmp	.+4      	; 0x522 <Dial+0x2e>
		}
		else
		{
			do
			{
				DebugChar(c);
     51e:	71 de       	rcall	.-798    	; 0x202 <DebugChar>
     520:	fb cf       	rjmp	.-10     	; 0x518 <Dial+0x24>
				c = modem_getc();
			}
			while (!(c & MODEM_NO_DATA));
		}
			
		if (TIME > 100)
     522:	80 91 a0 0a 	lds	r24, 0x0AA0
     526:	90 91 a1 0a 	lds	r25, 0x0AA1
     52a:	85 36       	cpi	r24, 0x65	; 101
     52c:	91 05       	cpc	r25, r1
     52e:	60 f1       	brcs	.+88     	; 0x588 <Dial+0x94>
		{
			TIME_SET(0);
     530:	10 92 a1 0a 	sts	0x0AA1, r1
     534:	10 92 a0 0a 	sts	0x0AA0, r1
			strcpy(Command, DialCommands[DialSteps++]);
     538:	80 91 75 06 	lds	r24, 0x0675
     53c:	e8 2f       	mov	r30, r24
     53e:	f0 e0       	ldi	r31, 0x00	; 0
     540:	ee 0f       	add	r30, r30
     542:	ff 1f       	adc	r31, r31
     544:	e6 54       	subi	r30, 0x46	; 70
     546:	fb 4f       	sbci	r31, 0xFB	; 251
     548:	60 81       	ld	r22, Z
     54a:	71 81       	ldd	r23, Z+1	; 0x01
     54c:	8f 5f       	subi	r24, 0xFF	; 255
     54e:	80 93 75 06 	sts	0x0675, r24
     552:	8e 01       	movw	r16, r28
     554:	0f 5f       	subi	r16, 0xFF	; 255
     556:	1f 4f       	sbci	r17, 0xFF	; 255
     558:	c8 01       	movw	r24, r16
     55a:	d8 dd       	rcall	.-1104   	; 0x10c <strcpy>

			if (strcmp(Command, "PPP") == 0)
     55c:	c8 01       	movw	r24, r16
     55e:	6d e7       	ldi	r22, 0x7D	; 125
     560:	72 e0       	ldi	r23, 0x02	; 2
     562:	cb dd       	rcall	.-1130   	; 0xfa <strcmp>
     564:	00 97       	sbiw	r24, 0x00	; 0
     566:	49 f4       	brne	.+18     	; 0x57a <Dial+0x86>
			{
				Debug("Starting PPP\r\n");
     568:	81 e8       	ldi	r24, 0x81	; 129
     56a:	92 e0       	ldi	r25, 0x02	; 2
     56c:	ed dd       	rcall	.-1062   	; 0x148 <Debug>
				DialSteps = 0;
     56e:	10 92 75 06 	sts	0x0675, r1
				ConnectedState = 1;
     572:	81 e0       	ldi	r24, 0x01	; 1
     574:	80 93 72 06 	sts	0x0672, r24
     578:	07 c0       	rjmp	.+14     	; 0x588 <Dial+0x94>
				return;
			}

			Debug("Sending command: ");
     57a:	80 e9       	ldi	r24, 0x90	; 144
     57c:	92 e0       	ldi	r25, 0x02	; 2
     57e:	e4 dd       	rcall	.-1080   	; 0x148 <Debug>
			Debug(Command);
     580:	c8 01       	movw	r24, r16
     582:	e2 dd       	rcall	.-1084   	; 0x148 <Debug>
			
			modem_puts(Command);
     584:	c8 01       	movw	r24, r16
     586:	e2 d4       	rcall	.+2500   	; 0xf4c <modem_puts>
		}
	}
}
     588:	c0 5c       	subi	r28, 0xC0	; 192
     58a:	df 4f       	sbci	r29, 0xFF	; 255
     58c:	0f b6       	in	r0, 0x3f	; 63
     58e:	f8 94       	cli
     590:	de bf       	out	0x3e, r29	; 62
     592:	0f be       	out	0x3f, r0	; 63
     594:	cd bf       	out	0x3d, r28	; 61
     596:	cf 91       	pop	r28
     598:	df 91       	pop	r29
     59a:	1f 91       	pop	r17
     59c:	0f 91       	pop	r16
     59e:	08 95       	ret

000005a0 <TCPIPTask>:
{
	uip_send("GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: Keep-Alive\r\n\r\n", 65);
}

void TCPIPTask(void)
{
     5a0:	cf 92       	push	r12
     5a2:	df 92       	push	r13
     5a4:	ef 92       	push	r14
     5a6:	ff 92       	push	r15
     5a8:	0f 93       	push	r16
     5aa:	1f 93       	push	r17
     5ac:	cf 93       	push	r28
     5ae:	df 93       	push	r29
	int i, j;

	uip_len = network_read();
     5b0:	0e 94 fb 15 	call	0x2bf6	; 0x2bf6 <network_read>
     5b4:	90 93 cc 0e 	sts	0x0ECC, r25
     5b8:	80 93 cb 0e 	sts	0x0ECB, r24

	if (uip_len == -1)								// Got a non-SLIP packet. Probably a LCP-TERM Re-establish link.
     5bc:	2f ef       	ldi	r18, 0xFF	; 255
     5be:	8f 3f       	cpi	r24, 0xFF	; 255
     5c0:	92 07       	cpc	r25, r18
     5c2:	51 f4       	brne	.+20     	; 0x5d8 <TCPIPTask+0x38>
	{
		Debug("Got non-PPP packet\r\n");
     5c4:	82 ea       	ldi	r24, 0xA2	; 162
     5c6:	92 e0       	ldi	r25, 0x02	; 2
     5c8:	bf dd       	rcall	.-1154   	; 0x148 <Debug>
		TIME_SET(0);
     5ca:	10 92 a1 0a 	sts	0x0AA1, r1
     5ce:	10 92 a0 0a 	sts	0x0AA0, r1
		ConnectedState = 0;
     5d2:	10 92 72 06 	sts	0x0672, r1
     5d6:	8f c0       	rjmp	.+286    	; 0x6f6 <TCPIPTask+0x156>
		return;
	}

	if (uip_len > 0)								// We have some data to process
     5d8:	89 2b       	or	r24, r25
     5da:	09 f4       	brne	.+2      	; 0x5de <TCPIPTask+0x3e>
     5dc:	58 c0       	rjmp	.+176    	; 0x68e <TCPIPTask+0xee>
	{
	
		/********************** Debug **********************/

		Debug("\r\nReceive:\r\n");
     5de:	87 eb       	ldi	r24, 0xB7	; 183
     5e0:	92 e0       	ldi	r25, 0x02	; 2
     5e2:	b2 dd       	rcall	.-1180   	; 0x148 <Debug>
     5e4:	26 e0       	ldi	r18, 0x06	; 6
     5e6:	c2 2e       	mov	r12, r18
     5e8:	2f e0       	ldi	r18, 0x0F	; 15
     5ea:	d2 2e       	mov	r13, r18
     5ec:	ee 24       	eor	r14, r14
     5ee:	ff 24       	eor	r15, r15
     5f0:	44 c0       	rjmp	.+136    	; 0x67a <TCPIPTask+0xda>
	
		for (i = 0; i < uip_len; i += 16)
     5f2:	86 01       	movw	r16, r12
     5f4:	c0 e0       	ldi	r28, 0x00	; 0
     5f6:	d0 e0       	ldi	r29, 0x00	; 0
		{	
			// Print the hex
			for (j = 0; j < 16; j++)
			{
				if ((i + j) >= uip_len)
     5f8:	9e 01       	movw	r18, r28
     5fa:	2e 0d       	add	r18, r14
     5fc:	3f 1d       	adc	r19, r15
     5fe:	80 91 cb 0e 	lds	r24, 0x0ECB
     602:	90 91 cc 0e 	lds	r25, 0x0ECC
     606:	28 17       	cp	r18, r24
     608:	39 07       	cpc	r19, r25
     60a:	40 f4       	brcc	.+16     	; 0x61c <TCPIPTask+0x7c>
					break;

				PrintHex(*(uip_buf + i + j));
     60c:	f8 01       	movw	r30, r16
     60e:	81 91       	ld	r24, Z+
     610:	8f 01       	movw	r16, r30
     612:	ff dd       	rcall	.-1026   	; 0x212 <PrintHex>
		Debug("\r\nReceive:\r\n");
	
		for (i = 0; i < uip_len; i += 16)
		{	
			// Print the hex
			for (j = 0; j < 16; j++)
     614:	21 96       	adiw	r28, 0x01	; 1
     616:	c0 31       	cpi	r28, 0x10	; 16
     618:	d1 05       	cpc	r29, r1
     61a:	71 f7       	brne	.-36     	; 0x5f8 <TCPIPTask+0x58>
					break;

				PrintHex(*(uip_buf + i + j));
			}
			
			Debug("\r\n");	
     61c:	8e e6       	ldi	r24, 0x6E	; 110
     61e:	91 e0       	ldi	r25, 0x01	; 1
     620:	93 dd       	rcall	.-1242   	; 0x148 <Debug>
     622:	86 01       	movw	r16, r12
     624:	c0 e0       	ldi	r28, 0x00	; 0
     626:	d0 e0       	ldi	r29, 0x00	; 0
			
			// Print the ASCII
			for (j = 0; j < 16; j++)
			{
				if ((i + j) >= uip_len)
     628:	9e 01       	movw	r18, r28
     62a:	2e 0d       	add	r18, r14
     62c:	3f 1d       	adc	r19, r15
     62e:	80 91 cb 0e 	lds	r24, 0x0ECB
     632:	90 91 cc 0e 	lds	r25, 0x0ECC
     636:	28 17       	cp	r18, r24
     638:	39 07       	cpc	r19, r25
     63a:	b0 f4       	brcc	.+44     	; 0x668 <TCPIPTask+0xc8>
					break;

				if (*(uip_buf + i + j) >= 0x20 && *(uip_buf + i + j) <= 0x7e)
     63c:	f8 01       	movw	r30, r16
     63e:	80 81       	ld	r24, Z
     640:	80 52       	subi	r24, 0x20	; 32
     642:	8f 35       	cpi	r24, 0x5F	; 95
     644:	40 f4       	brcc	.+16     	; 0x656 <TCPIPTask+0xb6>
				{
					DebugChar(' ');
     646:	80 e2       	ldi	r24, 0x20	; 32
     648:	dc dd       	rcall	.-1096   	; 0x202 <DebugChar>
					DebugChar(*(uip_buf + i + j));
     64a:	f8 01       	movw	r30, r16
     64c:	80 81       	ld	r24, Z
     64e:	d9 dd       	rcall	.-1102   	; 0x202 <DebugChar>
					DebugChar(' ');
     650:	80 e2       	ldi	r24, 0x20	; 32
     652:	d7 dd       	rcall	.-1106   	; 0x202 <DebugChar>
     654:	03 c0       	rjmp	.+6      	; 0x65c <TCPIPTask+0xbc>
				}
				else
					Debug(" . ");
     656:	84 ec       	ldi	r24, 0xC4	; 196
     658:	92 e0       	ldi	r25, 0x02	; 2
     65a:	76 dd       	rcall	.-1300   	; 0x148 <Debug>
			}
			
			Debug("\r\n");	
			
			// Print the ASCII
			for (j = 0; j < 16; j++)
     65c:	21 96       	adiw	r28, 0x01	; 1
     65e:	0f 5f       	subi	r16, 0xFF	; 255
     660:	1f 4f       	sbci	r17, 0xFF	; 255
     662:	c0 31       	cpi	r28, 0x10	; 16
     664:	d1 05       	cpc	r29, r1
     666:	01 f7       	brne	.-64     	; 0x628 <TCPIPTask+0x88>
				}
				else
					Debug(" . ");

			}
			Debug("\r\n");
     668:	8e e6       	ldi	r24, 0x6E	; 110
     66a:	91 e0       	ldi	r25, 0x01	; 1
     66c:	6d dd       	rcall	.-1318   	; 0x148 <Debug>
	
		/********************** Debug **********************/

		Debug("\r\nReceive:\r\n");
	
		for (i = 0; i < uip_len; i += 16)
     66e:	80 e1       	ldi	r24, 0x10	; 16
     670:	90 e0       	ldi	r25, 0x00	; 0
     672:	e8 0e       	add	r14, r24
     674:	f9 1e       	adc	r15, r25
     676:	c8 0e       	add	r12, r24
     678:	d9 1e       	adc	r13, r25
     67a:	80 91 cb 0e 	lds	r24, 0x0ECB
     67e:	90 91 cc 0e 	lds	r25, 0x0ECC
     682:	e8 16       	cp	r14, r24
     684:	f9 06       	cpc	r15, r25
     686:	08 f4       	brcc	.+2      	; 0x68a <TCPIPTask+0xea>
     688:	b4 cf       	rjmp	.-152    	; 0x5f2 <TCPIPTask+0x52>
			Debug("\r\n");
		}

		/********************** Debug **********************/

		uip_input();
     68a:	81 e0       	ldi	r24, 0x01	; 1
     68c:	11 c0       	rjmp	.+34     	; 0x6b0 <TCPIPTask+0x110>
	 	if (uip_len > 0)
		{
	 		network_send();
	 	}
	}
	else if (timer_expired(&periodic_timer))
     68e:	89 ea       	ldi	r24, 0xA9	; 169
     690:	9a e0       	ldi	r25, 0x0A	; 10
     692:	0e 94 6c 0c 	call	0x18d8	; 0x18d8 <timer_expired>
     696:	89 2b       	or	r24, r25
     698:	a9 f0       	breq	.+42     	; 0x6c4 <TCPIPTask+0x124>
	{
		timer_reset(&periodic_timer);
     69a:	89 ea       	ldi	r24, 0xA9	; 169
     69c:	9a e0       	ldi	r25, 0x0A	; 10
     69e:	0e 94 62 0c 	call	0x18c4	; 0x18c4 <timer_reset>

		for (int i = 0; i < UIP_CONNS; i++)
		{
	 		uip_periodic(i);
     6a2:	8a ed       	ldi	r24, 0xDA	; 218
     6a4:	9e e0       	ldi	r25, 0x0E	; 14
     6a6:	90 93 d9 0e 	sts	0x0ED9, r25
     6aa:	80 93 d8 0e 	sts	0x0ED8, r24
     6ae:	82 e0       	ldi	r24, 0x02	; 2
     6b0:	0e 94 c5 0d 	call	0x1b8a	; 0x1b8a <uip_process>
 
	 		// If the above function invocation resulted in data that should be sent out on the network, the global variable uip_len is set to a value > 0.
	 		if (uip_len > 0)
     6b4:	80 91 cb 0e 	lds	r24, 0x0ECB
     6b8:	90 91 cc 0e 	lds	r25, 0x0ECC
     6bc:	89 2b       	or	r24, r25
     6be:	11 f0       	breq	.+4      	; 0x6c4 <TCPIPTask+0x124>
	 		{
	 			network_send();
     6c0:	0e 94 0a 15 	call	0x2a14	; 0x2a14 <network_send>
		}
	}

	// Read any available data from the serial port.
	// If we see a '!' in the input stream, switch debug mode on. If we see a "@", switch debug mode off.
	int c = uart1_getc();
     6c4:	73 d3       	rcall	.+1766   	; 0xdac <uart1_getc>
	while (c != UART_NO_DATA)
	{
		if (c == '!')
		{
			uart1_puts("\r\nDebug on\r\n");
			DebugMode = 1;
     6c6:	11 e0       	ldi	r17, 0x01	; 1
     6c8:	12 c0       	rjmp	.+36     	; 0x6ee <TCPIPTask+0x14e>
	// If we see a '!' in the input stream, switch debug mode on. If we see a "@", switch debug mode off.
	int c = uart1_getc();
	
	while (c != UART_NO_DATA)
	{
		if (c == '!')
     6ca:	81 32       	cpi	r24, 0x21	; 33
     6cc:	91 05       	cpc	r25, r1
     6ce:	31 f4       	brne	.+12     	; 0x6dc <TCPIPTask+0x13c>
		{
			uart1_puts("\r\nDebug on\r\n");
     6d0:	88 ec       	ldi	r24, 0xC8	; 200
     6d2:	92 e0       	ldi	r25, 0x02	; 2
     6d4:	9c d3       	rcall	.+1848   	; 0xe0e <uart1_puts>
			DebugMode = 1;
     6d6:	10 93 73 06 	sts	0x0673, r17
     6da:	08 c0       	rjmp	.+16     	; 0x6ec <TCPIPTask+0x14c>
		}
		else if (c == '@')
     6dc:	80 34       	cpi	r24, 0x40	; 64
     6de:	91 05       	cpc	r25, r1
     6e0:	29 f4       	brne	.+10     	; 0x6ec <TCPIPTask+0x14c>
		{
			uart1_puts("\r\nDebug off\r\n");
     6e2:	85 ed       	ldi	r24, 0xD5	; 213
     6e4:	92 e0       	ldi	r25, 0x02	; 2
     6e6:	93 d3       	rcall	.+1830   	; 0xe0e <uart1_puts>
			DebugMode = 0;
     6e8:	10 92 73 06 	sts	0x0673, r1
		}

		c = uart1_getc();
     6ec:	5f d3       	rcall	.+1726   	; 0xdac <uart1_getc>

	// Read any available data from the serial port.
	// If we see a '!' in the input stream, switch debug mode on. If we see a "@", switch debug mode off.
	int c = uart1_getc();
	
	while (c != UART_NO_DATA)
     6ee:	e1 e0       	ldi	r30, 0x01	; 1
     6f0:	80 30       	cpi	r24, 0x00	; 0
     6f2:	9e 07       	cpc	r25, r30
     6f4:	51 f7       	brne	.-44     	; 0x6ca <TCPIPTask+0x12a>
			DebugMode = 0;
		}

		c = uart1_getc();
	}	
}
     6f6:	df 91       	pop	r29
     6f8:	cf 91       	pop	r28
     6fa:	1f 91       	pop	r17
     6fc:	0f 91       	pop	r16
     6fe:	ff 90       	pop	r15
     700:	ef 90       	pop	r14
     702:	df 90       	pop	r13
     704:	cf 90       	pop	r12
     706:	08 95       	ret

00000708 <SendGET>:
	}
}

void SendGET(void)
{
	uip_send("GET / HTTP/1.1\r\nHost: www.example.com\r\nConnection: Keep-Alive\r\n\r\n", 65);
     708:	83 ee       	ldi	r24, 0xE3	; 227
     70a:	92 e0       	ldi	r25, 0x02	; 2
     70c:	61 e4       	ldi	r22, 0x41	; 65
     70e:	70 e0       	ldi	r23, 0x00	; 0
     710:	0c 94 af 0d 	jmp	0x1b5e	; 0x1b5e <uip_send>

00000714 <TCPCallback>:
	}
}

extern void TCPCallback(void)
{
	DebugChar('*');
     714:	8a e2       	ldi	r24, 0x2A	; 42
     716:	75 dd       	rcall	.-1302   	; 0x202 <DebugChar>

	if (uip_newdata())
     718:	80 91 d3 0e 	lds	r24, 0x0ED3
     71c:	81 ff       	sbrs	r24, 1
     71e:	03 c0       	rjmp	.+6      	; 0x726 <TCPCallback+0x12>
		Debug("NewData ");
     720:	85 e2       	ldi	r24, 0x25	; 37
     722:	93 e0       	ldi	r25, 0x03	; 3
     724:	11 dd       	rcall	.-1502   	; 0x148 <Debug>

	if (uip_acked())
     726:	80 91 d3 0e 	lds	r24, 0x0ED3
     72a:	80 ff       	sbrs	r24, 0
     72c:	03 c0       	rjmp	.+6      	; 0x734 <TCPCallback+0x20>
		Debug("Acked ");
     72e:	8e e2       	ldi	r24, 0x2E	; 46
     730:	93 e0       	ldi	r25, 0x03	; 3
     732:	0a dd       	rcall	.-1516   	; 0x148 <Debug>
	
	if (uip_connected())
     734:	80 91 d3 0e 	lds	r24, 0x0ED3
     738:	86 ff       	sbrs	r24, 6
     73a:	03 c0       	rjmp	.+6      	; 0x742 <TCPCallback+0x2e>
		Debug("Connected ");
     73c:	85 e3       	ldi	r24, 0x35	; 53
     73e:	93 e0       	ldi	r25, 0x03	; 3
     740:	03 dd       	rcall	.-1530   	; 0x148 <Debug>

	if (uip_closed())
     742:	80 91 d3 0e 	lds	r24, 0x0ED3
     746:	84 ff       	sbrs	r24, 4
     748:	0f c0       	rjmp	.+30     	; 0x768 <TCPCallback+0x54>
	{
		Debug("Closed - Reconnecting...");
     74a:	80 e4       	ldi	r24, 0x40	; 64
     74c:	93 e0       	ldi	r25, 0x03	; 3
     74e:	fc dc       	rcall	.-1544   	; 0x148 <Debug>
     750:	80 e1       	ldi	r24, 0x10	; 16
     752:	97 e2       	ldi	r25, 0x27	; 39
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     754:	28 ec       	ldi	r18, 0xC8	; 200
     756:	30 e0       	ldi	r19, 0x00	; 0
     758:	f9 01       	movw	r30, r18
     75a:	31 97       	sbiw	r30, 0x01	; 1
     75c:	f1 f7       	brne	.-4      	; 0x75a <TCPCallback+0x46>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     75e:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     760:	d9 f7       	brne	.-10     	; 0x758 <TCPCallback+0x44>
		_delay_ms(1000);
		ConnectedState = 3;
     762:	83 e0       	ldi	r24, 0x03	; 3
     764:	80 93 72 06 	sts	0x0672, r24
	}

	if (uip_aborted())
     768:	80 91 d3 0e 	lds	r24, 0x0ED3
     76c:	85 ff       	sbrs	r24, 5
     76e:	0f c0       	rjmp	.+30     	; 0x78e <TCPCallback+0x7a>
	{
		Debug("Aborted - Reconnecting... ");
     770:	89 e5       	ldi	r24, 0x59	; 89
     772:	93 e0       	ldi	r25, 0x03	; 3
     774:	e9 dc       	rcall	.-1582   	; 0x148 <Debug>
     776:	80 e1       	ldi	r24, 0x10	; 16
     778:	97 e2       	ldi	r25, 0x27	; 39
     77a:	28 ec       	ldi	r18, 0xC8	; 200
     77c:	30 e0       	ldi	r19, 0x00	; 0
     77e:	f9 01       	movw	r30, r18
     780:	31 97       	sbiw	r30, 0x01	; 1
     782:	f1 f7       	brne	.-4      	; 0x780 <TCPCallback+0x6c>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     784:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     786:	d9 f7       	brne	.-10     	; 0x77e <TCPCallback+0x6a>
		_delay_ms(1000);
		ConnectedState = 3;
     788:	83 e0       	ldi	r24, 0x03	; 3
     78a:	80 93 72 06 	sts	0x0672, r24
	}

	if (uip_timedout())
     78e:	80 91 d3 0e 	lds	r24, 0x0ED3
     792:	87 ff       	sbrs	r24, 7
     794:	12 c0       	rjmp	.+36     	; 0x7ba <TCPCallback+0xa6>
	{
		Debug("Timeout - Reconnecting...");
     796:	84 e7       	ldi	r24, 0x74	; 116
     798:	93 e0       	ldi	r25, 0x03	; 3
     79a:	d6 dc       	rcall	.-1620   	; 0x148 <Debug>
		uip_abort();
     79c:	80 e2       	ldi	r24, 0x20	; 32
     79e:	80 93 d3 0e 	sts	0x0ED3, r24
     7a2:	80 e1       	ldi	r24, 0x10	; 16
     7a4:	97 e2       	ldi	r25, 0x27	; 39
     7a6:	28 ec       	ldi	r18, 0xC8	; 200
     7a8:	30 e0       	ldi	r19, 0x00	; 0
     7aa:	f9 01       	movw	r30, r18
     7ac:	31 97       	sbiw	r30, 0x01	; 1
     7ae:	f1 f7       	brne	.-4      	; 0x7ac <TCPCallback+0x98>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     7b0:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     7b2:	d9 f7       	brne	.-10     	; 0x7aa <TCPCallback+0x96>
		_delay_ms(1000);
		ConnectedState = 3;
     7b4:	83 e0       	ldi	r24, 0x03	; 3
     7b6:	80 93 72 06 	sts	0x0672, r24
	}

	if (uip_poll() && TIME > 3000)
     7ba:	80 91 d3 0e 	lds	r24, 0x0ED3
     7be:	83 ff       	sbrs	r24, 3
     7c0:	0f c0       	rjmp	.+30     	; 0x7e0 <TCPCallback+0xcc>
     7c2:	80 91 a0 0a 	lds	r24, 0x0AA0
     7c6:	90 91 a1 0a 	lds	r25, 0x0AA1
     7ca:	89 5b       	subi	r24, 0xB9	; 185
     7cc:	9b 40       	sbci	r25, 0x0B	; 11
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <TCPCallback+0xcc>
	{
		TIME_SET(0);
     7d0:	10 92 a1 0a 	sts	0x0AA1, r1
     7d4:	10 92 a0 0a 	sts	0x0AA0, r1
		
		Debug("\r\nSending GET\r\n");
     7d8:	8e e8       	ldi	r24, 0x8E	; 142
     7da:	93 e0       	ldi	r25, 0x03	; 3
     7dc:	b5 dc       	rcall	.-1686   	; 0x148 <Debug>
		SendGET();
     7de:	94 df       	rcall	.-216    	; 0x708 <SendGET>
	}
	
	if (uip_rexmit())
     7e0:	80 91 d3 0e 	lds	r24, 0x0ED3
     7e4:	82 ff       	sbrs	r24, 2
     7e6:	04 c0       	rjmp	.+8      	; 0x7f0 <TCPCallback+0xdc>
	{
		Debug("\r\nRetransmit GET\r\n");
     7e8:	8e e9       	ldi	r24, 0x9E	; 158
     7ea:	93 e0       	ldi	r25, 0x03	; 3
     7ec:	ad dc       	rcall	.-1702   	; 0x148 <Debug>
		SendGET();
     7ee:	8c df       	rcall	.-232    	; 0x708 <SendGET>
	}

	if (uip_newdata())
     7f0:	80 91 d3 0e 	lds	r24, 0x0ED3
     7f4:	81 ff       	sbrs	r24, 1
     7f6:	09 c0       	rjmp	.+18     	; 0x80a <TCPCallback+0xf6>
	{
		device_enqueue(uip_appdata, uip_datalen());
     7f8:	60 91 cb 0e 	lds	r22, 0x0ECB
     7fc:	70 91 cc 0e 	lds	r23, 0x0ECC
     800:	80 91 d6 0e 	lds	r24, 0x0ED6
     804:	90 91 d7 0e 	lds	r25, 0x0ED7
     808:	20 dd       	rcall	.-1472   	; 0x24a <device_enqueue>
		{
			uip_stop();
		}
	}

	if (uip_poll() && uip_stopped(ThisConn))
     80a:	90 91 d3 0e 	lds	r25, 0x0ED3
     80e:	93 ff       	sbrs	r25, 3
     810:	11 c0       	rjmp	.+34     	; 0x834 <TCPCallback+0x120>
     812:	e0 91 ad 0a 	lds	r30, 0x0AAD
     816:	f0 91 ae 0a 	lds	r31, 0x0AAE
     81a:	81 8d       	ldd	r24, Z+25	; 0x19
     81c:	84 ff       	sbrs	r24, 4
     81e:	0a c0       	rjmp	.+20     	; 0x834 <TCPCallback+0x120>
	{
		if (!device_queue_full())
		{
			uip_restart();
     820:	92 60       	ori	r25, 0x02	; 2
     822:	90 93 d3 0e 	sts	0x0ED3, r25
     826:	e0 91 d8 0e 	lds	r30, 0x0ED8
     82a:	f0 91 d9 0e 	lds	r31, 0x0ED9
     82e:	81 8d       	ldd	r24, Z+25	; 0x19
     830:	8f 7e       	andi	r24, 0xEF	; 239
     832:	81 8f       	std	Z+25, r24	; 0x19
     834:	08 95       	ret

00000836 <main>:
    return;
}

// Main program entry point. This routine configures the hardware required by the application, then runs the application tasks.
int main(void)
{
     836:	2f 92       	push	r2
     838:	3f 92       	push	r3
     83a:	4f 92       	push	r4
     83c:	5f 92       	push	r5
     83e:	6f 92       	push	r6
     840:	7f 92       	push	r7
     842:	8f 92       	push	r8
     844:	9f 92       	push	r9
     846:	af 92       	push	r10
     848:	bf 92       	push	r11
     84a:	cf 92       	push	r12
     84c:	df 92       	push	r13
     84e:	ef 92       	push	r14
     850:	ff 92       	push	r15
     852:	0f 93       	push	r16
     854:	1f 93       	push	r17
     856:	cf 93       	push	r28
     858:	df 93       	push	r29
	// Disable clock division
	clock_prescale_set(clock_div_1);
     85a:	80 e0       	ldi	r24, 0x00	; 0
     85c:	90 e0       	ldi	r25, 0x00	; 0
     85e:	20 e8       	ldi	r18, 0x80	; 128
     860:	0f b6       	in	r0, 0x3f	; 63
     862:	f8 94       	cli
     864:	20 93 61 00 	sts	0x0061, r18
     868:	80 93 61 00 	sts	0x0061, r24
     86c:	0f be       	out	0x3f, r0	; 63

	// Hardware Initialization
	//SerialStream_Init(19200, false);
	uart1_init(UART_BAUD_SELECT(UART_BAUD_RATE, F_CPU)); 	// Initialise the UART
     86e:	89 e1       	ldi	r24, 0x19	; 25
     870:	90 e0       	ldi	r25, 0x00	; 0
     872:	82 d2       	rcall	.+1284   	; 0xd78 <uart1_init>
	modem_init();
     874:	e6 d2       	rcall	.+1484   	; 0xe42 <modem_init>

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
     876:	8a b1       	in	r24, 0x0a	; 10
     878:	80 6f       	ori	r24, 0xF0	; 240
     87a:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
     87c:	8b b1       	in	r24, 0x0b	; 11
     87e:	8f 70       	andi	r24, 0x0F	; 15
     880:	8b b9       	out	0x0b, r24	; 11
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     882:	8b b1       	in	r24, 0x0b	; 11
     884:	8f 70       	andi	r24, 0x0F	; 15
     886:	80 66       	ori	r24, 0x60	; 96
     888:	8b b9       	out	0x0b, r24	; 11
     88a:	88 e8       	ldi	r24, 0x88	; 136
     88c:	93 e1       	ldi	r25, 0x13	; 19
     88e:	28 ec       	ldi	r18, 0xC8	; 200
     890:	30 e0       	ldi	r19, 0x00	; 0
     892:	f9 01       	movw	r30, r18
     894:	31 97       	sbiw	r30, 0x01	; 1
     896:	f1 f7       	brne	.-4      	; 0x894 <main+0x5e>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     898:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     89a:	d9 f7       	brne	.-10     	; 0x892 <main+0x5c>
     89c:	8b b1       	in	r24, 0x0b	; 11
     89e:	8f 70       	andi	r24, 0x0F	; 15
     8a0:	80 69       	ori	r24, 0x90	; 144
     8a2:	8b b9       	out	0x0b, r24	; 11
     8a4:	88 e8       	ldi	r24, 0x88	; 136
     8a6:	93 e1       	ldi	r25, 0x13	; 19
     8a8:	28 ec       	ldi	r18, 0xC8	; 200
     8aa:	30 e0       	ldi	r19, 0x00	; 0
     8ac:	f9 01       	movw	r30, r18
     8ae:	31 97       	sbiw	r30, 0x01	; 1
     8b0:	f1 f7       	brne	.-4      	; 0x8ae <main+0x78>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     8b2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     8b4:	d9 f7       	brne	.-10     	; 0x8ac <main+0x76>
     8b6:	8b b1       	in	r24, 0x0b	; 11
     8b8:	8f 70       	andi	r24, 0x0F	; 15
     8ba:	80 66       	ori	r24, 0x60	; 96
     8bc:	8b b9       	out	0x0b, r24	; 11
	LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
	_delay_ms(500);
	LEDs_SetAllLEDs(LEDMASK_USB_READY);
	
	// Initialize USB Subsystem
	USB_Init();
     8be:	0e 94 d7 19 	call	0x33ae	; 0x33ae <USB_Init>
	
	//Startup message
	uart1_puts("\r\nUSB Modem - Press space bar to debug\r\n");			// Make sure the first 5 chars do not contain a space as terminal will echo this back
     8c2:	81 eb       	ldi	r24, 0xB1	; 177
     8c4:	93 e0       	ldi	r25, 0x03	; 3
     8c6:	a3 d2       	rcall	.+1350   	; 0xe0e <uart1_puts>
     8c8:	c0 e0       	ldi	r28, 0x00	; 0
     8ca:	d0 e0       	ldi	r29, 0x00	; 0
     8cc:	08 ec       	ldi	r16, 0xC8	; 200
     8ce:	10 e0       	ldi	r17, 0x00	; 0
	
	for (int i = 0; i <= 5; i++)
	{
		uart1_putc('.');
     8d0:	8e e2       	ldi	r24, 0x2E	; 46
     8d2:	88 d2       	rcall	.+1296   	; 0xde4 <uart1_putc>
		
		if (uart1_getc() == ' ')
     8d4:	6b d2       	rcall	.+1238   	; 0xdac <uart1_getc>
     8d6:	80 97       	sbiw	r24, 0x20	; 32
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <main+0xb2>
		{
			DebugMode = 1;
     8da:	81 e0       	ldi	r24, 0x01	; 1
     8dc:	80 93 73 06 	sts	0x0673, r24
			uart1_puts("\r\nDebugging\r\n");
     8e0:	8a ed       	ldi	r24, 0xDA	; 218
     8e2:	93 e0       	ldi	r25, 0x03	; 3
     8e4:	94 d2       	rcall	.+1320   	; 0xe0e <uart1_puts>
     8e6:	0b c0       	rjmp	.+22     	; 0x8fe <main+0xc8>
			break;
     8e8:	88 e8       	ldi	r24, 0x88	; 136
     8ea:	93 e1       	ldi	r25, 0x13	; 19
     8ec:	f8 01       	movw	r30, r16
     8ee:	31 97       	sbiw	r30, 0x01	; 1
     8f0:	f1 f7       	brne	.-4      	; 0x8ee <main+0xb8>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
     8f2:	01 97       	sbiw	r24, 0x01	; 1
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
     8f4:	d9 f7       	brne	.-10     	; 0x8ec <main+0xb6>
	USB_Init();
	
	//Startup message
	uart1_puts("\r\nUSB Modem - Press space bar to debug\r\n");			// Make sure the first 5 chars do not contain a space as terminal will echo this back
	
	for (int i = 0; i <= 5; i++)
     8f6:	21 96       	adiw	r28, 0x01	; 1
     8f8:	c6 30       	cpi	r28, 0x06	; 6
     8fa:	d1 05       	cpc	r29, r1
     8fc:	49 f7       	brne	.-46     	; 0x8d0 <main+0x9a>
		}
		
		_delay_ms(500);
	}

	uart1_puts("\r\n");
     8fe:	8e e6       	ldi	r24, 0x6E	; 110
     900:	91 e0       	ldi	r25, 0x01	; 1
     902:	85 d2       	rcall	.+1290   	; 0xe0e <uart1_puts>

	// Timer 1
	TCCR1B = _BV(WGM12) | _BV(CS10) | _BV(CS12);			// CK/1024 prescale, CTC mode
     904:	8d e0       	ldi	r24, 0x0D	; 13
     906:	80 93 81 00 	sts	0x0081, r24
	OCR1A = 78;												// 10ms timer. 8,000,000 / 1,024 * 0.01
     90a:	8e e4       	ldi	r24, 0x4E	; 78
     90c:	90 e0       	ldi	r25, 0x00	; 0
     90e:	90 93 89 00 	sts	0x0089, r25
     912:	80 93 88 00 	sts	0x0088, r24
	TIMSK1 = _BV(OCIE1A); 									// Enable interrupt on Timer compare
     916:	82 e0       	ldi	r24, 0x02	; 2
     918:	80 93 6f 00 	sts	0x006F, r24
     91c:	8b b1       	in	r24, 0x0b	; 11
     91e:	8f 70       	andi	r24, 0x0F	; 15
     920:	8b b9       	out	0x0b, r24	; 11
	
	LEDs_SetAllLEDs(LEDS_NO_LEDS);							// Turn the LEDs off

	wdt_reset();
     922:	a8 95       	wdr
	WDTCSR = _BV(WDCE) | _BV(WDE);						
     924:	88 e1       	ldi	r24, 0x18	; 24
     926:	80 93 60 00 	sts	0x0060, r24
	WDTCSR = _BV(WDIE) | _BV(WDP0) | _BV(WDP3);				// Set the Watchdog timer to interrupt (not reset) every 8 seconds
     92a:	81 e6       	ldi	r24, 0x61	; 97
     92c:	80 93 60 00 	sts	0x0060, r24

	TIME_SET(0);											// Reset the 10ms timer
     930:	10 92 a1 0a 	sts	0x0AA1, r1
     934:	10 92 a0 0a 	sts	0x0AA0, r1
				timer_set(&periodic_timer, CLOCK_SECOND / 2);
			
				uip_init();

				// Set this machine's IP address
				uip_ipaddr(&LocalIPAddress, IPAddr1, IPAddr2, IPAddr3, IPAddr4);
     938:	f0 eb       	ldi	r31, 0xB0	; 176
     93a:	cf 2e       	mov	r12, r31
     93c:	fa e0       	ldi	r31, 0x0A	; 10
     93e:	df 2e       	mov	r13, r31
     940:	e2 e0       	ldi	r30, 0x02	; 2
     942:	2e 2e       	mov	r2, r30
     944:	31 2c       	mov	r3, r1
     946:	2c 0c       	add	r2, r12
     948:	3d 1c       	adc	r3, r13
				uip_sethostaddr(&LocalIPAddress);
     94a:	72 e0       	ldi	r23, 0x02	; 2
     94c:	e7 2e       	mov	r14, r23
     94e:	7f e0       	ldi	r23, 0x0F	; 15
     950:	f7 2e       	mov	r15, r23
     952:	62 e0       	ldi	r22, 0x02	; 2
     954:	46 2e       	mov	r4, r22
     956:	51 2c       	mov	r5, r1
     958:	4e 0c       	add	r4, r14
     95a:	5f 1c       	adc	r5, r15

				// Set remote IP address
				uip_ipaddr(&RemoteIPAddress, 192,0,32,10);	// www.example.com
     95c:	50 ec       	ldi	r21, 0xC0	; 192
     95e:	65 2e       	mov	r6, r21
     960:	71 2c       	mov	r7, r1
     962:	40 e2       	ldi	r20, 0x20	; 32
     964:	84 2e       	mov	r8, r20
     966:	4a e0       	ldi	r20, 0x0A	; 10
     968:	94 2e       	mov	r9, r20

				ConnectedState = 3;
				TIME_SET(2000);			// Make the first CONNECT happen straight away
     96a:	30 ed       	ldi	r19, 0xD0	; 208
     96c:	a3 2e       	mov	r10, r19
     96e:	37 e0       	ldi	r19, 0x07	; 7
     970:	b3 2e       	mov	r11, r19
	TIME_SET(0);											// Reset the 10ms timer
	
	// Loop forever	
	for(;;)
	{
		USB_USBTask();
     972:	0e 94 ac 1b 	call	0x3758	; 0x3758 <USB_USBTask>
		CDC_Host_Task();
     976:	71 dd       	rcall	.-1310   	; 0x45a <CDC_Host_Task>
		SendDataToAndFromModem();
     978:	8b dc       	rcall	.-1770   	; 0x290 <SendDataToAndFromModem>
		
		switch (ConnectedState)
     97a:	80 91 72 06 	lds	r24, 0x0672
     97e:	82 30       	cpi	r24, 0x02	; 2
     980:	89 f0       	breq	.+34     	; 0x9a4 <main+0x16e>
     982:	83 30       	cpi	r24, 0x03	; 3
     984:	28 f4       	brcc	.+10     	; 0x990 <main+0x15a>
     986:	88 23       	and	r24, r24
     988:	49 f0       	breq	.+18     	; 0x99c <main+0x166>
     98a:	81 30       	cpi	r24, 0x01	; 1
     98c:	91 f7       	brne	.-28     	; 0x972 <main+0x13c>
     98e:	08 c0       	rjmp	.+16     	; 0x9a0 <main+0x16a>
     990:	83 30       	cpi	r24, 0x03	; 3
     992:	09 f4       	brne	.+2      	; 0x996 <main+0x160>
     994:	45 c0       	rjmp	.+138    	; 0xa20 <main+0x1ea>
     996:	84 30       	cpi	r24, 0x04	; 4
     998:	61 f7       	brne	.-40     	; 0x972 <main+0x13c>
     99a:	80 c0       	rjmp	.+256    	; 0xa9c <main+0x266>
		{
			case 0:
				Dial();
     99c:	ab dd       	rcall	.-1194   	; 0x4f4 <Dial>
     99e:	e9 cf       	rjmp	.-46     	; 0x972 <main+0x13c>
			break;
			
			case 1:
				DoPPP();
     9a0:	0b d6       	rcall	.+3094   	; 0x15b8 <DoPPP>
     9a2:	e7 cf       	rjmp	.-50     	; 0x972 <main+0x13c>
			break;
			
			case 2:
				Debug("Initialise TCP Stack\r\n");
     9a4:	88 ee       	ldi	r24, 0xE8	; 232
     9a6:	93 e0       	ldi	r25, 0x03	; 3
     9a8:	cf db       	rcall	.-2146   	; 0x148 <Debug>
			
				network_init();
     9aa:	0e 94 ff 14 	call	0x29fe	; 0x29fe <network_init>
	
				clock_init();
     9ae:	0e 94 ed 14 	call	0x29da	; 0x29da <clock_init>

				timer_set(&periodic_timer, CLOCK_SECOND / 2);
     9b2:	89 ea       	ldi	r24, 0xA9	; 169
     9b4:	9a e0       	ldi	r25, 0x0A	; 10
     9b6:	6f e0       	ldi	r22, 0x0F	; 15
     9b8:	70 e0       	ldi	r23, 0x00	; 0
     9ba:	a5 d7       	rcall	.+3914   	; 0x1906 <timer_set>
			
				uip_init();
     9bc:	0e 94 21 0d 	call	0x1a42	; 0x1a42 <uip_init>

				// Set this machine's IP address
				uip_ipaddr(&LocalIPAddress, IPAddr1, IPAddr2, IPAddr3, IPAddr4);
     9c0:	10 91 af 0a 	lds	r17, 0x0AAF
     9c4:	00 e0       	ldi	r16, 0x00	; 0
     9c6:	20 91 a3 0a 	lds	r18, 0x0AA3
     9ca:	30 e0       	ldi	r19, 0x00	; 0
     9cc:	20 2b       	or	r18, r16
     9ce:	31 2b       	or	r19, r17
     9d0:	30 93 b0 0a 	sts	0x0AB0, r19
     9d4:	f6 01       	movw	r30, r12
     9d6:	21 83       	std	Z+1, r18	; 0x01
     9d8:	d0 91 a2 0a 	lds	r29, 0x0AA2
     9dc:	c0 e0       	ldi	r28, 0x00	; 0
     9de:	80 91 a8 0a 	lds	r24, 0x0AA8
     9e2:	90 e0       	ldi	r25, 0x00	; 0
     9e4:	8c 2b       	or	r24, r28
     9e6:	9d 2b       	or	r25, r29
     9e8:	90 93 b2 0a 	sts	0x0AB2, r25
     9ec:	f1 01       	movw	r30, r2
     9ee:	81 83       	std	Z+1, r24	; 0x01
				uip_sethostaddr(&LocalIPAddress);
     9f0:	30 93 02 0f 	sts	0x0F02, r19
     9f4:	f7 01       	movw	r30, r14
     9f6:	21 83       	std	Z+1, r18	; 0x01
     9f8:	90 93 04 0f 	sts	0x0F04, r25
     9fc:	f2 01       	movw	r30, r4
     9fe:	81 83       	std	Z+1, r24	; 0x01

				// Set remote IP address
				uip_ipaddr(&RemoteIPAddress, 192,0,32,10);	// www.example.com
     a00:	70 92 a5 0a 	sts	0x0AA5, r7
     a04:	60 92 a4 0a 	sts	0x0AA4, r6
     a08:	90 92 a7 0a 	sts	0x0AA7, r9
     a0c:	80 92 a6 0a 	sts	0x0AA6, r8

				ConnectedState = 3;
     a10:	f3 e0       	ldi	r31, 0x03	; 3
     a12:	f0 93 72 06 	sts	0x0672, r31
				TIME_SET(2000);			// Make the first CONNECT happen straight away
     a16:	b0 92 a1 0a 	sts	0x0AA1, r11
     a1a:	a0 92 a0 0a 	sts	0x0AA0, r10
     a1e:	a9 cf       	rjmp	.-174    	; 0x972 <main+0x13c>
			break;
			
			case 3:
				if (TIME > 1000)		//Try to connect every 1 second
     a20:	80 91 a0 0a 	lds	r24, 0x0AA0
     a24:	90 91 a1 0a 	lds	r25, 0x0AA1
     a28:	89 5e       	subi	r24, 0xE9	; 233
     a2a:	93 40       	sbci	r25, 0x03	; 3
     a2c:	08 f4       	brcc	.+2      	; 0xa30 <main+0x1fa>
     a2e:	a1 cf       	rjmp	.-190    	; 0x972 <main+0x13c>
				{
					TIME_SET(0);
     a30:	10 92 a1 0a 	sts	0x0AA1, r1
     a34:	10 92 a0 0a 	sts	0x0AA0, r1
					
					// Connect to the remote machine
					ThisConn = uip_connect(&RemoteIPAddress, HTONS(80));
     a38:	84 ea       	ldi	r24, 0xA4	; 164
     a3a:	9a e0       	ldi	r25, 0x0A	; 10
     a3c:	60 e0       	ldi	r22, 0x00	; 0
     a3e:	70 e5       	ldi	r23, 0x50	; 80
     a40:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <uip_connect>
     a44:	90 93 ae 0a 	sts	0x0AAE, r25
     a48:	80 93 ad 0a 	sts	0x0AAD, r24

					if (ThisConn != 0)
     a4c:	89 2b       	or	r24, r25
     a4e:	69 f0       	breq	.+26     	; 0xa6a <main+0x234>
					{
						Debug("Connected to host\r\n");
     a50:	8f ef       	ldi	r24, 0xFF	; 255
     a52:	93 e0       	ldi	r25, 0x03	; 3
     a54:	79 db       	rcall	.-2318   	; 0x148 <Debug>
						ConnectedState = 4;
     a56:	84 e0       	ldi	r24, 0x04	; 4
     a58:	80 93 72 06 	sts	0x0672, r24
						TIME_SET(3001);			// Make the first GET happen straight away
     a5c:	e9 eb       	ldi	r30, 0xB9	; 185
     a5e:	fb e0       	ldi	r31, 0x0B	; 11
     a60:	f0 93 a1 0a 	sts	0x0AA1, r31
     a64:	e0 93 a0 0a 	sts	0x0AA0, r30
     a68:	03 c0       	rjmp	.+6      	; 0xa70 <main+0x23a>
					}
					else
						Debug("Failed to Connect\r\n");
     a6a:	83 e1       	ldi	r24, 0x13	; 19
     a6c:	94 e0       	ldi	r25, 0x04	; 4
     a6e:	6c db       	rcall	.-2344   	; 0x148 <Debug>

					Debug("Maximum Segment Size: 0x"); PrintHex(uip_mss() / 256);
     a70:	87 e2       	ldi	r24, 0x27	; 39
     a72:	94 e0       	ldi	r25, 0x04	; 4
     a74:	69 db       	rcall	.-2350   	; 0x148 <Debug>
     a76:	e0 91 d8 0e 	lds	r30, 0x0ED8
     a7a:	f0 91 d9 0e 	lds	r31, 0x0ED9
     a7e:	83 89       	ldd	r24, Z+19	; 0x13
     a80:	c8 db       	rcall	.-2160   	; 0x212 <PrintHex>
					Debug("0x"); PrintHex(uip_mss() & 255); 
     a82:	80 e4       	ldi	r24, 0x40	; 64
     a84:	94 e0       	ldi	r25, 0x04	; 4
     a86:	60 db       	rcall	.-2368   	; 0x148 <Debug>
     a88:	e0 91 d8 0e 	lds	r30, 0x0ED8
     a8c:	f0 91 d9 0e 	lds	r31, 0x0ED9
     a90:	82 89       	ldd	r24, Z+18	; 0x12
     a92:	bf db       	rcall	.-2178   	; 0x212 <PrintHex>
					Debug("\r\n");
     a94:	8e e6       	ldi	r24, 0x6E	; 110
     a96:	91 e0       	ldi	r25, 0x01	; 1
     a98:	57 db       	rcall	.-2386   	; 0x148 <Debug>
     a9a:	6b cf       	rjmp	.-298    	; 0x972 <main+0x13c>
				}
			break;
			
			case 4:
				TCPIPTask();
     a9c:	81 dd       	rcall	.-1278   	; 0x5a0 <TCPIPTask>
     a9e:	69 cf       	rjmp	.-302    	; 0x972 <main+0x13c>

00000aa0 <DComp_NextCDCControlInterface>:
 *  This comparator searches for the next Interface descriptor of the correct CDC control Class, Subclass and Protocol values.
 *
 *  \return A value from the DSEARCH_Return_ErrorCodes_t enum
 */
uint8_t DComp_NextCDCControlInterface(void* CurrentDescriptor)
{
     aa0:	fc 01       	movw	r30, r24
	if (DESCRIPTOR_TYPE(CurrentDescriptor) == DTYPE_Interface)
     aa2:	81 81       	ldd	r24, Z+1	; 0x01
     aa4:	84 30       	cpi	r24, 0x04	; 4
     aa6:	59 f4       	brne	.+22     	; 0xabe <DComp_NextCDCControlInterface+0x1e>
	{
		/* Check the CDC descriptor class, subclass and protocol, break out if correct control interface found */
		if ((DESCRIPTOR_CAST(CurrentDescriptor, USB_Descriptor_Interface_t).Class    == CDC_CONTROL_CLASS)    &&
     aa8:	85 81       	ldd	r24, Z+5	; 0x05
     aaa:	8f 3f       	cpi	r24, 0xFF	; 255
     aac:	41 f4       	brne	.+16     	; 0xabe <DComp_NextCDCControlInterface+0x1e>
     aae:	86 81       	ldd	r24, Z+6	; 0x06
     ab0:	8f 3f       	cpi	r24, 0xFF	; 255
     ab2:	29 f4       	brne	.+10     	; 0xabe <DComp_NextCDCControlInterface+0x1e>
     ab4:	87 81       	ldd	r24, Z+7	; 0x07
     ab6:	8f 3f       	cpi	r24, 0xFF	; 255
     ab8:	11 f4       	brne	.+4      	; 0xabe <DComp_NextCDCControlInterface+0x1e>
     aba:	80 e0       	ldi	r24, 0x00	; 0
     abc:	08 95       	ret
     abe:	82 e0       	ldi	r24, 0x02	; 2
			return DESCRIPTOR_SEARCH_Found;
		}
	}
	
	return DESCRIPTOR_SEARCH_NotFound;
}
     ac0:	08 95       	ret

00000ac2 <DComp_NextCDCDataInterface>:
 *  This comparator searches for the next Interface descriptor of the correct CDC data Class, Subclass and Protocol values.
 *
 *  \return A value from the DSEARCH_Return_ErrorCodes_t enum
 */
uint8_t DComp_NextCDCDataInterface(void* CurrentDescriptor)
{
     ac2:	fc 01       	movw	r30, r24
	if (DESCRIPTOR_TYPE(CurrentDescriptor) == DTYPE_Interface)
     ac4:	81 81       	ldd	r24, Z+1	; 0x01
     ac6:	84 30       	cpi	r24, 0x04	; 4
     ac8:	59 f4       	brne	.+22     	; 0xae0 <DComp_NextCDCDataInterface+0x1e>
	{
		/* Check the CDC descriptor class, subclass and protocol, break out if correct data interface found */
		if ((DESCRIPTOR_CAST(CurrentDescriptor, USB_Descriptor_Interface_t).Class    == CDC_DATA_CLASS)    &&
     aca:	85 81       	ldd	r24, Z+5	; 0x05
     acc:	8f 3f       	cpi	r24, 0xFF	; 255
     ace:	41 f4       	brne	.+16     	; 0xae0 <DComp_NextCDCDataInterface+0x1e>
     ad0:	86 81       	ldd	r24, Z+6	; 0x06
     ad2:	8f 3f       	cpi	r24, 0xFF	; 255
     ad4:	29 f4       	brne	.+10     	; 0xae0 <DComp_NextCDCDataInterface+0x1e>
     ad6:	87 81       	ldd	r24, Z+7	; 0x07
     ad8:	8f 3f       	cpi	r24, 0xFF	; 255
     ada:	11 f4       	brne	.+4      	; 0xae0 <DComp_NextCDCDataInterface+0x1e>
     adc:	80 e0       	ldi	r24, 0x00	; 0
     ade:	08 95       	ret
     ae0:	82 e0       	ldi	r24, 0x02	; 2
			return DESCRIPTOR_SEARCH_Found;
		}
	}
	
	return DESCRIPTOR_SEARCH_NotFound;
}
     ae2:	08 95       	ret

00000ae4 <DComp_NextCDCDataInterfaceEndpoint>:
 *  using a different comparator to determine if it is another CDC class interface).
 *
 *  \return A value from the DSEARCH_Return_ErrorCodes_t enum
 */
uint8_t DComp_NextCDCDataInterfaceEndpoint(void* CurrentDescriptor)
{
     ae4:	fc 01       	movw	r30, r24
	if (DESCRIPTOR_TYPE(CurrentDescriptor) == DTYPE_Endpoint)
     ae6:	81 81       	ldd	r24, Z+1	; 0x01
     ae8:	85 30       	cpi	r24, 0x05	; 5
     aea:	39 f4       	brne	.+14     	; 0xafa <DComp_NextCDCDataInterfaceEndpoint+0x16>
	{
		uint8_t EndpointType = (DESCRIPTOR_CAST(CurrentDescriptor,
		                                        USB_Descriptor_Endpoint_t).Attributes & EP_TYPE_MASK);
	
		if ((EndpointType == EP_TYPE_BULK) || (EndpointType == EP_TYPE_INTERRUPT))
     aec:	83 81       	ldd	r24, Z+3	; 0x03
     aee:	83 70       	andi	r24, 0x03	; 3
     af0:	82 50       	subi	r24, 0x02	; 2
     af2:	82 30       	cpi	r24, 0x02	; 2
     af4:	30 f4       	brcc	.+12     	; 0xb02 <DComp_NextCDCDataInterfaceEndpoint+0x1e>
     af6:	80 e0       	ldi	r24, 0x00	; 0
     af8:	08 95       	ret
		  return DESCRIPTOR_SEARCH_Found;
	}
	else if (DESCRIPTOR_TYPE(CurrentDescriptor) == DTYPE_Interface)
     afa:	84 30       	cpi	r24, 0x04	; 4
     afc:	11 f4       	brne	.+4      	; 0xb02 <DComp_NextCDCDataInterfaceEndpoint+0x1e>
     afe:	81 e0       	ldi	r24, 0x01	; 1
     b00:	08 95       	ret
     b02:	82 e0       	ldi	r24, 0x02	; 2
	{
		return DESCRIPTOR_SEARCH_Fail;
	}

	return DESCRIPTOR_SEARCH_NotFound;
}
     b04:	08 95       	ret

00000b06 <ProcessConfigurationDescriptor>:
 *  This routine searches for a CDC interface descriptor containing bulk data IN and OUT endpoints, and an interrupt event endpoint.
 *
 *  \return An error code from the \ref CDCHost_GetConfigDescriptorDataCodes_t enum.
 */
uint8_t ProcessConfigurationDescriptor(void)
{
     b06:	5f 92       	push	r5
     b08:	6f 92       	push	r6
     b0a:	7f 92       	push	r7
     b0c:	8f 92       	push	r8
     b0e:	9f 92       	push	r9
     b10:	af 92       	push	r10
     b12:	bf 92       	push	r11
     b14:	cf 92       	push	r12
     b16:	df 92       	push	r13
     b18:	ef 92       	push	r14
     b1a:	ff 92       	push	r15
     b1c:	0f 93       	push	r16
     b1e:	1f 93       	push	r17
     b20:	df 93       	push	r29
     b22:	cf 93       	push	r28
     b24:	cd b7       	in	r28, 0x3d	; 61
     b26:	de b7       	in	r29, 0x3e	; 62
     b28:	c4 50       	subi	r28, 0x04	; 4
     b2a:	d2 40       	sbci	r29, 0x02	; 2
     b2c:	0f b6       	in	r0, 0x3f	; 63
     b2e:	f8 94       	cli
     b30:	de bf       	out	0x3e, r29	; 62
     b32:	0f be       	out	0x3f, r0	; 63
     b34:	cd bf       	out	0x3d, r28	; 61
	uint8_t  ConfigDescriptorData[512];
	void*    CurrConfigLocation = ConfigDescriptorData;
     b36:	ae 01       	movw	r20, r28
     b38:	4b 5f       	subi	r20, 0xFB	; 251
     b3a:	5f 4f       	sbci	r21, 0xFF	; 255
     b3c:	5a 83       	std	Y+2, r21	; 0x02
     b3e:	49 83       	std	Y+1, r20	; 0x01
	uint16_t CurrConfigBytesRem;
	uint8_t  FoundEndpoints = 0;

	/* Retrieve the entire configuration descriptor into the allocated buffer */
	switch (USB_Host_GetDeviceConfigDescriptor(1, &CurrConfigBytesRem, ConfigDescriptorData, sizeof(ConfigDescriptorData)))
     b40:	8e 01       	movw	r16, r28
     b42:	0d 5f       	subi	r16, 0xFD	; 253
     b44:	1f 4f       	sbci	r17, 0xFF	; 255
     b46:	81 e0       	ldi	r24, 0x01	; 1
     b48:	b8 01       	movw	r22, r16
     b4a:	20 e0       	ldi	r18, 0x00	; 0
     b4c:	32 e0       	ldi	r19, 0x02	; 2
     b4e:	0e 94 fb 1b 	call	0x37f6	; 0x37f6 <USB_Host_GetDeviceConfigDescriptor>
     b52:	85 30       	cpi	r24, 0x05	; 5
     b54:	29 f0       	breq	.+10     	; 0xb60 <ProcessConfigurationDescriptor+0x5a>
     b56:	86 30       	cpi	r24, 0x06	; 6
     b58:	29 f0       	breq	.+10     	; 0xb64 <ProcessConfigurationDescriptor+0x5e>
     b5a:	88 23       	and	r24, r24
     b5c:	39 f0       	breq	.+14     	; 0xb6c <ProcessConfigurationDescriptor+0x66>
     b5e:	04 c0       	rjmp	.+8      	; 0xb68 <ProcessConfigurationDescriptor+0x62>
     b60:	82 e0       	ldi	r24, 0x02	; 2
     b62:	97 c0       	rjmp	.+302    	; 0xc92 <ProcessConfigurationDescriptor+0x18c>
     b64:	83 e0       	ldi	r24, 0x03	; 3
     b66:	95 c0       	rjmp	.+298    	; 0xc92 <ProcessConfigurationDescriptor+0x18c>
     b68:	81 e0       	ldi	r24, 0x01	; 1
     b6a:	93 c0       	rjmp	.+294    	; 0xc92 <ProcessConfigurationDescriptor+0x18c>
		default:
			return ControlError;
	}
	
	/* Get the CDC control interface from the configuration descriptor */
	if (USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,
     b6c:	c8 01       	movw	r24, r16
     b6e:	6e 01       	movw	r12, r28
     b70:	08 94       	sec
     b72:	c1 1c       	adc	r12, r1
     b74:	d1 1c       	adc	r13, r1
     b76:	b6 01       	movw	r22, r12
     b78:	40 e5       	ldi	r20, 0x50	; 80
     b7a:	55 e0       	ldi	r21, 0x05	; 5
     b7c:	0e 94 be 1b 	call	0x377c	; 0x377c <USB_GetNextDescriptorComp>
     b80:	88 23       	and	r24, r24
     b82:	09 f0       	breq	.+2      	; 0xb86 <ProcessConfigurationDescriptor+0x80>
     b84:	85 c0       	rjmp	.+266    	; 0xc90 <ProcessConfigurationDescriptor+0x18a>
     b86:	ff 24       	eor	r15, r15

	/* Get the IN and OUT data and IN notification endpoints for the CDC interface */
	while (FoundEndpoints != ((1 << CDC_NOTIFICATIONPIPE) | (1 << CDC_DATAPIPE_IN) | (1 << CDC_DATAPIPE_OUT)))
	{
		/* Fetch the next bulk or interrupt endpoint from the current CDC interface */
		if (USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,
     b88:	48 01       	movw	r8, r16
     b8a:	56 01       	movw	r10, r12
			{
				/* Clear the found endpoints mask, since any already processed endpoints aren't in the CDC interface we need */
				FoundEndpoints = 0;

				/* Disable any already configured pipes from the invalid CDC interfaces */
				Pipe_SelectPipe(CDC_NOTIFICATIONPIPE);
     b8c:	93 e0       	ldi	r25, 0x03	; 3
     b8e:	59 2e       	mov	r5, r25
				Pipe_DisablePipe();
				Pipe_SelectPipe(CDC_DATAPIPE_IN);
     b90:	66 24       	eor	r6, r6
     b92:	63 94       	inc	r6
				Pipe_DisablePipe();
				Pipe_SelectPipe(CDC_DATAPIPE_OUT);
     b94:	82 e0       	ldi	r24, 0x02	; 2
     b96:	78 2e       	mov	r7, r24

	/* Get the IN and OUT data and IN notification endpoints for the CDC interface */
	while (FoundEndpoints != ((1 << CDC_NOTIFICATIONPIPE) | (1 << CDC_DATAPIPE_IN) | (1 << CDC_DATAPIPE_OUT)))
	{
		/* Fetch the next bulk or interrupt endpoint from the current CDC interface */
		if (USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,
     b98:	c4 01       	movw	r24, r8
     b9a:	b5 01       	movw	r22, r10
     b9c:	42 e7       	ldi	r20, 0x72	; 114
     b9e:	55 e0       	ldi	r21, 0x05	; 5
     ba0:	0e 94 be 1b 	call	0x377c	; 0x377c <USB_GetNextDescriptorComp>
     ba4:	88 23       	and	r24, r24
     ba6:	a1 f1       	breq	.+104    	; 0xc10 <ProcessConfigurationDescriptor+0x10a>
		                              DComp_NextCDCDataInterfaceEndpoint) != DESCRIPTOR_SEARCH_COMP_Found)
		{
			/* Check to see if the control interface's notification pipe has been found, if so search for the data interface */
			if (FoundEndpoints & (1 << CDC_NOTIFICATIONPIPE))
     ba8:	f3 fe       	sbrs	r15, 3
     baa:	09 c0       	rjmp	.+18     	; 0xbbe <ProcessConfigurationDescriptor+0xb8>
			{
				/* Get the next CDC data interface from the configuration descriptor (CDC class has two CDC interfaces) */
				if (USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation, 
     bac:	c4 01       	movw	r24, r8
     bae:	b5 01       	movw	r22, r10
     bb0:	41 e6       	ldi	r20, 0x61	; 97
     bb2:	55 e0       	ldi	r21, 0x05	; 5
     bb4:	0e 94 be 1b 	call	0x377c	; 0x377c <USB_GetNextDescriptorComp>
     bb8:	88 23       	and	r24, r24
     bba:	01 f1       	breq	.+64     	; 0xbfc <ProcessConfigurationDescriptor+0xf6>
     bbc:	69 c0       	rjmp	.+210    	; 0xc90 <ProcessConfigurationDescriptor+0x18a>
			{
				/* Clear the found endpoints mask, since any already processed endpoints aren't in the CDC interface we need */
				FoundEndpoints = 0;

				/* Disable any already configured pipes from the invalid CDC interfaces */
				Pipe_SelectPipe(CDC_NOTIFICATIONPIPE);
     bbe:	50 92 a7 00 	sts	0x00A7, r5
				Pipe_DisablePipe();
     bc2:	80 91 a9 00 	lds	r24, 0x00A9
     bc6:	8e 7f       	andi	r24, 0xFE	; 254
     bc8:	80 93 a9 00 	sts	0x00A9, r24
				Pipe_SelectPipe(CDC_DATAPIPE_IN);
     bcc:	60 92 a7 00 	sts	0x00A7, r6
				Pipe_DisablePipe();
     bd0:	80 91 a9 00 	lds	r24, 0x00A9
     bd4:	8e 7f       	andi	r24, 0xFE	; 254
     bd6:	80 93 a9 00 	sts	0x00A9, r24
				Pipe_SelectPipe(CDC_DATAPIPE_OUT);
     bda:	70 92 a7 00 	sts	0x00A7, r7
				Pipe_DisablePipe();
     bde:	80 91 a9 00 	lds	r24, 0x00A9
     be2:	8e 7f       	andi	r24, 0xFE	; 254
     be4:	80 93 a9 00 	sts	0x00A9, r24
			
				/* Get the next CDC control interface from the configuration descriptor (CDC class has two CDC interfaces) */
				if (USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,
     be8:	c4 01       	movw	r24, r8
     bea:	b5 01       	movw	r22, r10
     bec:	40 e5       	ldi	r20, 0x50	; 80
     bee:	55 e0       	ldi	r21, 0x05	; 5
     bf0:	0e 94 be 1b 	call	0x377c	; 0x377c <USB_GetNextDescriptorComp>
     bf4:	88 23       	and	r24, r24
     bf6:	09 f0       	breq	.+2      	; 0xbfa <ProcessConfigurationDescriptor+0xf4>
     bf8:	4b c0       	rjmp	.+150    	; 0xc90 <ProcessConfigurationDescriptor+0x18a>
     bfa:	ff 24       	eor	r15, r15
					return NoCDCInterfaceFound;
				}
			}

			/* Fetch the next bulk or interrupt endpoint from the current CDC interface */
			if (USB_GetNextDescriptorComp(&CurrConfigBytesRem, &CurrConfigLocation,
     bfc:	c4 01       	movw	r24, r8
     bfe:	b5 01       	movw	r22, r10
     c00:	42 e7       	ldi	r20, 0x72	; 114
     c02:	55 e0       	ldi	r21, 0x05	; 5
     c04:	0e 94 be 1b 	call	0x377c	; 0x377c <USB_GetNextDescriptorComp>
     c08:	88 23       	and	r24, r24
     c0a:	11 f0       	breq	.+4      	; 0xc10 <ProcessConfigurationDescriptor+0x10a>
     c0c:	85 e0       	ldi	r24, 0x05	; 5
     c0e:	41 c0       	rjmp	.+130    	; 0xc92 <ProcessConfigurationDescriptor+0x18c>
				/* Descriptor not found, error out */
				return NoEndpointFound;
			}
		}
		
		USB_Descriptor_Endpoint_t* EndpointData = DESCRIPTOR_PCAST(CurrConfigLocation, USB_Descriptor_Endpoint_t);
     c10:	c9 80       	ldd	r12, Y+1	; 0x01
     c12:	da 80       	ldd	r13, Y+2	; 0x02

		/* Check if the found endpoint is a interrupt or bulk type descriptor */
		if ((EndpointData->Attributes & EP_TYPE_MASK) == EP_TYPE_INTERRUPT)
     c14:	f6 01       	movw	r30, r12
     c16:	83 81       	ldd	r24, Z+3	; 0x03
     c18:	83 70       	andi	r24, 0x03	; 3
     c1a:	22 81       	ldd	r18, Z+2	; 0x02
     c1c:	83 30       	cpi	r24, 0x03	; 3
     c1e:	79 f4       	brne	.+30     	; 0xc3e <ProcessConfigurationDescriptor+0x138>
		{
			/* If the endpoint is a IN type interrupt endpoint */
			if (EndpointData->EndpointAddress & ENDPOINT_DESCRIPTOR_DIR_IN)
     c20:	27 ff       	sbrs	r18, 7
     c22:	30 c0       	rjmp	.+96     	; 0xc84 <ProcessConfigurationDescriptor+0x17e>
			{							   
				/* Configure the notification pipe */
				Pipe_ConfigurePipe(CDC_NOTIFICATIONPIPE, EP_TYPE_INTERRUPT, PIPE_TOKEN_IN,
     c24:	04 81       	ldd	r16, Z+4	; 0x04
     c26:	15 81       	ldd	r17, Z+5	; 0x05
     c28:	63 e0       	ldi	r22, 0x03	; 3
     c2a:	40 e1       	ldi	r20, 0x10	; 16
     c2c:	ee 24       	eor	r14, r14
     c2e:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <Pipe_ConfigurePipe>
								   EndpointData->EndpointAddress, EndpointData->EndpointSize, PIPE_BANK_SINGLE);

				Pipe_SetInterruptPeriod(EndpointData->PollingIntervalMS);
     c32:	f6 01       	movw	r30, r12
     c34:	86 81       	ldd	r24, Z+6	; 0x06
     c36:	80 93 ad 00 	sts	0x00AD, r24
				
				/* Set the flag indicating that the notification pipe has been found */
				FoundEndpoints |= (1 << CDC_NOTIFICATIONPIPE);
     c3a:	f8 e0       	ldi	r31, 0x08	; 8
     c3c:	22 c0       	rjmp	.+68     	; 0xc82 <ProcessConfigurationDescriptor+0x17c>
			}
		}
		else
		{
			/* Check if the endpoint is a bulk IN or bulk OUT endpoint */
			if (EndpointData->EndpointAddress & ENDPOINT_DESCRIPTOR_DIR_IN)
     c3e:	27 ff       	sbrs	r18, 7
     c40:	16 c0       	rjmp	.+44     	; 0xc6e <ProcessConfigurationDescriptor+0x168>
			{
				/* Kill the configured OUT pipe if the data endpoints are bidirectional */
				if (Pipe_IsEndpointBound(EndpointData->EndpointAddress))
     c42:	82 2f       	mov	r24, r18
     c44:	0e 94 5a 1a 	call	0x34b4	; 0x34b4 <Pipe_IsEndpointBound>
     c48:	88 23       	and	r24, r24
     c4a:	29 f0       	breq	.+10     	; 0xc56 <ProcessConfigurationDescriptor+0x150>
				  Pipe_DisablePipe();
     c4c:	80 91 a9 00 	lds	r24, 0x00A9
     c50:	8e 7f       	andi	r24, 0xFE	; 254
     c52:	80 93 a9 00 	sts	0x00A9, r24

				/* Configure the data IN pipe */
				Pipe_ConfigurePipe(CDC_DATAPIPE_IN, EP_TYPE_BULK, PIPE_TOKEN_IN,
     c56:	f6 01       	movw	r30, r12
     c58:	04 81       	ldd	r16, Z+4	; 0x04
     c5a:	15 81       	ldd	r17, Z+5	; 0x05
     c5c:	81 e0       	ldi	r24, 0x01	; 1
     c5e:	62 e0       	ldi	r22, 0x02	; 2
     c60:	40 e1       	ldi	r20, 0x10	; 16
     c62:	22 81       	ldd	r18, Z+2	; 0x02
     c64:	ee 24       	eor	r14, r14
     c66:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <Pipe_ConfigurePipe>
								   EndpointData->EndpointAddress, EndpointData->EndpointSize, PIPE_BANK_SINGLE);
				
				/* Set the flag indicating that the data IN pipe has been found */
				FoundEndpoints |= (1 << CDC_DATAPIPE_IN);
     c6a:	f2 e0       	ldi	r31, 0x02	; 2
     c6c:	0a c0       	rjmp	.+20     	; 0xc82 <ProcessConfigurationDescriptor+0x17c>
			{
				/* Only configure the OUT data pipe if the data endpoints haev not shown to be bidirectional */
				//if (!(Pipe_IsEndpointBound(EndpointData->EndpointAddress)))
				{
					/* Configure the data OUT pipe */
					Pipe_ConfigurePipe(CDC_DATAPIPE_OUT, EP_TYPE_BULK, PIPE_TOKEN_OUT,
     c6e:	f6 01       	movw	r30, r12
     c70:	04 81       	ldd	r16, Z+4	; 0x04
     c72:	15 81       	ldd	r17, Z+5	; 0x05
     c74:	82 e0       	ldi	r24, 0x02	; 2
     c76:	62 e0       	ldi	r22, 0x02	; 2
     c78:	40 e2       	ldi	r20, 0x20	; 32
     c7a:	ee 24       	eor	r14, r14
     c7c:	0e 94 ea 19 	call	0x33d4	; 0x33d4 <Pipe_ConfigurePipe>
									   EndpointData->EndpointAddress, EndpointData->EndpointSize, PIPE_BANK_SINGLE);
				}
				
				/* Set the flag indicating that the data OUT pipe has been found */
				FoundEndpoints |= (1 << CDC_DATAPIPE_OUT);
     c80:	f4 e0       	ldi	r31, 0x04	; 4
     c82:	ff 2a       	or	r15, r31
		/* Descriptor not found, error out */
		return NoCDCInterfaceFound;
	}

	/* Get the IN and OUT data and IN notification endpoints for the CDC interface */
	while (FoundEndpoints != ((1 << CDC_NOTIFICATIONPIPE) | (1 << CDC_DATAPIPE_IN) | (1 << CDC_DATAPIPE_OUT)))
     c84:	8e e0       	ldi	r24, 0x0E	; 14
     c86:	f8 16       	cp	r15, r24
     c88:	09 f0       	breq	.+2      	; 0xc8c <ProcessConfigurationDescriptor+0x186>
     c8a:	86 cf       	rjmp	.-244    	; 0xb98 <ProcessConfigurationDescriptor+0x92>
     c8c:	80 e0       	ldi	r24, 0x00	; 0
     c8e:	01 c0       	rjmp	.+2      	; 0xc92 <ProcessConfigurationDescriptor+0x18c>
     c90:	84 e0       	ldi	r24, 0x04	; 4
		}
	}

	/* Valid data found, return success */
	return SuccessfulConfigRead;
}
     c92:	cc 5f       	subi	r28, 0xFC	; 252
     c94:	dd 4f       	sbci	r29, 0xFD	; 253
     c96:	0f b6       	in	r0, 0x3f	; 63
     c98:	f8 94       	cli
     c9a:	de bf       	out	0x3e, r29	; 62
     c9c:	0f be       	out	0x3f, r0	; 63
     c9e:	cd bf       	out	0x3d, r28	; 61
     ca0:	cf 91       	pop	r28
     ca2:	df 91       	pop	r29
     ca4:	1f 91       	pop	r17
     ca6:	0f 91       	pop	r16
     ca8:	ff 90       	pop	r15
     caa:	ef 90       	pop	r14
     cac:	df 90       	pop	r13
     cae:	cf 90       	pop	r12
     cb0:	bf 90       	pop	r11
     cb2:	af 90       	pop	r10
     cb4:	9f 90       	pop	r9
     cb6:	8f 90       	pop	r8
     cb8:	7f 90       	pop	r7
     cba:	6f 90       	pop	r6
     cbc:	5f 90       	pop	r5
     cbe:	08 95       	ret

00000cc0 <__vector_25>:
SIGNAL(UART1_RECEIVE_INTERRUPT)
/*************************************************************************
Function: UART1 Receive Complete interrupt
Purpose:  called when the UART1 has received a character
**************************************************************************/
{
     cc0:	1f 92       	push	r1
     cc2:	0f 92       	push	r0
     cc4:	0f b6       	in	r0, 0x3f	; 63
     cc6:	0f 92       	push	r0
     cc8:	0b b6       	in	r0, 0x3b	; 59
     cca:	0f 92       	push	r0
     ccc:	11 24       	eor	r1, r1
     cce:	2f 93       	push	r18
     cd0:	8f 93       	push	r24
     cd2:	9f 93       	push	r25
     cd4:	ef 93       	push	r30
     cd6:	ff 93       	push	r31
    unsigned char usr;
    unsigned char lastRxError;
 
 
    /* read UART status register and UART data register */ 
    usr  = UART1_STATUS;
     cd8:	90 91 c8 00 	lds	r25, 0x00C8
    data = UART1_DATA;
     cdc:	20 91 ce 00 	lds	r18, 0x00CE
    
    /* */
    lastRxError = (usr & (_BV(FE1)|_BV(DOR1)) );
        
    /* calculate buffer index */ 
    tmphead = ( UART1_RxHead + 1) & UART_RX_BUFFER_MASK;
     ce0:	e0 91 78 08 	lds	r30, 0x0878
     ce4:	ef 5f       	subi	r30, 0xFF	; 255
    
    if ( tmphead == UART1_RxTail ) {
     ce6:	80 91 79 08 	lds	r24, 0x0879
     cea:	e8 17       	cp	r30, r24
     cec:	11 f4       	brne	.+4      	; 0xcf2 <__vector_25+0x32>
     cee:	82 e0       	ldi	r24, 0x02	; 2
     cf0:	08 c0       	rjmp	.+16     	; 0xd02 <__vector_25+0x42>
    /* read UART status register and UART data register */ 
    usr  = UART1_STATUS;
    data = UART1_DATA;
    
    /* */
    lastRxError = (usr & (_BV(FE1)|_BV(DOR1)) );
     cf2:	89 2f       	mov	r24, r25
     cf4:	88 71       	andi	r24, 0x18	; 24
    if ( tmphead == UART1_RxTail ) {
        /* error: receive buffer overflow */
        lastRxError = UART_BUFFER_OVERFLOW >> 8;
    }else{
        /* store new index */
        UART1_RxHead = tmphead;
     cf6:	e0 93 78 08 	sts	0x0878, r30
        /* store received data in buffer */
        UART1_RxBuf[tmphead] = data;
     cfa:	f0 e0       	ldi	r31, 0x00	; 0
     cfc:	ea 58       	subi	r30, 0x8A	; 138
     cfe:	f8 4f       	sbci	r31, 0xF8	; 248
     d00:	20 83       	st	Z, r18
    }
    UART1_LastRxError = lastRxError;   
     d02:	80 93 7a 08 	sts	0x087A, r24
}
     d06:	ff 91       	pop	r31
     d08:	ef 91       	pop	r30
     d0a:	9f 91       	pop	r25
     d0c:	8f 91       	pop	r24
     d0e:	2f 91       	pop	r18
     d10:	0f 90       	pop	r0
     d12:	0b be       	out	0x3b, r0	; 59
     d14:	0f 90       	pop	r0
     d16:	0f be       	out	0x3f, r0	; 63
     d18:	0f 90       	pop	r0
     d1a:	1f 90       	pop	r1
     d1c:	18 95       	reti

00000d1e <__vector_26>:
SIGNAL(UART1_TRANSMIT_INTERRUPT)
/*************************************************************************
Function: UART1 Data Register Empty interrupt
Purpose:  called when the UART1 is ready to transmit the next byte
**************************************************************************/
{
     d1e:	1f 92       	push	r1
     d20:	0f 92       	push	r0
     d22:	0f b6       	in	r0, 0x3f	; 63
     d24:	0f 92       	push	r0
     d26:	0b b6       	in	r0, 0x3b	; 59
     d28:	0f 92       	push	r0
     d2a:	11 24       	eor	r1, r1
     d2c:	8f 93       	push	r24
     d2e:	9f 93       	push	r25
     d30:	ef 93       	push	r30
     d32:	ff 93       	push	r31
    unsigned char tmptail;

    
    if ( UART1_TxHead != UART1_TxTail) {
     d34:	90 91 76 08 	lds	r25, 0x0876
     d38:	80 91 77 08 	lds	r24, 0x0877
     d3c:	98 17       	cp	r25, r24
     d3e:	61 f0       	breq	.+24     	; 0xd58 <__vector_26+0x3a>
        /* calculate and store new buffer index */
        tmptail = (UART1_TxTail + 1) & UART_TX_BUFFER_MASK;
     d40:	e0 91 77 08 	lds	r30, 0x0877
     d44:	ef 5f       	subi	r30, 0xFF	; 255
        UART1_TxTail = tmptail;
     d46:	e0 93 77 08 	sts	0x0877, r30
        /* get one byte from buffer and write it to UART */
        UART1_DATA = UART1_TxBuf[tmptail];  /* start transmission */
     d4a:	f0 e0       	ldi	r31, 0x00	; 0
     d4c:	ea 58       	subi	r30, 0x8A	; 138
     d4e:	f9 4f       	sbci	r31, 0xF9	; 249
     d50:	80 81       	ld	r24, Z
     d52:	80 93 ce 00 	sts	0x00CE, r24
     d56:	05 c0       	rjmp	.+10     	; 0xd62 <__vector_26+0x44>
    }else{
        /* tx buffer empty, disable UDRE interrupt */
        UART1_CONTROL &= ~_BV(UART1_UDRIE);
     d58:	80 91 c9 00 	lds	r24, 0x00C9
     d5c:	8f 7d       	andi	r24, 0xDF	; 223
     d5e:	80 93 c9 00 	sts	0x00C9, r24
    }
}
     d62:	ff 91       	pop	r31
     d64:	ef 91       	pop	r30
     d66:	9f 91       	pop	r25
     d68:	8f 91       	pop	r24
     d6a:	0f 90       	pop	r0
     d6c:	0b be       	out	0x3b, r0	; 59
     d6e:	0f 90       	pop	r0
     d70:	0f be       	out	0x3f, r0	; 63
     d72:	0f 90       	pop	r0
     d74:	1f 90       	pop	r1
     d76:	18 95       	reti

00000d78 <uart1_init>:
Purpose:  initialize UART1 and set baudrate
Input:    baudrate using macro UART_BAUD_SELECT()
Returns:  none
**************************************************************************/
void uart1_init(unsigned int baudrate)
{
     d78:	9c 01       	movw	r18, r24
    UART1_TxHead = 0;
     d7a:	10 92 76 08 	sts	0x0876, r1
    UART1_TxTail = 0;
     d7e:	10 92 77 08 	sts	0x0877, r1
    UART1_RxHead = 0;
     d82:	10 92 78 08 	sts	0x0878, r1
    UART1_RxTail = 0;
     d86:	10 92 79 08 	sts	0x0879, r1
    

    /* Set baud rate */
    if ( baudrate & 0x8000 ) 
     d8a:	97 ff       	sbrs	r25, 7
     d8c:	04 c0       	rjmp	.+8      	; 0xd96 <uart1_init+0x1e>
    {
    	UART1_STATUS = (1<<U2X1);  //Enable 2x speed 
     d8e:	82 e0       	ldi	r24, 0x02	; 2
     d90:	80 93 c8 00 	sts	0x00C8, r24
      baudrate &= ~0x8000;
     d94:	3f 77       	andi	r19, 0x7F	; 127
    }
    UBRR1H = (unsigned char)(baudrate>>8);
     d96:	30 93 cd 00 	sts	0x00CD, r19
    UBRR1L = (unsigned char) baudrate;
     d9a:	20 93 cc 00 	sts	0x00CC, r18

    /* Enable USART receiver and transmitter and receive complete interrupt */
    UART1_CONTROL = _BV(RXCIE1)|(1<<RXEN1)|(1<<TXEN1);
     d9e:	88 e9       	ldi	r24, 0x98	; 152
     da0:	80 93 c9 00 	sts	0x00C9, r24
    
    /* Set frame format: asynchronous, 8data, no parity, 1stop bit */   
    #ifdef URSEL1
    UCSR1C = (1<<URSEL1)|(3<<UCSZ10);
    #else
    UCSR1C = (3<<UCSZ10);
     da4:	86 e0       	ldi	r24, 0x06	; 6
     da6:	80 93 ca 00 	sts	0x00CA, r24
    #endif 
}/* uart_init */
     daa:	08 95       	ret

00000dac <uart1_getc>:
{    
    unsigned char tmptail;
    unsigned char data;


    if ( UART1_RxHead == UART1_RxTail ) {
     dac:	90 91 78 08 	lds	r25, 0x0878
     db0:	80 91 79 08 	lds	r24, 0x0879
     db4:	98 17       	cp	r25, r24
     db6:	19 f4       	brne	.+6      	; 0xdbe <uart1_getc+0x12>
     db8:	20 e0       	ldi	r18, 0x00	; 0
     dba:	31 e0       	ldi	r19, 0x01	; 1
     dbc:	11 c0       	rjmp	.+34     	; 0xde0 <uart1_getc+0x34>
        return UART_NO_DATA;   /* no data available */
    }
    
    /* calculate /store buffer index */
    tmptail = (UART1_RxTail + 1) & UART_RX_BUFFER_MASK;
     dbe:	e0 91 79 08 	lds	r30, 0x0879
     dc2:	ef 5f       	subi	r30, 0xFF	; 255
    UART1_RxTail = tmptail; 
     dc4:	e0 93 79 08 	sts	0x0879, r30
    
    /* get data from receive buffer */
    data = UART1_RxBuf[tmptail];
     dc8:	f0 e0       	ldi	r31, 0x00	; 0
     dca:	ea 58       	subi	r30, 0x8A	; 138
     dcc:	f8 4f       	sbci	r31, 0xF8	; 248
     dce:	30 81       	ld	r19, Z
    
    return (UART1_LastRxError << 8) + data;
     dd0:	20 91 7a 08 	lds	r18, 0x087A
     dd4:	92 2f       	mov	r25, r18
     dd6:	80 e0       	ldi	r24, 0x00	; 0
     dd8:	ac 01       	movw	r20, r24
     dda:	43 0f       	add	r20, r19
     ddc:	51 1d       	adc	r21, r1
     dde:	9a 01       	movw	r18, r20

}/* uart1_getc */
     de0:	c9 01       	movw	r24, r18
     de2:	08 95       	ret

00000de4 <uart1_putc>:
Purpose:  write byte to ringbuffer for transmitting via UART
Input:    byte to be transmitted
Returns:  none          
**************************************************************************/
void uart1_putc(unsigned char data)
{
     de4:	28 2f       	mov	r18, r24
    unsigned char tmphead;

    
    tmphead  = (UART1_TxHead + 1) & UART_TX_BUFFER_MASK;
     de6:	90 91 76 08 	lds	r25, 0x0876
     dea:	9f 5f       	subi	r25, 0xFF	; 255
    
    while ( tmphead == UART1_TxTail ){
     dec:	80 91 77 08 	lds	r24, 0x0877
     df0:	98 17       	cp	r25, r24
     df2:	e1 f3       	breq	.-8      	; 0xdec <uart1_putc+0x8>
        ;/* wait for free space in buffer */
    }
    
    UART1_TxBuf[tmphead] = data;
     df4:	e9 2f       	mov	r30, r25
     df6:	f0 e0       	ldi	r31, 0x00	; 0
     df8:	ea 58       	subi	r30, 0x8A	; 138
     dfa:	f9 4f       	sbci	r31, 0xF9	; 249
     dfc:	20 83       	st	Z, r18
    UART1_TxHead = tmphead;
     dfe:	90 93 76 08 	sts	0x0876, r25

    /* enable UDRE interrupt */
    UART1_CONTROL    |= _BV(UART1_UDRIE);
     e02:	80 91 c9 00 	lds	r24, 0x00C9
     e06:	80 62       	ori	r24, 0x20	; 32
     e08:	80 93 c9 00 	sts	0x00C9, r24

}/* uart1_putc */
     e0c:	08 95       	ret

00000e0e <uart1_puts>:
Purpose:  transmit string to UART1
Input:    string to be transmitted
Returns:  none          
**************************************************************************/
void uart1_puts(const char *s )
{
     e0e:	dc 01       	movw	r26, r24
     e10:	14 c0       	rjmp	.+40     	; 0xe3a <uart1_puts+0x2c>
void uart1_putc(unsigned char data)
{
    unsigned char tmphead;

    
    tmphead  = (UART1_TxHead + 1) & UART_TX_BUFFER_MASK;
     e12:	90 91 76 08 	lds	r25, 0x0876
     e16:	9f 5f       	subi	r25, 0xFF	; 255
    
    while ( tmphead == UART1_TxTail ){
     e18:	80 91 77 08 	lds	r24, 0x0877
     e1c:	98 17       	cp	r25, r24
     e1e:	e1 f3       	breq	.-8      	; 0xe18 <uart1_puts+0xa>
Returns:  none          
**************************************************************************/
void uart1_puts(const char *s )
{
    while (*s) 
      uart1_putc(*s++);
     e20:	11 96       	adiw	r26, 0x01	; 1
    
    while ( tmphead == UART1_TxTail ){
        ;/* wait for free space in buffer */
    }
    
    UART1_TxBuf[tmphead] = data;
     e22:	e9 2f       	mov	r30, r25
     e24:	f0 e0       	ldi	r31, 0x00	; 0
     e26:	ea 58       	subi	r30, 0x8A	; 138
     e28:	f9 4f       	sbci	r31, 0xF9	; 249
     e2a:	20 83       	st	Z, r18
    UART1_TxHead = tmphead;
     e2c:	90 93 76 08 	sts	0x0876, r25

    /* enable UDRE interrupt */
    UART1_CONTROL    |= _BV(UART1_UDRIE);
     e30:	80 91 c9 00 	lds	r24, 0x00C9
     e34:	80 62       	ori	r24, 0x20	; 32
     e36:	80 93 c9 00 	sts	0x00C9, r24
Input:    string to be transmitted
Returns:  none          
**************************************************************************/
void uart1_puts(const char *s )
{
    while (*s) 
     e3a:	2c 91       	ld	r18, X
     e3c:	22 23       	and	r18, r18
     e3e:	49 f7       	brne	.-46     	; 0xe12 <uart1_puts+0x4>
      uart1_putc(*s++);

}/* uart1_puts */
     e40:	08 95       	ret

00000e42 <modem_init>:
static volatile unsigned char MODEM_RxTail;
static volatile unsigned char MODEM_LastRxError;

void modem_init(void)
{
	MODEM_TxHead = 0;
     e42:	10 92 7b 0a 	sts	0x0A7B, r1
    MODEM_TxTail = 0;
     e46:	10 92 7c 0a 	sts	0x0A7C, r1
    MODEM_RxHead = 0;
     e4a:	10 92 7d 0a 	sts	0x0A7D, r1
    MODEM_RxTail = 0;
     e4e:	10 92 7e 0a 	sts	0x0A7E, r1
}
     e52:	08 95       	ret

00000e54 <modem_getc>:
unsigned int modem_getc(void)
{    
    unsigned char tmptail;
    unsigned char data;

    if (MODEM_RxHead == MODEM_RxTail)
     e54:	90 91 7d 0a 	lds	r25, 0x0A7D
     e58:	80 91 7e 0a 	lds	r24, 0x0A7E
     e5c:	98 17       	cp	r25, r24
     e5e:	19 f4       	brne	.+6      	; 0xe66 <modem_getc+0x12>
     e60:	20 e0       	ldi	r18, 0x00	; 0
     e62:	31 e0       	ldi	r19, 0x01	; 1
     e64:	11 c0       	rjmp	.+34     	; 0xe88 <modem_getc+0x34>
	{
        return MODEM_NO_DATA;   // no data available 
    }
    
    // Calculate/store buffer index 
    tmptail = (MODEM_RxTail + 1) & MODEM_RX_BUFFER_MASK;
     e66:	e0 91 7e 0a 	lds	r30, 0x0A7E
     e6a:	ef 5f       	subi	r30, 0xFF	; 255
    MODEM_RxTail = tmptail; 
     e6c:	e0 93 7e 0a 	sts	0x0A7E, r30
    
    // Get data from receive buffer
    data = MODEM_RxBuf[tmptail];
     e70:	f0 e0       	ldi	r31, 0x00	; 0
     e72:	e5 58       	subi	r30, 0x85	; 133
     e74:	f6 4f       	sbci	r31, 0xF6	; 246
     e76:	30 81       	ld	r19, Z
    
    return (MODEM_LastRxError << 8) + data;
     e78:	20 91 7f 0a 	lds	r18, 0x0A7F
     e7c:	92 2f       	mov	r25, r18
     e7e:	80 e0       	ldi	r24, 0x00	; 0
     e80:	ac 01       	movw	r20, r24
     e82:	43 0f       	add	r20, r19
     e84:	51 1d       	adc	r21, r1
     e86:	9a 01       	movw	r18, r20
}
     e88:	c9 01       	movw	r24, r18
     e8a:	08 95       	ret

00000e8c <modem_TxBufferEmpty>:
      modem_putc(*s++);
}

bool modem_TxBufferEmpty()
{
	if (MODEM_TxHead == MODEM_TxTail)
     e8c:	90 91 7b 0a 	lds	r25, 0x0A7B
     e90:	80 91 7c 0a 	lds	r24, 0x0A7C
     e94:	20 e0       	ldi	r18, 0x00	; 0
     e96:	98 17       	cp	r25, r24
     e98:	09 f4       	brne	.+2      	; 0xe9c <modem_TxBufferEmpty+0x10>
     e9a:	21 e0       	ldi	r18, 0x01	; 1
		return true;
	else
		return false;
}
     e9c:	82 2f       	mov	r24, r18
     e9e:	08 95       	ret

00000ea0 <modem_getTxBuffer>:
	else
		return false;
}

unsigned int modem_getTxBuffer(unsigned char *s, int maxSize)
{
     ea0:	ac 01       	movw	r20, r24
     ea2:	20 e0       	ldi	r18, 0x00	; 0
     ea4:	30 e0       	ldi	r19, 0x00	; 0
     ea6:	0f c0       	rjmp	.+30     	; 0xec6 <modem_getTxBuffer+0x26>
	unsigned int i = 0;
		
	while (MODEM_TxHead != MODEM_TxTail && maxSize < MODEM_TX_BUFFER_SIZE)
	{
		// Calculate and store new buffer index 
		tmptail = (MODEM_TxTail + 1) & MODEM_TX_BUFFER_MASK;
     ea8:	e0 91 7c 0a 	lds	r30, 0x0A7C
     eac:	ef 5f       	subi	r30, 0xFF	; 255
	    MODEM_TxTail = tmptail;
     eae:	e0 93 7c 0a 	sts	0x0A7C, r30

	    // Get one byte from buffer and write it to the buffer
	    s[i++] = MODEM_TxBuf[tmptail];
     eb2:	f0 e0       	ldi	r31, 0x00	; 0
     eb4:	e5 58       	subi	r30, 0x85	; 133
     eb6:	f7 4f       	sbci	r31, 0xF7	; 247
     eb8:	80 81       	ld	r24, Z
     eba:	fa 01       	movw	r30, r20
     ebc:	e2 0f       	add	r30, r18
     ebe:	f3 1f       	adc	r31, r19
     ec0:	80 83       	st	Z, r24
     ec2:	2f 5f       	subi	r18, 0xFF	; 255
     ec4:	3f 4f       	sbci	r19, 0xFF	; 255
unsigned int modem_getTxBuffer(unsigned char *s, int maxSize)
{
	unsigned char tmptail;
	unsigned int i = 0;
		
	while (MODEM_TxHead != MODEM_TxTail && maxSize < MODEM_TX_BUFFER_SIZE)
     ec6:	90 91 7b 0a 	lds	r25, 0x0A7B
     eca:	80 91 7c 0a 	lds	r24, 0x0A7C
     ece:	98 17       	cp	r25, r24
     ed0:	21 f0       	breq	.+8      	; 0xeda <modem_getTxBuffer+0x3a>
     ed2:	6f 3f       	cpi	r22, 0xFF	; 255
     ed4:	71 05       	cpc	r23, r1
     ed6:	41 f3       	breq	.-48     	; 0xea8 <modem_getTxBuffer+0x8>
     ed8:	3c f3       	brlt	.-50     	; 0xea8 <modem_getTxBuffer+0x8>
	    // Get one byte from buffer and write it to the buffer
	    s[i++] = MODEM_TxBuf[tmptail];
	}

	return i;
}
     eda:	c9 01       	movw	r24, r18
     edc:	08 95       	ret

00000ede <modem_putRxBuffer>:

unsigned int modem_putRxBuffer(unsigned char *s, int size)
{
     ede:	ac 01       	movw	r20, r24
     ee0:	20 e0       	ldi	r18, 0x00	; 0
     ee2:	30 e0       	ldi	r19, 0x00	; 0
     ee4:	16 c0       	rjmp	.+44     	; 0xf12 <modem_putRxBuffer+0x34>
	unsigned char tmphead;
	unsigned int lastRxError = 0;
	
	for (unsigned int BufferByte = 0; BufferByte < size; BufferByte++)
	{
		tmphead = (MODEM_RxHead + 1) & MODEM_RX_BUFFER_MASK;
     ee6:	e0 91 7d 0a 	lds	r30, 0x0A7D
     eea:	ef 5f       	subi	r30, 0xFF	; 255
		
		if (tmphead == MODEM_RxTail)							// Error - receive buffer overflow
     eec:	80 91 7e 0a 	lds	r24, 0x0A7E
     ef0:	e8 17       	cp	r30, r24
     ef2:	19 f4       	brne	.+6      	; 0xefa <modem_putRxBuffer+0x1c>
     ef4:	22 e0       	ldi	r18, 0x02	; 2
     ef6:	30 e0       	ldi	r19, 0x00	; 0
     ef8:	11 c0       	rjmp	.+34     	; 0xf1c <modem_putRxBuffer+0x3e>
	        lastRxError = MODEM_BUFFER_OVERFLOW >> 8;
			break;
	    }
		else
		{
			MODEM_RxHead = tmphead;								// Store new index
     efa:	e0 93 7d 0a 	sts	0x0A7D, r30
			MODEM_RxBuf[tmphead] = s[BufferByte];			// Store received data in buffer
     efe:	f0 e0       	ldi	r31, 0x00	; 0
     f00:	da 01       	movw	r26, r20
     f02:	a2 0f       	add	r26, r18
     f04:	b3 1f       	adc	r27, r19
     f06:	8c 91       	ld	r24, X
     f08:	e5 58       	subi	r30, 0x85	; 133
     f0a:	f6 4f       	sbci	r31, 0xF6	; 246
     f0c:	80 83       	st	Z, r24
unsigned int modem_putRxBuffer(unsigned char *s, int size)
{
	unsigned char tmphead;
	unsigned int lastRxError = 0;
	
	for (unsigned int BufferByte = 0; BufferByte < size; BufferByte++)
     f0e:	2f 5f       	subi	r18, 0xFF	; 255
     f10:	3f 4f       	sbci	r19, 0xFF	; 255
     f12:	26 17       	cp	r18, r22
     f14:	37 07       	cpc	r19, r23
     f16:	38 f3       	brcs	.-50     	; 0xee6 <modem_putRxBuffer+0x8>
     f18:	20 e0       	ldi	r18, 0x00	; 0
     f1a:	30 e0       	ldi	r19, 0x00	; 0
			MODEM_RxBuf[tmphead] = s[BufferByte];			// Store received data in buffer
	    }
	}

	return lastRxError;
}
     f1c:	c9 01       	movw	r24, r18
     f1e:	08 95       	ret

00000f20 <modem_putc>:
    
    return (MODEM_LastRxError << 8) + data;
}

void modem_putc(unsigned char data)
{
     f20:	28 2f       	mov	r18, r24
    unsigned char tmphead;
    
    tmphead  = (MODEM_TxHead + 1) & MODEM_TX_BUFFER_MASK;
     f22:	90 91 7b 0a 	lds	r25, 0x0A7B
     f26:	9f 5f       	subi	r25, 0xFF	; 255
    
    if (tmphead == MODEM_TxTail) 	// Error - transmit buffer overflow
     f28:	80 91 7c 0a 	lds	r24, 0x0A7C
     f2c:	98 17       	cp	r25, r24
     f2e:	31 f4       	brne	.+12     	; 0xf3c <modem_putc+0x1c>
	{
        MODEM_LastRxError = MODEM_BUFFER_OVERFLOW >> 8;
     f30:	82 e0       	ldi	r24, 0x02	; 2
     f32:	80 93 7f 0a 	sts	0x0A7F, r24
		Debug("Modem Buffer Overflow\r\n");
     f36:	80 ed       	ldi	r24, 0xD0	; 208
     f38:	94 e0       	ldi	r25, 0x04	; 4
     f3a:	06 c9       	rjmp	.-3572   	; 0x148 <Debug>
		return;
    }
    
    MODEM_TxBuf[tmphead] = data;
     f3c:	e9 2f       	mov	r30, r25
     f3e:	f0 e0       	ldi	r31, 0x00	; 0
     f40:	e5 58       	subi	r30, 0x85	; 133
     f42:	f7 4f       	sbci	r31, 0xF7	; 247
     f44:	20 83       	st	Z, r18
    MODEM_TxHead = tmphead;
     f46:	90 93 7b 0a 	sts	0x0A7B, r25
     f4a:	08 95       	ret

00000f4c <modem_puts>:
}

void modem_puts(const char *s)
{
     f4c:	cf 93       	push	r28
     f4e:	df 93       	push	r29
     f50:	ec 01       	movw	r28, r24
     f52:	02 c0       	rjmp	.+4      	; 0xf58 <modem_puts+0xc>
    while (*s) 
      modem_putc(*s++);
     f54:	21 96       	adiw	r28, 0x01	; 1
     f56:	e4 df       	rcall	.-56     	; 0xf20 <modem_putc>
    MODEM_TxHead = tmphead;
}

void modem_puts(const char *s)
{
    while (*s) 
     f58:	88 81       	ld	r24, Y
     f5a:	88 23       	and	r24, r24
     f5c:	d9 f7       	brne	.-10     	; 0xf54 <modem_puts+0x8>
      modem_putc(*s++);
}
     f5e:	df 91       	pop	r29
     f60:	cf 91       	pop	r28
     f62:	08 95       	ret

00000f64 <CreatePacket>:
//   packettype is the packet type (e.g. REQ, ACK, NAK)
//   packetID is the packet ID
//   *str is the packet data to be added after the header
// Returns the packet as a string in tx_str
void CreatePacket(unsigned int protocol, unsigned char packetType, unsigned char packetID, const unsigned char *str)
{
     f64:	d9 01       	movw	r26, r18
	unsigned int length, temp;

	tx_ptr = 1;													// Point to 2nd char in transmit buffer. 1st char is length
	tx_str[0] = ' ';											// Dummy first character. Will be overwritten by frame char (0x7e) when the packet is sent out
     f66:	20 e2       	ldi	r18, 0x20	; 32
     f68:	20 93 bf 0a 	sts	0x0ABF, r18
static __inline__ uint16_t
_crc_ccitt_update (uint16_t __crc, uint8_t __data)
{
    uint16_t __ret;

    __asm__ __volatile__ (
     f6c:	5f ef       	ldi	r21, 0xFF	; 255
     f6e:	2f ef       	ldi	r18, 0xFF	; 255
     f70:	3f ef       	ldi	r19, 0xFF	; 255
     f72:	25 27       	eor	r18, r21
     f74:	02 2e       	mov	r0, r18
     f76:	22 95       	swap	r18
     f78:	20 7f       	andi	r18, 0xF0	; 240
     f7a:	20 25       	eor	r18, r0
     f7c:	03 2e       	mov	r0, r19
     f7e:	32 2f       	mov	r19, r18
     f80:	22 95       	swap	r18
     f82:	2f 70       	andi	r18, 0x0F	; 15
     f84:	02 26       	eor	r0, r18
     f86:	26 95       	lsr	r18
     f88:	32 27       	eor	r19, r18
     f8a:	23 27       	eor	r18, r19
     f8c:	22 0f       	add	r18, r18
     f8e:	22 0f       	add	r18, r18
     f90:	22 0f       	add	r18, r18
     f92:	20 25       	eor	r18, r0

// Add character to the new packet & update the checksum
void AddToPacket(unsigned char c)
{
	checksum2 = CRC(checksum2, c);								// Add CRC from this char to running total
  	tx_str[tx_ptr++] = c;										// Store character in the transmit buffer
     f94:	50 93 c0 0a 	sts	0x0AC0, r21
     f98:	53 e0       	ldi	r21, 0x03	; 3
     f9a:	25 27       	eor	r18, r21
     f9c:	02 2e       	mov	r0, r18
     f9e:	22 95       	swap	r18
     fa0:	20 7f       	andi	r18, 0xF0	; 240
     fa2:	20 25       	eor	r18, r0
     fa4:	03 2e       	mov	r0, r19
     fa6:	32 2f       	mov	r19, r18
     fa8:	22 95       	swap	r18
     faa:	2f 70       	andi	r18, 0x0F	; 15
     fac:	02 26       	eor	r0, r18
     fae:	26 95       	lsr	r18
     fb0:	32 27       	eor	r19, r18
     fb2:	23 27       	eor	r18, r19
     fb4:	22 0f       	add	r18, r18
     fb6:	22 0f       	add	r18, r18
     fb8:	22 0f       	add	r18, r18
     fba:	20 25       	eor	r18, r0
     fbc:	50 93 c1 0a 	sts	0x0AC1, r21
     fc0:	29 27       	eor	r18, r25
     fc2:	02 2e       	mov	r0, r18
     fc4:	22 95       	swap	r18
     fc6:	20 7f       	andi	r18, 0xF0	; 240
     fc8:	20 25       	eor	r18, r0
     fca:	03 2e       	mov	r0, r19
     fcc:	32 2f       	mov	r19, r18
     fce:	22 95       	swap	r18
     fd0:	2f 70       	andi	r18, 0x0F	; 15
     fd2:	02 26       	eor	r0, r18
     fd4:	26 95       	lsr	r18
     fd6:	32 27       	eor	r19, r18
     fd8:	23 27       	eor	r18, r19
     fda:	22 0f       	add	r18, r18
     fdc:	22 0f       	add	r18, r18
     fde:	22 0f       	add	r18, r18
     fe0:	20 25       	eor	r18, r0
     fe2:	90 93 c2 0a 	sts	0x0AC2, r25
     fe6:	28 27       	eor	r18, r24
     fe8:	02 2e       	mov	r0, r18
     fea:	22 95       	swap	r18
     fec:	20 7f       	andi	r18, 0xF0	; 240
     fee:	20 25       	eor	r18, r0
     ff0:	03 2e       	mov	r0, r19
     ff2:	32 2f       	mov	r19, r18
     ff4:	22 95       	swap	r18
     ff6:	2f 70       	andi	r18, 0x0F	; 15
     ff8:	02 26       	eor	r0, r18
     ffa:	26 95       	lsr	r18
     ffc:	32 27       	eor	r19, r18
     ffe:	23 27       	eor	r18, r19
    1000:	22 0f       	add	r18, r18
    1002:	22 0f       	add	r18, r18
    1004:	22 0f       	add	r18, r18
    1006:	20 25       	eor	r18, r0
    1008:	80 93 c3 0a 	sts	0x0AC3, r24
    100c:	26 27       	eor	r18, r22
    100e:	02 2e       	mov	r0, r18
    1010:	22 95       	swap	r18
    1012:	20 7f       	andi	r18, 0xF0	; 240
    1014:	20 25       	eor	r18, r0
    1016:	03 2e       	mov	r0, r19
    1018:	32 2f       	mov	r19, r18
    101a:	22 95       	swap	r18
    101c:	2f 70       	andi	r18, 0x0F	; 15
    101e:	02 26       	eor	r0, r18
    1020:	26 95       	lsr	r18
    1022:	32 27       	eor	r19, r18
    1024:	23 27       	eor	r18, r19
    1026:	22 0f       	add	r18, r18
    1028:	22 0f       	add	r18, r18
    102a:	22 0f       	add	r18, r18
    102c:	20 25       	eor	r18, r0
    102e:	60 93 c4 0a 	sts	0x0AC4, r22
    1032:	24 27       	eor	r18, r20
    1034:	02 2e       	mov	r0, r18
    1036:	22 95       	swap	r18
    1038:	20 7f       	andi	r18, 0xF0	; 240
    103a:	20 25       	eor	r18, r0
    103c:	03 2e       	mov	r0, r19
    103e:	32 2f       	mov	r19, r18
    1040:	22 95       	swap	r18
    1042:	2f 70       	andi	r18, 0x0F	; 15
    1044:	02 26       	eor	r0, r18
    1046:	26 95       	lsr	r18
    1048:	32 27       	eor	r19, r18
    104a:	23 27       	eor	r18, r19
    104c:	22 0f       	add	r18, r18
    104e:	22 0f       	add	r18, r18
    1050:	22 0f       	add	r18, r18
    1052:	20 25       	eor	r18, r0
    1054:	40 93 c5 0a 	sts	0x0AC5, r20
    1058:	80 e0       	ldi	r24, 0x00	; 0
    105a:	28 27       	eor	r18, r24
    105c:	02 2e       	mov	r0, r18
    105e:	22 95       	swap	r18
    1060:	20 7f       	andi	r18, 0xF0	; 240
    1062:	20 25       	eor	r18, r0
    1064:	03 2e       	mov	r0, r19
    1066:	32 2f       	mov	r19, r18
    1068:	22 95       	swap	r18
    106a:	2f 70       	andi	r18, 0x0F	; 15
    106c:	02 26       	eor	r0, r18
    106e:	26 95       	lsr	r18
    1070:	32 27       	eor	r19, r18
    1072:	23 27       	eor	r18, r19
    1074:	22 0f       	add	r18, r18
    1076:	22 0f       	add	r18, r18
    1078:	22 0f       	add	r18, r18
    107a:	20 25       	eor	r18, r0
}

// Add character to the new packet & update the checksum
void AddToPacket(unsigned char c)
{
	checksum2 = CRC(checksum2, c);								// Add CRC from this char to running total
    107c:	30 93 c1 0c 	sts	0x0CC1, r19
    1080:	20 93 c0 0c 	sts	0x0CC0, r18
  	tx_str[tx_ptr++] = c;										// Store character in the transmit buffer
    1084:	10 92 c6 0a 	sts	0x0AC6, r1
    1088:	88 e0       	ldi	r24, 0x08	; 8
    108a:	90 e0       	ldi	r25, 0x00	; 0
    108c:	90 93 b6 0a 	sts	0x0AB6, r25
    1090:	80 93 b5 0a 	sts	0x0AB5, r24

	AddToPacket(packetType);									// Insert packet type (e.g. REQ, ACK, NAK)
	AddToPacket(packetID);										// Insert packet ID number

	AddToPacket(0);												// Insert MSB of length (i.e. max length = 256)
	length = (*str) - 3;										// Calculate the length of data we actually have to copy
    1094:	8c 91       	ld	r24, X
    1096:	48 2f       	mov	r20, r24
    1098:	50 e0       	ldi	r21, 0x00	; 0
    109a:	43 50       	subi	r20, 0x03	; 3
    109c:	50 40       	sbci	r21, 0x00	; 0
    109e:	22 c0       	rjmp	.+68     	; 0x10e4 <CreatePacket+0x180>

	while (length)
	{															// Copy the whole string into packet
		length--;												// Decrement packet length
    10a0:	41 50       	subi	r20, 0x01	; 1
    10a2:	50 40       	sbci	r21, 0x00	; 0
	  	AddToPacket(*str);										// Add current character to packet
    10a4:	8d 91       	ld	r24, X+
    10a6:	28 27       	eor	r18, r24
    10a8:	02 2e       	mov	r0, r18
    10aa:	22 95       	swap	r18
    10ac:	20 7f       	andi	r18, 0xF0	; 240
    10ae:	20 25       	eor	r18, r0
    10b0:	03 2e       	mov	r0, r19
    10b2:	32 2f       	mov	r19, r18
    10b4:	22 95       	swap	r18
    10b6:	2f 70       	andi	r18, 0x0F	; 15
    10b8:	02 26       	eor	r0, r18
    10ba:	26 95       	lsr	r18
    10bc:	32 27       	eor	r19, r18
    10be:	23 27       	eor	r18, r19
    10c0:	22 0f       	add	r18, r18
    10c2:	22 0f       	add	r18, r18
    10c4:	22 0f       	add	r18, r18
    10c6:	20 25       	eor	r18, r0
}

// Add character to the new packet & update the checksum
void AddToPacket(unsigned char c)
{
	checksum2 = CRC(checksum2, c);								// Add CRC from this char to running total
    10c8:	30 93 c1 0c 	sts	0x0CC1, r19
    10cc:	20 93 c0 0c 	sts	0x0CC0, r18
  	tx_str[tx_ptr++] = c;										// Store character in the transmit buffer
    10d0:	fb 01       	movw	r30, r22
    10d2:	e1 54       	subi	r30, 0x41	; 65
    10d4:	f5 4f       	sbci	r31, 0xF5	; 245
    10d6:	80 83       	st	Z, r24
    10d8:	6f 5f       	subi	r22, 0xFF	; 255
    10da:	7f 4f       	sbci	r23, 0xFF	; 255
    10dc:	70 93 b6 0a 	sts	0x0AB6, r23
    10e0:	60 93 b5 0a 	sts	0x0AB5, r22
    10e4:	20 91 c0 0c 	lds	r18, 0x0CC0
    10e8:	30 91 c1 0c 	lds	r19, 0x0CC1
    10ec:	60 91 b5 0a 	lds	r22, 0x0AB5
    10f0:	70 91 b6 0a 	lds	r23, 0x0AB6
	AddToPacket(packetID);										// Insert packet ID number

	AddToPacket(0);												// Insert MSB of length (i.e. max length = 256)
	length = (*str) - 3;										// Calculate the length of data we actually have to copy

	while (length)
    10f4:	41 15       	cp	r20, r1
    10f6:	51 05       	cpc	r21, r1
    10f8:	99 f6       	brne	.-90     	; 0x10a0 <CreatePacket+0x13c>
		length--;												// Decrement packet length
	  	AddToPacket(*str);										// Add current character to packet
		str++;													// Point to next character
	}

	temp = ~checksum2;
    10fa:	a9 01       	movw	r20, r18
    10fc:	40 95       	com	r20
    10fe:	50 95       	com	r21
    1100:	c9 01       	movw	r24, r18
    1102:	84 27       	eor	r24, r20
    1104:	08 2e       	mov	r0, r24
    1106:	82 95       	swap	r24
    1108:	80 7f       	andi	r24, 0xF0	; 240
    110a:	80 25       	eor	r24, r0
    110c:	09 2e       	mov	r0, r25
    110e:	98 2f       	mov	r25, r24
    1110:	82 95       	swap	r24
    1112:	8f 70       	andi	r24, 0x0F	; 15
    1114:	08 26       	eor	r0, r24
    1116:	86 95       	lsr	r24
    1118:	98 27       	eor	r25, r24
    111a:	89 27       	eor	r24, r25
    111c:	88 0f       	add	r24, r24
    111e:	88 0f       	add	r24, r24
    1120:	88 0f       	add	r24, r24
    1122:	80 25       	eor	r24, r0

// Add character to the new packet & update the checksum
void AddToPacket(unsigned char c)
{
	checksum2 = CRC(checksum2, c);								// Add CRC from this char to running total
  	tx_str[tx_ptr++] = c;										// Store character in the transmit buffer
    1124:	fb 01       	movw	r30, r22
    1126:	e1 54       	subi	r30, 0x41	; 65
    1128:	f5 4f       	sbci	r31, 0xF5	; 245
    112a:	40 83       	st	Z, r20
    112c:	9b 01       	movw	r18, r22
    112e:	2f 5f       	subi	r18, 0xFF	; 255
    1130:	3f 4f       	sbci	r19, 0xFF	; 255
    1132:	85 27       	eor	r24, r21
    1134:	08 2e       	mov	r0, r24
    1136:	82 95       	swap	r24
    1138:	80 7f       	andi	r24, 0xF0	; 240
    113a:	80 25       	eor	r24, r0
    113c:	09 2e       	mov	r0, r25
    113e:	98 2f       	mov	r25, r24
    1140:	82 95       	swap	r24
    1142:	8f 70       	andi	r24, 0x0F	; 15
    1144:	08 26       	eor	r0, r24
    1146:	86 95       	lsr	r24
    1148:	98 27       	eor	r25, r24
    114a:	89 27       	eor	r24, r25
    114c:	88 0f       	add	r24, r24
    114e:	88 0f       	add	r24, r24
    1150:	88 0f       	add	r24, r24
    1152:	80 25       	eor	r24, r0
}

// Add character to the new packet & update the checksum
void AddToPacket(unsigned char c)
{
	checksum2 = CRC(checksum2, c);								// Add CRC from this char to running total
    1154:	90 93 c1 0c 	sts	0x0CC1, r25
    1158:	80 93 c0 0c 	sts	0x0CC0, r24
  	tx_str[tx_ptr++] = c;										// Store character in the transmit buffer
    115c:	f9 01       	movw	r30, r18
    115e:	e1 54       	subi	r30, 0x41	; 65
    1160:	f5 4f       	sbci	r31, 0xF5	; 245
    1162:	50 83       	st	Z, r21

	temp = ~checksum2;
	AddToPacket(temp & 255);									// Insert checksum MSB
	AddToPacket(temp / 256);									// Insert checksum LSB

	tx_end = tx_ptr;											// Set end of buffer marker to end of packet
    1164:	2f 5f       	subi	r18, 0xFF	; 255
    1166:	3f 4f       	sbci	r19, 0xFF	; 255
    1168:	30 93 ca 0e 	sts	0x0ECA, r19
    116c:	20 93 c9 0e 	sts	0x0EC9, r18
	tx_ptr = 0;													// Point to the beginning of the packet
    1170:	10 92 b6 0a 	sts	0x0AB6, r1
    1174:	10 92 b5 0a 	sts	0x0AB5, r1
}
    1178:	08 95       	ret

0000117a <TestOptions>:
// Test the option list in packet for valid options
//   option is the 16 bit field, where a 1 accepts the option one greater than the bit # (e.g. 0x0004 for option 5) 
//   returns 2 for LCP NAK, 1 is only correct fields found, and zero means bad options
//   return also modifies RX_STR to list unacceptable options if NAK or REJ required
unsigned char TestOptions(unsigned int option)
{
    117a:	0f 93       	push	r16
    117c:	1f 93       	push	r17
    117e:	cf 93       	push	r28
    1180:	df 93       	push	r29
    1182:	ec 01       	movw	r28, r24
	unsigned int size;											// size is length of option string
	unsigned ptr1 = 8;											// ptr1 points data insert location
    unsigned ptr2 = 8;											// ptr2 points to data origin
	char pass = 3;												// pass is the return value

	size = rx_str[7] + 4;										// size is length of packet
    1184:	80 91 cb 0c 	lds	r24, 0x0CCB
    1188:	68 2f       	mov	r22, r24
    118a:	70 e0       	ldi	r23, 0x00	; 0
    118c:	6c 5f       	subi	r22, 0xFC	; 252
    118e:	7f 4f       	sbci	r23, 0xFF	; 255
    1190:	28 e0       	ldi	r18, 0x08	; 8
    1192:	30 e0       	ldi	r19, 0x00	; 0
    1194:	43 e0       	ldi	r20, 0x03	; 3
	while (ptr1 < size)											// Scan options in receiver buffer
	{
		if (rx_str[ptr1] == 3 && rx_str[ptr1+2] == 0xc2)
			pass &= 0xfd;										// Found a CHAP request, mark for NAK

		if (!((1 << (rx_str[ptr1] - 1)) & option))
    1196:	a1 e0       	ldi	r26, 0x01	; 1
    1198:	b0 e0       	ldi	r27, 0x00	; 0
    119a:	1f c0       	rjmp	.+62     	; 0x11da <TestOptions+0x60>
	if (size > MaxRx)
		size = MaxRx;											// Truncate packet if larger than buffer

	while (ptr1 < size)											// Scan options in receiver buffer
	{
		if (rx_str[ptr1] == 3 && rx_str[ptr1+2] == 0xc2)
    119c:	f9 01       	movw	r30, r18
    119e:	ec 53       	subi	r30, 0x3C	; 60
    11a0:	f3 4f       	sbci	r31, 0xF3	; 243
    11a2:	90 81       	ld	r25, Z
    11a4:	93 30       	cpi	r25, 0x03	; 3
    11a6:	21 f4       	brne	.+8      	; 0x11b0 <TestOptions+0x36>
    11a8:	82 81       	ldd	r24, Z+2	; 0x02
    11aa:	82 3c       	cpi	r24, 0xC2	; 194
    11ac:	09 f4       	brne	.+2      	; 0x11b0 <TestOptions+0x36>
			pass &= 0xfd;										// Found a CHAP request, mark for NAK
    11ae:	4d 7f       	andi	r20, 0xFD	; 253

		if (!((1 << (rx_str[ptr1] - 1)) & option))
    11b0:	89 2f       	mov	r24, r25
    11b2:	90 e0       	ldi	r25, 0x00	; 0
    11b4:	01 97       	sbiw	r24, 0x01	; 1
    11b6:	fd 01       	movw	r30, r26
    11b8:	02 c0       	rjmp	.+4      	; 0x11be <TestOptions+0x44>
    11ba:	ee 0f       	add	r30, r30
    11bc:	ff 1f       	adc	r31, r31
    11be:	8a 95       	dec	r24
    11c0:	e2 f7       	brpl	.-8      	; 0x11ba <TestOptions+0x40>
    11c2:	cf 01       	movw	r24, r30
    11c4:	8c 23       	and	r24, r28
    11c6:	9d 23       	and	r25, r29
    11c8:	89 2b       	or	r24, r25
    11ca:	09 f4       	brne	.+2      	; 0x11ce <TestOptions+0x54>
    11cc:	40 e0       	ldi	r20, 0x00	; 0
	    	pass = 0;											// Found illegal options, mark for REJ

	  ptr1 += rx_str[ptr1+1];									// Point to start of next option
    11ce:	f9 01       	movw	r30, r18
    11d0:	ec 53       	subi	r30, 0x3C	; 60
    11d2:	f3 4f       	sbci	r31, 0xF3	; 243
    11d4:	81 81       	ldd	r24, Z+1	; 0x01
    11d6:	28 0f       	add	r18, r24
    11d8:	31 1d       	adc	r19, r1
	size = rx_str[7] + 4;										// size is length of packet
   
	if (size > MaxRx)
		size = MaxRx;											// Truncate packet if larger than buffer

	while (ptr1 < size)											// Scan options in receiver buffer
    11da:	26 17       	cp	r18, r22
    11dc:	37 07       	cpc	r19, r23
    11de:	f0 f2       	brcs	.-68     	; 0x119c <TestOptions+0x22>
	    	pass = 0;											// Found illegal options, mark for REJ

	  ptr1 += rx_str[ptr1+1];									// Point to start of next option
	}

	if (!(pass & 2))											// If marked for NAK or REJ
    11e0:	41 fd       	sbrc	r20, 1
    11e2:	3e c0       	rjmp	.+124    	; 0x1260 <TestOptions+0xe6>
	{	
		if (pass & 1)											// Save state for NAK
    11e4:	40 ff       	sbrs	r20, 0
    11e6:	02 c0       	rjmp	.+4      	; 0x11ec <TestOptions+0x72>
    11e8:	cb ef       	ldi	r28, 0xFB	; 251
    11ea:	df ef       	ldi	r29, 0xFF	; 255
    11ec:	28 e0       	ldi	r18, 0x08	; 8
    11ee:	30 e0       	ldi	r19, 0x00	; 0
    11f0:	48 e0       	ldi	r20, 0x08	; 8
    11f2:	50 e0       	ldi	r21, 0x00	; 0
			option = 0xfffb;
		}

		for (ptr1 = 8; ptr1 < size;)
		{
			if (!((1 << (rx_str[ptr1] - 1)) & option))			// If illegal option
    11f4:	01 e0       	ldi	r16, 0x01	; 1
    11f6:	10 e0       	ldi	r17, 0x00	; 0
    11f8:	27 c0       	rjmp	.+78     	; 0x1248 <TestOptions+0xce>
    11fa:	f9 01       	movw	r30, r18
    11fc:	ec 53       	subi	r30, 0x3C	; 60
    11fe:	f3 4f       	sbci	r31, 0xF3	; 243
    1200:	80 81       	ld	r24, Z
    1202:	90 e0       	ldi	r25, 0x00	; 0
    1204:	01 97       	sbiw	r24, 0x01	; 1
    1206:	d8 01       	movw	r26, r16
    1208:	02 c0       	rjmp	.+4      	; 0x120e <TestOptions+0x94>
    120a:	aa 0f       	add	r26, r26
    120c:	bb 1f       	adc	r27, r27
    120e:	8a 95       	dec	r24
    1210:	e2 f7       	brpl	.-8      	; 0x120a <TestOptions+0x90>
    1212:	cd 01       	movw	r24, r26
    1214:	8c 23       	and	r24, r28
    1216:	9d 23       	and	r25, r29
    1218:	89 2b       	or	r24, r25
    121a:	99 f4       	brne	.+38     	; 0x1242 <TestOptions+0xc8>
			{
            	for (pass = rx_str[ptr1+1]; ptr1 < size && pass; ptr1++) // Move option
    121c:	91 81       	ldd	r25, Z+1	; 0x01
    121e:	df 01       	movw	r26, r30
    1220:	fa 01       	movw	r30, r20
    1222:	ec 53       	subi	r30, 0x3C	; 60
    1224:	f3 4f       	sbci	r31, 0xF3	; 243
    1226:	0a c0       	rjmp	.+20     	; 0x123c <TestOptions+0xc2>
				{ 
					rx_str[ptr2] = rx_str[ptr1];				// Move current byte to new storage
    1228:	8d 91       	ld	r24, X+
    122a:	81 93       	st	Z+, r24
					ptr2++;										// Increment storage pointer
    122c:	4f 5f       	subi	r20, 0xFF	; 255
    122e:	5f 4f       	sbci	r21, 0xFF	; 255

		for (ptr1 = 8; ptr1 < size;)
		{
			if (!((1 << (rx_str[ptr1] - 1)) & option))			// If illegal option
			{
            	for (pass = rx_str[ptr1+1]; ptr1 < size && pass; ptr1++) // Move option
    1230:	2f 5f       	subi	r18, 0xFF	; 255
    1232:	3f 4f       	sbci	r19, 0xFF	; 255
    1234:	26 17       	cp	r18, r22
    1236:	37 07       	cpc	r19, r23
    1238:	38 f4       	brcc	.+14     	; 0x1248 <TestOptions+0xce>
				{ 
					rx_str[ptr2] = rx_str[ptr1];				// Move current byte to new storage
					ptr2++;										// Increment storage pointer
					pass--;										// Decrement number of characters
    123a:	91 50       	subi	r25, 0x01	; 1

		for (ptr1 = 8; ptr1 < size;)
		{
			if (!((1 << (rx_str[ptr1] - 1)) & option))			// If illegal option
			{
            	for (pass = rx_str[ptr1+1]; ptr1 < size && pass; ptr1++) // Move option
    123c:	99 23       	and	r25, r25
    123e:	a1 f7       	brne	.-24     	; 0x1228 <TestOptions+0xae>
    1240:	03 c0       	rjmp	.+6      	; 0x1248 <TestOptions+0xce>
					pass--;										// Decrement number of characters
				}
			}
			else 
			{
				ptr1+=rx_str[ptr1+1];							// Point to next option
    1242:	81 81       	ldd	r24, Z+1	; 0x01
    1244:	28 0f       	add	r18, r24
    1246:	31 1d       	adc	r19, r1
		if (pass & 1)											// Save state for NAK
		{
			option = 0xfffb;
		}

		for (ptr1 = 8; ptr1 < size;)
    1248:	26 17       	cp	r18, r22
    124a:	37 07       	cpc	r19, r23
    124c:	b0 f2       	brcs	.-84     	; 0x11fa <TestOptions+0x80>
			{
				ptr1+=rx_str[ptr1+1];							// Point to next option
			}
		}

		rx_str[7] = ptr2 - 4;									// Save new option string length
    124e:	84 2f       	mov	r24, r20
    1250:	84 50       	subi	r24, 0x04	; 4
    1252:	80 93 cb 0c 	sts	0x0CCB, r24
    1256:	40 e0       	ldi	r20, 0x00	; 0
    1258:	cb 5f       	subi	r28, 0xFB	; 251
    125a:	df 4f       	sbci	r29, 0xFF	; 255
    125c:	09 f4       	brne	.+2      	; 0x1260 <TestOptions+0xe6>
    125e:	41 e0       	ldi	r20, 0x01	; 1
		if (option == 0xfffb)									// Restore state for NAK
		pass = 1;
   }

   return pass;
}
    1260:	84 2f       	mov	r24, r20
    1262:	df 91       	pop	r29
    1264:	cf 91       	pop	r28
    1266:	1f 91       	pop	r17
    1268:	0f 91       	pop	r16
    126a:	08 95       	ret

0000126c <CRC>:
    126c:	9c 01       	movw	r18, r24
    126e:	26 27       	eor	r18, r22
    1270:	02 2e       	mov	r0, r18
    1272:	22 95       	swap	r18
    1274:	20 7f       	andi	r18, 0xF0	; 240
    1276:	20 25       	eor	r18, r0
    1278:	03 2e       	mov	r0, r19
    127a:	32 2f       	mov	r19, r18
    127c:	22 95       	swap	r18
    127e:	2f 70       	andi	r18, 0x0F	; 15
    1280:	02 26       	eor	r0, r18
    1282:	26 95       	lsr	r18
    1284:	32 27       	eor	r19, r18
    1286:	23 27       	eor	r18, r19
    1288:	22 0f       	add	r18, r18
    128a:	22 0f       	add	r18, r18
    128c:	22 0f       	add	r18, r18
    128e:	20 25       	eor	r18, r0
   //b = (crcvalue ^ c) & 0xFF;
   //b = (b ^ (b << 4)) & 0xFF;				
   //b = (b << 8) ^ (b << 3) ^ (b >> 4);
   
   //return ((crcvalue >> 8) ^ b);
}
    1290:	c9 01       	movw	r24, r18
    1292:	08 95       	ret

00001294 <MakeInitialPacket>:


// Make the first packet to start each phase of the PPP negotiations (LCP, PAP, IPCP)
void MakeInitialPacket(void)
{
	if (tx_end)													// Don't make a new packet if we have data in the buffer already
    1294:	80 91 c9 0e 	lds	r24, 0x0EC9
    1298:	90 91 ca 0e 	lds	r25, 0x0ECA
    129c:	89 2b       	or	r24, r25
    129e:	09 f0       	breq	.+2      	; 0x12a2 <MakeInitialPacket+0xe>
    12a0:	57 c0       	rjmp	.+174    	; 0x1350 <MakeInitialPacket+0xbc>
		return;

	if (PPPState == LCPState && TIME > 300)						// Once every 3 seconds try negotiating LCP
    12a2:	80 91 bc 0a 	lds	r24, 0x0ABC
    12a6:	88 23       	and	r24, r24
    12a8:	d9 f4       	brne	.+54     	; 0x12e0 <MakeInitialPacket+0x4c>
    12aa:	80 91 a0 0a 	lds	r24, 0x0AA0
    12ae:	90 91 a1 0a 	lds	r25, 0x0AA1
    12b2:	8d 52       	subi	r24, 0x2D	; 45
    12b4:	91 40       	sbci	r25, 0x01	; 1
    12b6:	08 f4       	brcc	.+2      	; 0x12ba <MakeInitialPacket+0x26>
    12b8:	4b c0       	rjmp	.+150    	; 0x1350 <MakeInitialPacket+0xbc>
	{		
		Debug("\r\nMaking LCP Packet");
    12ba:	88 ee       	ldi	r24, 0xE8	; 232
    12bc:	94 e0       	ldi	r25, 0x04	; 4
    12be:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
		
		TIME_SET(0);											// Reset timer
    12c2:	10 92 a1 0a 	sts	0x0AA1, r1
    12c6:	10 92 a0 0a 	sts	0x0AA0, r1
		number++;												// Increment ID to make packets unique
    12ca:	40 91 b9 0a 	lds	r20, 0x0AB9
    12ce:	4f 5f       	subi	r20, 0xFF	; 255
    12d0:	40 93 b9 0a 	sts	0x0AB9, r20

		// Request LCP options 2, 5, 7, 8, 0D, 11, 13
		CreatePacket(LCP, REQ, number, (unsigned char*)"\x12\x01\x04\x05\xa0\x02\x06\x00\x0a\x00\x00\x07\x02\x08\x02");
    12d4:	81 e2       	ldi	r24, 0x21	; 33
    12d6:	90 ec       	ldi	r25, 0xC0	; 192
    12d8:	61 e0       	ldi	r22, 0x01	; 1
    12da:	2c ef       	ldi	r18, 0xFC	; 252
    12dc:	34 e0       	ldi	r19, 0x04	; 4
    12de:	1b c0       	rjmp	.+54     	; 0x1316 <MakeInitialPacket+0x82>
	}

	else if (PPPState == PAPState && TIME > 100)				// Once every second try negotiating password
    12e0:	81 30       	cpi	r24, 0x01	; 1
    12e2:	d1 f4       	brne	.+52     	; 0x1318 <MakeInitialPacket+0x84>
    12e4:	80 91 a0 0a 	lds	r24, 0x0AA0
    12e8:	90 91 a1 0a 	lds	r25, 0x0AA1
    12ec:	85 36       	cpi	r24, 0x65	; 101
    12ee:	91 05       	cpc	r25, r1
    12f0:	78 f1       	brcs	.+94     	; 0x1350 <MakeInitialPacket+0xbc>
	{	
		Debug("\r\nMaking PAP Packet");
    12f2:	8c e0       	ldi	r24, 0x0C	; 12
    12f4:	95 e0       	ldi	r25, 0x05	; 5
    12f6:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
		
		TIME_SET(0);											// Reset timer
    12fa:	10 92 a1 0a 	sts	0x0AA1, r1
    12fe:	10 92 a0 0a 	sts	0x0AA0, r1
		number++;												// Increment ID to make packets unique
    1302:	40 91 b9 0a 	lds	r20, 0x0AB9
    1306:	4f 5f       	subi	r20, 0xFF	; 255
    1308:	40 93 b9 0a 	sts	0x0AB9, r20

     	CreatePacket(PAP, REQ, number, (unsigned char*)"\x06\x00\x00"); 
    130c:	83 e2       	ldi	r24, 0x23	; 35
    130e:	90 ec       	ldi	r25, 0xC0	; 192
    1310:	61 e0       	ldi	r22, 0x01	; 1
    1312:	20 e2       	ldi	r18, 0x20	; 32
    1314:	35 e0       	ldi	r19, 0x05	; 5
    1316:	26 ce       	rjmp	.-948    	; 0xf64 <CreatePacket>
  	}

	else if (PPPState == IPCPState && TIME > 500)				// Once every 5 seconds try negotiating IPCP
    1318:	82 30       	cpi	r24, 0x02	; 2
    131a:	d1 f4       	brne	.+52     	; 0x1350 <MakeInitialPacket+0xbc>
    131c:	80 91 a0 0a 	lds	r24, 0x0AA0
    1320:	90 91 a1 0a 	lds	r25, 0x0AA1
    1324:	85 5f       	subi	r24, 0xF5	; 245
    1326:	91 40       	sbci	r25, 0x01	; 1
    1328:	98 f0       	brcs	.+38     	; 0x1350 <MakeInitialPacket+0xbc>
	{
		Debug("\r\nMaking IPCP Packet");
    132a:	84 e2       	ldi	r24, 0x24	; 36
    132c:	95 e0       	ldi	r25, 0x05	; 5
    132e:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>

		TIME_SET(0);											// Reset timer
    1332:	10 92 a1 0a 	sts	0x0AA1, r1
    1336:	10 92 a0 0a 	sts	0x0AA0, r1
		number++;												// Increment ID to make packets unique
    133a:	40 91 b9 0a 	lds	r20, 0x0AB9
    133e:	4f 5f       	subi	r20, 0xFF	; 255
    1340:	40 93 b9 0a 	sts	0x0AB9, r20
		
		// Request IPCP options 3 (IP Address), 81 (Primary DNS) & 83 (Secondary DNS) with addr 0.0.0.0 for each one
		CreatePacket(IPCP, REQ, number, (unsigned char*)"\x16\x03\x06\x00\x00\x00\x00\x81\x06\x00\x00\x00\x00\x83\x06\x00\x00\x00\x00");
    1344:	81 e2       	ldi	r24, 0x21	; 33
    1346:	90 e8       	ldi	r25, 0x80	; 128
    1348:	61 e0       	ldi	r22, 0x01	; 1
    134a:	29 e3       	ldi	r18, 0x39	; 57
    134c:	35 e0       	ldi	r19, 0x05	; 5
    134e:	0a ce       	rjmp	.-1004   	; 0xf64 <CreatePacket>
    1350:	08 95       	ret

00001352 <ProcessReceivedPacket>:
	while (ExitFlag == 0);
}


void ProcessReceivedPacket(void)
{	
    1352:	1f 93       	push	r17

	// *****************************
	// **         LCP             **
	// *****************************
  	
	if (PacketType == LCP)
    1354:	80 91 80 0a 	lds	r24, 0x0A80
    1358:	90 91 81 0a 	lds	r25, 0x0A81
    135c:	20 ec       	ldi	r18, 0xC0	; 192
    135e:	81 32       	cpi	r24, 0x21	; 33
    1360:	92 07       	cpc	r25, r18
    1362:	09 f0       	breq	.+2      	; 0x1366 <ProcessReceivedPacket+0x14>
    1364:	78 c0       	rjmp	.+240    	; 0x1456 <ProcessReceivedPacket+0x104>
	{
		Debug("Got LCP ");
    1366:	8d e4       	ldi	r24, 0x4D	; 77
    1368:	95 e0       	ldi	r25, 0x05	; 5
    136a:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>

		switch (rx_str[4])										// Switch on packet type
    136e:	10 91 c8 0c 	lds	r17, 0x0CC8
    1372:	13 30       	cpi	r17, 0x03	; 3
    1374:	09 f4       	brne	.+2      	; 0x1378 <ProcessReceivedPacket+0x26>
    1376:	53 c0       	rjmp	.+166    	; 0x141e <ProcessReceivedPacket+0xcc>
    1378:	14 30       	cpi	r17, 0x04	; 4
    137a:	30 f4       	brcc	.+12     	; 0x1388 <ProcessReceivedPacket+0x36>
    137c:	11 30       	cpi	r17, 0x01	; 1
    137e:	59 f0       	breq	.+22     	; 0x1396 <ProcessReceivedPacket+0x44>
    1380:	12 30       	cpi	r17, 0x02	; 2
    1382:	09 f0       	breq	.+2      	; 0x1386 <ProcessReceivedPacket+0x34>
    1384:	5a c0       	rjmp	.+180    	; 0x143a <ProcessReceivedPacket+0xe8>
    1386:	3a c0       	rjmp	.+116    	; 0x13fc <ProcessReceivedPacket+0xaa>
    1388:	14 30       	cpi	r17, 0x04	; 4
    138a:	09 f4       	brne	.+2      	; 0x138e <ProcessReceivedPacket+0x3c>
    138c:	4b c0       	rjmp	.+150    	; 0x1424 <ProcessReceivedPacket+0xd2>
    138e:	15 30       	cpi	r17, 0x05	; 5
    1390:	09 f0       	breq	.+2      	; 0x1394 <ProcessReceivedPacket+0x42>
    1392:	53 c0       	rjmp	.+166    	; 0x143a <ProcessReceivedPacket+0xe8>
    1394:	4e c0       	rjmp	.+156    	; 0x1432 <ProcessReceivedPacket+0xe0>
		{
			case REQ:
				RemoteReady = 0;								// Clear remote ready flag
    1396:	10 92 83 0a 	sts	0x0A83, r1
           
		   		Debug("REQ ");
    139a:	86 e5       	ldi	r24, 0x56	; 86
    139c:	95 e0       	ldi	r25, 0x05	; 5
    139e:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
				
				if ((c = TestOptions(0x00c7)))					// Options 1, 2, 3, 7, 8
    13a2:	87 ec       	ldi	r24, 0xC7	; 199
    13a4:	90 e0       	ldi	r25, 0x00	; 0
    13a6:	e9 de       	rcall	.-558    	; 0x117a <TestOptions>
    13a8:	90 e0       	ldi	r25, 0x00	; 0
    13aa:	00 97       	sbiw	r24, 0x00	; 0
    13ac:	a9 f0       	breq	.+42     	; 0x13d8 <ProcessReceivedPacket+0x86>
				{											
	            	if (c > 1)
    13ae:	01 97       	sbiw	r24, 0x01	; 1
    13b0:	49 f0       	breq	.+18     	; 0x13c4 <ProcessReceivedPacket+0x72>
				  	{
	                	c = ACK;								// ACK packet
                 
						RemoteReady = 1;						// Set remote ready flag
    13b2:	10 93 83 0a 	sts	0x0A83, r17

						Debug("- We ACK\r\n");
    13b6:	8b e5       	ldi	r24, 0x5B	; 91
    13b8:	95 e0       	ldi	r25, 0x05	; 5
    13ba:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
    13be:	62 e0       	ldi	r22, 0x02	; 2
    13c0:	70 e0       	ldi	r23, 0x00	; 0
    13c2:	10 c0       	rjmp	.+32     	; 0x13e4 <ProcessReceivedPacket+0x92>
	              	}
					else
					{
	                	rx_str[10] = 0xc0;						// Else NAK password authentication
    13c4:	80 ec       	ldi	r24, 0xC0	; 192
    13c6:	80 93 ce 0c 	sts	0x0CCE, r24
	                 	c = NAK;
						Debug("- We NAK\r\n");
    13ca:	86 e6       	ldi	r24, 0x66	; 102
    13cc:	95 e0       	ldi	r25, 0x05	; 5
    13ce:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
    13d2:	63 e0       	ldi	r22, 0x03	; 3
    13d4:	70 e0       	ldi	r23, 0x00	; 0
    13d6:	06 c0       	rjmp	.+12     	; 0x13e4 <ProcessReceivedPacket+0x92>
	              	}
				}
				else											// Else REJ bad options
				{
					Debug("- We REJ\r\n");
    13d8:	81 e7       	ldi	r24, 0x71	; 113
    13da:	95 e0       	ldi	r25, 0x05	; 5
    13dc:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
    13e0:	64 e0       	ldi	r22, 0x04	; 4
    13e2:	70 e0       	ldi	r23, 0x00	; 0
			   		c = REJ;
				}
			
				TIME_SET(0);									// Stop the timer from expiring
    13e4:	10 92 a1 0a 	sts	0x0AA1, r1
    13e8:	10 92 a0 0a 	sts	0x0AA0, r1
	           	CreatePacket(LCP, c, rx_str[5], rx_str + 7); 	// Create LCP packet from Rx buffer
    13ec:	81 e2       	ldi	r24, 0x21	; 33
    13ee:	90 ec       	ldi	r25, 0xC0	; 192
    13f0:	40 91 c9 0c 	lds	r20, 0x0CC9
    13f4:	2b ec       	ldi	r18, 0xCB	; 203
    13f6:	3c e0       	ldi	r19, 0x0C	; 12
    13f8:	b5 dd       	rcall	.-1174   	; 0xf64 <CreatePacket>
    13fa:	1f c0       	rjmp	.+62     	; 0x143a <ProcessReceivedPacket+0xe8>
			break;
        
			case ACK:
				if (rx_str[5] == number)						// Does reply ID match the request
    13fc:	90 91 c9 0c 	lds	r25, 0x0CC9
    1400:	80 91 b9 0a 	lds	r24, 0x0AB9
    1404:	98 17       	cp	r25, r24
    1406:	41 f4       	brne	.+16     	; 0x1418 <ProcessReceivedPacket+0xc6>
			   	{
					Debug("ACK\r\n");
    1408:	8c e7       	ldi	r24, 0x7C	; 124
    140a:	95 e0       	ldi	r25, 0x05	; 5
    140c:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
					LocalReady = 1;								// Set local ready flag
    1410:	81 e0       	ldi	r24, 0x01	; 1
    1412:	80 93 ba 0a 	sts	0x0ABA, r24
    1416:	11 c0       	rjmp	.+34     	; 0x143a <ProcessReceivedPacket+0xe8>
				}
				else
					Debug("Out of sync ACK\r\n");
    1418:	82 e8       	ldi	r24, 0x82	; 130
    141a:	95 e0       	ldi	r25, 0x05	; 5
    141c:	0c c0       	rjmp	.+24     	; 0x1436 <ProcessReceivedPacket+0xe4>
			break;
        
			case NAK:
				Debug("NAK\r\n");
    141e:	84 e9       	ldi	r24, 0x94	; 148
    1420:	95 e0       	ldi	r25, 0x05	; 5
    1422:	02 c0       	rjmp	.+4      	; 0x1428 <ProcessReceivedPacket+0xd6>
				LocalReady = 0;									// Clear local ready flag
	        break;
        
			case REJ:
				Debug("REJ\r\n");
    1424:	8a e9       	ldi	r24, 0x9A	; 154
    1426:	95 e0       	ldi	r25, 0x05	; 5
    1428:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
	        	LocalReady = 0;									// Clear local ready flag
    142c:	10 92 ba 0a 	sts	0x0ABA, r1
    1430:	04 c0       	rjmp	.+8      	; 0x143a <ProcessReceivedPacket+0xe8>
	        break;
        
			case TERM:
				Debug("TERM\r\n");
    1432:	80 ea       	ldi	r24, 0xA0	; 160
    1434:	95 e0       	ldi	r25, 0x05	; 5
    1436:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
	        break;
		}

		if (LocalReady && RemoteReady)							// When both ends ready, go to PAP state
    143a:	80 91 ba 0a 	lds	r24, 0x0ABA
    143e:	88 23       	and	r24, r24
    1440:	09 f4       	brne	.+2      	; 0x1444 <ProcessReceivedPacket+0xf2>
    1442:	b4 c0       	rjmp	.+360    	; 0x15ac <ProcessReceivedPacket+0x25a>
    1444:	80 91 83 0a 	lds	r24, 0x0A83
    1448:	88 23       	and	r24, r24
    144a:	09 f4       	brne	.+2      	; 0x144e <ProcessReceivedPacket+0xfc>
    144c:	af c0       	rjmp	.+350    	; 0x15ac <ProcessReceivedPacket+0x25a>
			PPPState = PAPState;
    144e:	81 e0       	ldi	r24, 0x01	; 1
    1450:	80 93 bc 0a 	sts	0x0ABC, r24
    1454:	ab c0       	rjmp	.+342    	; 0x15ac <ProcessReceivedPacket+0x25a>

	// *****************************
	// **         PAP             **
	// *****************************

	else if (PacketType == PAP)
    1456:	20 ec       	ldi	r18, 0xC0	; 192
    1458:	83 32       	cpi	r24, 0x23	; 35
    145a:	92 07       	cpc	r25, r18
    145c:	d1 f4       	brne	.+52     	; 0x1492 <ProcessReceivedPacket+0x140>
	{
		Debug("Got PAP ");
    145e:	87 ea       	ldi	r24, 0xA7	; 167
    1460:	95 e0       	ldi	r25, 0x05	; 5
    1462:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>

    	switch (rx_str[4])										// Switch on packet type
    1466:	10 91 c8 0c 	lds	r17, 0x0CC8
    146a:	12 30       	cpi	r17, 0x02	; 2
    146c:	41 f0       	breq	.+16     	; 0x147e <ProcessReceivedPacket+0x12c>
    146e:	13 30       	cpi	r17, 0x03	; 3
    1470:	69 f0       	breq	.+26     	; 0x148c <ProcessReceivedPacket+0x13a>
    1472:	11 30       	cpi	r17, 0x01	; 1
    1474:	09 f0       	breq	.+2      	; 0x1478 <ProcessReceivedPacket+0x126>
    1476:	9a c0       	rjmp	.+308    	; 0x15ac <ProcessReceivedPacket+0x25a>
		{
	        case REQ:
				Debug("REQ\r\n");				
    1478:	80 eb       	ldi	r24, 0xB0	; 176
    147a:	95 e0       	ldi	r25, 0x05	; 5
    147c:	95 c0       	rjmp	.+298    	; 0x15a8 <ProcessReceivedPacket+0x256>
	        break;												// Ignore incoming PAP REQ
	        case ACK:
				Debug("ACK\r\n");
    147e:	8c e7       	ldi	r24, 0x7C	; 124
    1480:	95 e0       	ldi	r25, 0x05	; 5
    1482:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
	           	PPPState = IPCPState;							// PAP ACK means that this state is done
    1486:	10 93 bc 0a 	sts	0x0ABC, r17
    148a:	90 c0       	rjmp	.+288    	; 0x15ac <ProcessReceivedPacket+0x25a>
	        break;
	        case NAK:
				Debug("NAK\r\n");
    148c:	84 e9       	ldi	r24, 0x94	; 148
    148e:	95 e0       	ldi	r25, 0x05	; 5
    1490:	8b c0       	rjmp	.+278    	; 0x15a8 <ProcessReceivedPacket+0x256>

	// *****************************
	// **         IPCP            **
	// *****************************

	else if (PacketType == IPCP)
    1492:	20 e8       	ldi	r18, 0x80	; 128
    1494:	81 32       	cpi	r24, 0x21	; 33
    1496:	92 07       	cpc	r25, r18
    1498:	09 f0       	breq	.+2      	; 0x149c <ProcessReceivedPacket+0x14a>
    149a:	75 c0       	rjmp	.+234    	; 0x1586 <ProcessReceivedPacket+0x234>
		// IPCP option 0x81 Primary DNS Address
		// IPCP option 0x82 Primary NBNS Address
		// IPCP option 0x83 Secondary DNS Address
		// IPCP option 0x84 Secondary NBNS Address

		Debug("Got IPCP ");
    149c:	86 eb       	ldi	r24, 0xB6	; 182
    149e:	95 e0       	ldi	r25, 0x05	; 5
    14a0:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>

    	switch (rx_str[4])										// Switch on packet type
    14a4:	10 91 c8 0c 	lds	r17, 0x0CC8
    14a8:	13 30       	cpi	r17, 0x03	; 3
    14aa:	09 f4       	brne	.+2      	; 0x14ae <ProcessReceivedPacket+0x15c>
    14ac:	3e c0       	rjmp	.+124    	; 0x152a <ProcessReceivedPacket+0x1d8>
    14ae:	14 30       	cpi	r17, 0x04	; 4
    14b0:	30 f4       	brcc	.+12     	; 0x14be <ProcessReceivedPacket+0x16c>
    14b2:	11 30       	cpi	r17, 0x01	; 1
    14b4:	59 f0       	breq	.+22     	; 0x14cc <ProcessReceivedPacket+0x17a>
    14b6:	12 30       	cpi	r17, 0x02	; 2
    14b8:	09 f0       	breq	.+2      	; 0x14bc <ProcessReceivedPacket+0x16a>
    14ba:	78 c0       	rjmp	.+240    	; 0x15ac <ProcessReceivedPacket+0x25a>
    14bc:	22 c0       	rjmp	.+68     	; 0x1502 <ProcessReceivedPacket+0x1b0>
    14be:	14 30       	cpi	r17, 0x04	; 4
    14c0:	09 f4       	brne	.+2      	; 0x14c4 <ProcessReceivedPacket+0x172>
    14c2:	5b c0       	rjmp	.+182    	; 0x157a <ProcessReceivedPacket+0x228>
    14c4:	15 30       	cpi	r17, 0x05	; 5
    14c6:	09 f0       	breq	.+2      	; 0x14ca <ProcessReceivedPacket+0x178>
    14c8:	71 c0       	rjmp	.+226    	; 0x15ac <ProcessReceivedPacket+0x25a>
    14ca:	5a c0       	rjmp	.+180    	; 0x1580 <ProcessReceivedPacket+0x22e>
		{		
        	case REQ:
				Debug("REQ ");	
    14cc:	86 e5       	ldi	r24, 0x56	; 86
    14ce:	95 e0       	ldi	r25, 0x05	; 5
    14d0:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
        		
				if (TestOptions(0x0004))						// Option 3 - We got an IP address
    14d4:	84 e0       	ldi	r24, 0x04	; 4
    14d6:	90 e0       	ldi	r25, 0x00	; 0
    14d8:	50 de       	rcall	.-864    	; 0x117a <TestOptions>
    14da:	88 23       	and	r24, r24
    14dc:	39 f0       	breq	.+14     	; 0x14ec <ProcessReceivedPacket+0x19a>
		   		{
					c = ACK;									// We ACK
					Debug("- We ACK\r\n");
    14de:	8b e5       	ldi	r24, 0x5B	; 91
    14e0:	95 e0       	ldi	r25, 0x05	; 5
    14e2:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
    14e6:	62 e0       	ldi	r22, 0x02	; 2
    14e8:	70 e0       	ldi	r23, 0x00	; 0
    14ea:	06 c0       	rjmp	.+12     	; 0x14f8 <ProcessReceivedPacket+0x1a6>
           		}
				else
				{				
              		c = REJ;									// Otherwise we reject bad options
					Debug("- We REJ\r\n");
    14ec:	81 e7       	ldi	r24, 0x71	; 113
    14ee:	95 e0       	ldi	r25, 0x05	; 5
    14f0:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
    14f4:	64 e0       	ldi	r22, 0x04	; 4
    14f6:	70 e0       	ldi	r23, 0x00	; 0
           		}
           		
				CreatePacket(IPCP, c, rx_str[5], rx_str + 7);	// Create IPCP packet from Rx buffer
    14f8:	81 e2       	ldi	r24, 0x21	; 33
    14fa:	90 e8       	ldi	r25, 0x80	; 128
    14fc:	40 91 c9 0c 	lds	r20, 0x0CC9
    1500:	38 c0       	rjmp	.+112    	; 0x1572 <ProcessReceivedPacket+0x220>
			break; 				
        
			case ACK:
				Debug("ACK\r\n");	
    1502:	8c e7       	ldi	r24, 0x7C	; 124
    1504:	95 e0       	ldi	r25, 0x05	; 5
    1506:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
				
				if (rx_str[5] == number)						// If IPCP response id matches request id
    150a:	90 91 c9 0c 	lds	r25, 0x0CC9
    150e:	80 91 b9 0a 	lds	r24, 0x0AB9
    1512:	98 17       	cp	r25, r24
    1514:	09 f0       	breq	.+2      	; 0x1518 <ProcessReceivedPacket+0x1c6>
    1516:	4a c0       	rjmp	.+148    	; 0x15ac <ProcessReceivedPacket+0x25a>
				{
					Debug("**LINK CONNECTED**\r\n");
    1518:	80 ec       	ldi	r24, 0xC0	; 192
    151a:	95 e0       	ldi	r25, 0x05	; 5
    151c:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
					PPPState = LCPState;						// Move into initial state for when we get called next time (after link disconnect)
    1520:	10 92 bc 0a 	sts	0x0ABC, r1
					ConnectedState = 2;
    1524:	10 93 72 06 	sts	0x0672, r17
    1528:	41 c0       	rjmp	.+130    	; 0x15ac <ProcessReceivedPacket+0x25a>
           		}
			break;
       
			case NAK:   										// This is where we get our address
				Debug("NAK\r\n");	
    152a:	84 e9       	ldi	r24, 0x94	; 148
    152c:	95 e0       	ldi	r25, 0x05	; 5
    152e:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
				IPAddr1 = addr1 = rx_str[10];
    1532:	80 91 ce 0c 	lds	r24, 0x0CCE
    1536:	80 93 c8 0e 	sts	0x0EC8, r24
    153a:	80 93 af 0a 	sts	0x0AAF, r24
				IPAddr2 = addr2 = rx_str[11];   				// Store address for use in IP packets 
    153e:	80 91 cf 0c 	lds	r24, 0x0CCF
    1542:	80 93 b4 0a 	sts	0x0AB4, r24
    1546:	80 93 a3 0a 	sts	0x0AA3, r24
				IPAddr3 = addr3 = rx_str[12];
    154a:	80 91 d0 0c 	lds	r24, 0x0CD0
    154e:	80 93 bb 0a 	sts	0x0ABB, r24
    1552:	80 93 a2 0a 	sts	0x0AA2, r24
				IPAddr4 = addr4 = rx_str[13];
    1556:	80 91 d1 0c 	lds	r24, 0x0CD1
    155a:	80 93 c7 0e 	sts	0x0EC7, r24
    155e:	80 93 a8 0a 	sts	0x0AA8, r24
				
				number++;										// If we get a NAK, send the next REQ packet with a new number
    1562:	40 91 b9 0a 	lds	r20, 0x0AB9
    1566:	4f 5f       	subi	r20, 0xFF	; 255
    1568:	40 93 b9 0a 	sts	0x0AB9, r20
				
				CreatePacket(IPCP, REQ, number, rx_str + 7);	// Make IPCP packet from Rx buffer
    156c:	81 e2       	ldi	r24, 0x21	; 33
    156e:	90 e8       	ldi	r25, 0x80	; 128
    1570:	61 e0       	ldi	r22, 0x01	; 1
    1572:	2b ec       	ldi	r18, 0xCB	; 203
    1574:	3c e0       	ldi	r19, 0x0C	; 12
    1576:	f6 dc       	rcall	.-1556   	; 0xf64 <CreatePacket>
    1578:	19 c0       	rjmp	.+50     	; 0x15ac <ProcessReceivedPacket+0x25a>
			break; 				

			case REJ:
				Debug("REJ\r\n");	
    157a:	8a e9       	ldi	r24, 0x9A	; 154
    157c:	95 e0       	ldi	r25, 0x05	; 5
    157e:	14 c0       	rjmp	.+40     	; 0x15a8 <ProcessReceivedPacket+0x256>
			break;												// Ignore incoming IPCP REJ
			
			case TERM:
				Debug("TERM\r\n");	
    1580:	80 ea       	ldi	r24, 0xA0	; 160
    1582:	95 e0       	ldi	r25, 0x05	; 5
    1584:	11 c0       	rjmp	.+34     	; 0x15a8 <ProcessReceivedPacket+0x256>
			break;												// Ignore incoming IPCP TERM
		}
	}

	else if (PacketType == IP)
    1586:	81 32       	cpi	r24, 0x21	; 33
    1588:	91 05       	cpc	r25, r1
    158a:	19 f4       	brne	.+6      	; 0x1592 <ProcessReceivedPacket+0x240>
	{
		Debug("Got IP\r\n");									// Should never get this as we should have handed over to the TCP stack
    158c:	85 ed       	ldi	r24, 0xD5	; 213
    158e:	95 e0       	ldi	r25, 0x05	; 5
    1590:	0b c0       	rjmp	.+22     	; 0x15a8 <ProcessReceivedPacket+0x256>
	} 

	else if (PacketType == CHAP)								// Should never get this as we ask for PAP authentication
    1592:	22 ec       	ldi	r18, 0xC2	; 194
    1594:	83 32       	cpi	r24, 0x23	; 35
    1596:	92 07       	cpc	r25, r18
    1598:	19 f4       	brne	.+6      	; 0x15a0 <ProcessReceivedPacket+0x24e>
	{
		Debug("Got CHAP\r\n");
    159a:	8e ed       	ldi	r24, 0xDE	; 222
    159c:	95 e0       	ldi	r25, 0x05	; 5
    159e:	04 c0       	rjmp	.+8      	; 0x15a8 <ProcessReceivedPacket+0x256>
	}

	else if (PacketType)										// Ignore any other received packet types
    15a0:	89 2b       	or	r24, r25
    15a2:	21 f0       	breq	.+8      	; 0x15ac <ProcessReceivedPacket+0x25a>
	{				
		Debug("Got unknown packet\r\n");
    15a4:	89 ee       	ldi	r24, 0xE9	; 233
    15a6:	95 e0       	ldi	r25, 0x05	; 5
    15a8:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
  	}

	PacketType = NONE;											// Indicate that packet is processed
    15ac:	10 92 81 0a 	sts	0x0A81, r1
    15b0:	10 92 80 0a 	sts	0x0A80, r1
}
    15b4:	1f 91       	pop	r17
    15b6:	08 95       	ret

000015b8 <DoPPP>:
enum {LCPState, PAPState, IPCPState} PPPState;					// PPP negotiation states


// The main loop, login script, PPP state machine
void DoPPP(void)
{
    15b8:	2f 92       	push	r2
    15ba:	3f 92       	push	r3
    15bc:	4f 92       	push	r4
    15be:	5f 92       	push	r5
    15c0:	6f 92       	push	r6
    15c2:	7f 92       	push	r7
    15c4:	8f 92       	push	r8
    15c6:	9f 92       	push	r9
    15c8:	af 92       	push	r10
    15ca:	bf 92       	push	r11
    15cc:	cf 92       	push	r12
    15ce:	df 92       	push	r13
    15d0:	ef 92       	push	r14
    15d2:	ff 92       	push	r15
    15d4:	0f 93       	push	r16
    15d6:	1f 93       	push	r17
    15d8:	cf 93       	push	r28
    15da:	df 93       	push	r29
	int ModemData;
	int ExitFlag = 0;
	int CharCount = 0;

	// This will kick-start each phase of the PPP negotiations (LCP, PAP, IPCP)
	MakeInitialPacket();
    15dc:	5b de       	rcall	.-842    	; 0x1294 <MakeInitialPacket>
    15de:	ee 24       	eor	r14, r14
    15e0:	ff 24       	eor	r15, r15
				// Uncompress PPP framing header
				if (rx_ptr == 0 && c != 0xff)					// If Address-and-Control-Field-Compression is switched on
					rx_str[rx_ptr++] = 0xff;					// then the remote end is allowed to leave out the 0xff 0x03 header
	        													// so we add it back in if its missing
				if (rx_ptr == 1 && c != 0x03)
					rx_str[rx_ptr++] = 0x03;
    15e2:	32 e0       	ldi	r19, 0x02	; 2
    15e4:	23 2e       	mov	r2, r19
    15e6:	31 2c       	mov	r3, r1
	           		EscapeFlag = 0;								// Clear escape flag
	        	}
	        
				// Uncompress PPP framing header
				if (rx_ptr == 0 && c != 0xff)					// If Address-and-Control-Field-Compression is switched on
					rx_str[rx_ptr++] = 0xff;					// then the remote end is allowed to leave out the 0xff 0x03 header
    15e8:	21 e0       	ldi	r18, 0x01	; 1
    15ea:	42 2e       	mov	r4, r18
    15ec:	51 2c       	mov	r5, r1
			{
	        	CharCount++;
				
				if (EscapeFlag)									// If escape flag set from previous character
				{
	           		c ^= 0x20;									// Recover next character
    15ee:	90 e2       	ldi	r25, 0x20	; 32
    15f0:	89 2e       	mov	r8, r25
    15f2:	91 2c       	mov	r9, r1
					}
	        	}
				
				EscapeFlag = 0;									// Clear escape character flag
			   	rx_ptr = 0;										// Get ready for next packet
	        	checksum1 = 0xffff;								// Start new checksum
    15f4:	66 24       	eor	r6, r6
    15f6:	6a 94       	dec	r6
    15f8:	76 2c       	mov	r7, r6

	// Stay in this loop until we have either received a full PPP packet, or until we have sent a full PPP packet, or we have nothing to do
	do
	{
		// Receive a full PPP packet
		if (!((ModemData = modem_getc()) & MODEM_NO_DATA))		// Incoming character?
    15fa:	2c dc       	rcall	.-1960   	; 0xe54 <modem_getc>
    15fc:	9c 01       	movw	r18, r24
    15fe:	90 fd       	sbrc	r25, 0
    1600:	db c0       	rjmp	.+438    	; 0x17b8 <DoPPP+0x200>
		{
			c = ModemData;										// Get the character
	     
		 	if (c == 0x7e)										// Start or end of a packet 
    1602:	8e 37       	cpi	r24, 0x7E	; 126
    1604:	91 05       	cpc	r25, r1
    1606:	09 f0       	breq	.+2      	; 0x160a <DoPPP+0x52>
    1608:	4c c0       	rjmp	.+152    	; 0x16a2 <DoPPP+0xea>
			{	
	        	if (rx_ptr == 0)								// Start of packet
    160a:	80 91 bd 0a 	lds	r24, 0x0ABD
    160e:	90 91 be 0a 	lds	r25, 0x0ABE
    1612:	89 2b       	or	r24, r25
    1614:	51 f4       	brne	.+20     	; 0x162a <DoPPP+0x72>
				{
					Debug("\r\n\r\nReceive:\r\n7e ");
    1616:	8e ef       	ldi	r24, 0xFE	; 254
    1618:	95 e0       	ldi	r25, 0x05	; 5
    161a:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
    161e:	c0 e0       	ldi	r28, 0x00	; 0
    1620:	d0 e0       	ldi	r29, 0x00	; 0
    1622:	81 e0       	ldi	r24, 0x01	; 1
    1624:	e8 2e       	mov	r14, r24
    1626:	f1 2c       	mov	r15, r1
    1628:	31 c0       	rjmp	.+98     	; 0x168c <DoPPP+0xd4>
					CharCount = 1;
				}
				else											// End of packet
				{
					Debug("7e\r\n");
    162a:	80 e1       	ldi	r24, 0x10	; 16
    162c:	96 e0       	ldi	r25, 0x06	; 6
    162e:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>

					// If CRC passes, then accept packet
				 	if (~checksum1secondlast == (rx_str[rx_ptr - 1] * 256 + rx_str[rx_ptr - 2]))
    1632:	e0 91 bd 0a 	lds	r30, 0x0ABD
    1636:	f0 91 be 0a 	lds	r31, 0x0ABE
    163a:	20 91 b7 0a 	lds	r18, 0x0AB7
    163e:	30 91 b8 0a 	lds	r19, 0x0AB8
    1642:	20 95       	com	r18
    1644:	30 95       	com	r19
    1646:	ec 53       	subi	r30, 0x3C	; 60
    1648:	f3 4f       	sbci	r31, 0xF3	; 243
    164a:	d2 90       	ld	r13, -Z
    164c:	cc 24       	eor	r12, r12
    164e:	82 91       	ld	r24, -Z
    1650:	a6 01       	movw	r20, r12
    1652:	48 0f       	add	r20, r24
    1654:	51 1d       	adc	r21, r1
    1656:	24 17       	cp	r18, r20
    1658:	35 07       	cpc	r19, r21
    165a:	91 f4       	brne	.+36     	; 0x1680 <DoPPP+0xc8>
					{
						Debug("CRC OK\r\n");
    165c:	85 e1       	ldi	r24, 0x15	; 21
    165e:	96 e0       	ldi	r25, 0x06	; 6
    1660:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
	           			PacketType = rx_str[2] * 256 + rx_str[3];
    1664:	b0 90 c6 0c 	lds	r11, 0x0CC6
    1668:	aa 24       	eor	r10, r10
    166a:	80 91 c7 0c 	lds	r24, 0x0CC7
    166e:	95 01       	movw	r18, r10
    1670:	28 0f       	add	r18, r24
    1672:	31 1d       	adc	r19, r1
    1674:	30 93 81 0a 	sts	0x0A81, r19
    1678:	20 93 80 0a 	sts	0x0A80, r18

						ProcessReceivedPacket();				// Process the packet we received
    167c:	6a de       	rcall	.-812    	; 0x1352 <ProcessReceivedPacket>
    167e:	04 c0       	rjmp	.+8      	; 0x1688 <DoPPP+0xd0>
						ExitFlag = 1;
					}
					else
					{
						Debug("*** BAD CRC ***\r\n");
    1680:	8e e1       	ldi	r24, 0x1E	; 30
    1682:	96 e0       	ldi	r25, 0x06	; 6
    1684:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
    1688:	c1 e0       	ldi	r28, 0x01	; 1
    168a:	d0 e0       	ldi	r29, 0x00	; 0
						ExitFlag = 1;
					}
	        	}
				
				EscapeFlag = 0;									// Clear escape character flag
    168c:	10 92 82 0a 	sts	0x0A82, r1
			   	rx_ptr = 0;										// Get ready for next packet
    1690:	10 92 be 0a 	sts	0x0ABE, r1
    1694:	10 92 bd 0a 	sts	0x0ABD, r1
	        	checksum1 = 0xffff;								// Start new checksum
    1698:	70 92 c6 0e 	sts	0x0EC6, r7
    169c:	60 92 c5 0e 	sts	0x0EC5, r6
    16a0:	fb c0       	rjmp	.+502    	; 0x1898 <DoPPP+0x2e0>
	     	}
		  	else if (c == 0x7d)									// If escape character then set escape flag
    16a2:	8d 37       	cpi	r24, 0x7D	; 125
    16a4:	91 05       	cpc	r25, r1
    16a6:	21 f4       	brne	.+8      	; 0x16b0 <DoPPP+0xf8>
			{
				EscapeFlag = 1;
    16a8:	31 e0       	ldi	r19, 0x01	; 1
    16aa:	30 93 82 0a 	sts	0x0A82, r19
    16ae:	a5 cf       	rjmp	.-182    	; 0x15fa <DoPPP+0x42>
	     	}
			else												// Process the character
			{
	        	CharCount++;
    16b0:	08 94       	sec
    16b2:	e1 1c       	adc	r14, r1
    16b4:	f1 1c       	adc	r15, r1
				
				if (EscapeFlag)									// If escape flag set from previous character
    16b6:	80 91 82 0a 	lds	r24, 0x0A82
    16ba:	88 23       	and	r24, r24
    16bc:	21 f0       	breq	.+8      	; 0x16c6 <DoPPP+0x10e>
				{
	           		c ^= 0x20;									// Recover next character
    16be:	28 25       	eor	r18, r8
    16c0:	39 25       	eor	r19, r9
	           		EscapeFlag = 0;								// Clear escape flag
    16c2:	10 92 82 0a 	sts	0x0A82, r1
	        	}
	        
				// Uncompress PPP framing header
				if (rx_ptr == 0 && c != 0xff)					// If Address-and-Control-Field-Compression is switched on
    16c6:	80 91 bd 0a 	lds	r24, 0x0ABD
    16ca:	90 91 be 0a 	lds	r25, 0x0ABE
    16ce:	89 2b       	or	r24, r25
    16d0:	51 f4       	brne	.+20     	; 0x16e6 <DoPPP+0x12e>
    16d2:	2f 3f       	cpi	r18, 0xFF	; 255
    16d4:	31 05       	cpc	r19, r1
    16d6:	39 f0       	breq	.+14     	; 0x16e6 <DoPPP+0x12e>
					rx_str[rx_ptr++] = 0xff;					// then the remote end is allowed to leave out the 0xff 0x03 header
    16d8:	4f ef       	ldi	r20, 0xFF	; 255
    16da:	40 93 c4 0c 	sts	0x0CC4, r20
    16de:	50 92 be 0a 	sts	0x0ABE, r5
    16e2:	40 92 bd 0a 	sts	0x0ABD, r4
	        													// so we add it back in if its missing
				if (rx_ptr == 1 && c != 0x03)
    16e6:	80 91 bd 0a 	lds	r24, 0x0ABD
    16ea:	90 91 be 0a 	lds	r25, 0x0ABE
    16ee:	01 97       	sbiw	r24, 0x01	; 1
    16f0:	51 f4       	brne	.+20     	; 0x1706 <DoPPP+0x14e>
    16f2:	23 30       	cpi	r18, 0x03	; 3
    16f4:	31 05       	cpc	r19, r1
    16f6:	39 f0       	breq	.+14     	; 0x1706 <DoPPP+0x14e>
					rx_str[rx_ptr++] = 0x03;
    16f8:	53 e0       	ldi	r21, 0x03	; 3
    16fa:	50 93 c5 0c 	sts	0x0CC5, r21
    16fe:	30 92 be 0a 	sts	0x0ABE, r3
    1702:	20 92 bd 0a 	sts	0x0ABD, r2
			
				// Uncompress PPP protocol header
				if (rx_ptr == 2 && (c & 1))						// If Protocol-Field-Compression is switched on
    1706:	80 91 bd 0a 	lds	r24, 0x0ABD
    170a:	90 91 be 0a 	lds	r25, 0x0ABE
    170e:	02 97       	sbiw	r24, 0x02	; 2
    1710:	51 f4       	brne	.+20     	; 0x1726 <DoPPP+0x16e>
    1712:	20 ff       	sbrs	r18, 0
    1714:	08 c0       	rjmp	.+16     	; 0x1726 <DoPPP+0x16e>
					rx_str[rx_ptr++] = 0x00;					// the remote end is allowed to leave out the initial 0x00 in the protocol field
    1716:	10 92 c6 0c 	sts	0x0CC6, r1
    171a:	83 e0       	ldi	r24, 0x03	; 3
    171c:	90 e0       	ldi	r25, 0x00	; 0
    171e:	90 93 be 0a 	sts	0x0ABE, r25
    1722:	80 93 bd 0a 	sts	0x0ABD, r24

		        rx_str[rx_ptr++] = c;							// Insert character in buffer
    1726:	80 91 bd 0a 	lds	r24, 0x0ABD
    172a:	90 91 be 0a 	lds	r25, 0x0ABE
    172e:	12 2f       	mov	r17, r18
    1730:	fc 01       	movw	r30, r24
    1732:	ec 53       	subi	r30, 0x3C	; 60
    1734:	f3 4f       	sbci	r31, 0xF3	; 243
    1736:	20 83       	st	Z, r18
    1738:	01 96       	adiw	r24, 0x01	; 1
    173a:	90 93 be 0a 	sts	0x0ABE, r25
    173e:	80 93 bd 0a 	sts	0x0ABD, r24
	        
				if (rx_ptr > MaxRx) 
    1742:	81 50       	subi	r24, 0x01	; 1
    1744:	92 40       	sbci	r25, 0x02	; 2
    1746:	30 f0       	brcs	.+12     	; 0x1754 <DoPPP+0x19c>
					rx_ptr = MaxRx;								// Increment pointer. Max is end of buffer
    1748:	40 e0       	ldi	r20, 0x00	; 0
    174a:	52 e0       	ldi	r21, 0x02	; 2
    174c:	50 93 be 0a 	sts	0x0ABE, r21
    1750:	40 93 bd 0a 	sts	0x0ABD, r20
				
				PrintHex(c);
    1754:	81 2f       	mov	r24, r17
    1756:	0e 94 09 01 	call	0x212	; 0x212 <PrintHex>

				if (CharCount % 16 == 0)
    175a:	c7 01       	movw	r24, r14
    175c:	8f 70       	andi	r24, 0x0F	; 15
    175e:	90 70       	andi	r25, 0x00	; 0
    1760:	89 2b       	or	r24, r25
    1762:	21 f4       	brne	.+8      	; 0x176c <DoPPP+0x1b4>
					Debug("\r\n");
    1764:	80 e3       	ldi	r24, 0x30	; 48
    1766:	96 e0       	ldi	r25, 0x06	; 6
    1768:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>

	        	checksum1secondlast = checksum1last;			// Keep a rolling count of the last 3 checksums
    176c:	80 91 c2 0c 	lds	r24, 0x0CC2
    1770:	90 91 c3 0c 	lds	r25, 0x0CC3
    1774:	90 93 b8 0a 	sts	0x0AB8, r25
    1778:	80 93 b7 0a 	sts	0x0AB7, r24
				checksum1last = checksum1;						// Eventually we need to see if the checksum is valid
    177c:	80 91 c5 0e 	lds	r24, 0x0EC5
    1780:	90 91 c6 0e 	lds	r25, 0x0EC6
    1784:	90 93 c3 0c 	sts	0x0CC3, r25
    1788:	80 93 c2 0c 	sts	0x0CC2, r24
    178c:	81 27       	eor	r24, r17
    178e:	08 2e       	mov	r0, r24
    1790:	82 95       	swap	r24
    1792:	80 7f       	andi	r24, 0xF0	; 240
    1794:	80 25       	eor	r24, r0
    1796:	09 2e       	mov	r0, r25
    1798:	98 2f       	mov	r25, r24
    179a:	82 95       	swap	r24
    179c:	8f 70       	andi	r24, 0x0F	; 15
    179e:	08 26       	eor	r0, r24
    17a0:	86 95       	lsr	r24
    17a2:	98 27       	eor	r25, r24
    17a4:	89 27       	eor	r24, r25
    17a6:	88 0f       	add	r24, r24
    17a8:	88 0f       	add	r24, r24
    17aa:	88 0f       	add	r24, r24
    17ac:	80 25       	eor	r24, r0
				checksum1 = CRC(checksum1, c);					// and we need the one two back (as the current one includes the checksum itself)
    17ae:	90 93 c6 0e 	sts	0x0EC6, r25
    17b2:	80 93 c5 0e 	sts	0x0EC5, r24
    17b6:	21 cf       	rjmp	.-446    	; 0x15fa <DoPPP+0x42>
	     	}
	  	} 
	   	
		// Send a full PPP packet
		else if (tx_end)										// Do we have data to send?
    17b8:	80 91 c9 0e 	lds	r24, 0x0EC9
    17bc:	90 91 ca 0e 	lds	r25, 0x0ECA
    17c0:	00 97       	sbiw	r24, 0x00	; 0
    17c2:	09 f4       	brne	.+2      	; 0x17c6 <DoPPP+0x20e>
    17c4:	6c c0       	rjmp	.+216    	; 0x189e <DoPPP+0x2e6>
		{
	     	c = tx_str[tx_ptr];									// Get character from buffer
    17c6:	20 91 b5 0a 	lds	r18, 0x0AB5
    17ca:	30 91 b6 0a 	lds	r19, 0x0AB6
    17ce:	f9 01       	movw	r30, r18
    17d0:	e1 54       	subi	r30, 0x41	; 65
    17d2:	f5 4f       	sbci	r31, 0xF5	; 245
    17d4:	e0 81       	ld	r30, Z

	     	if (tx_ptr == tx_end)								// Was it the last character
    17d6:	28 17       	cp	r18, r24
    17d8:	39 07       	cpc	r19, r25
    17da:	69 f4       	brne	.+26     	; 0x17f6 <DoPPP+0x23e>
			{
	        	tx_end = 0;										// Mark buffer empty
    17dc:	10 92 ca 0e 	sts	0x0ECA, r1
    17e0:	10 92 c9 0e 	sts	0x0EC9, r1
	        	c = 0x7e;										// Send end-of-frame character
				
				Debug("7e\r\n");
    17e4:	80 e1       	ldi	r24, 0x10	; 16
    17e6:	96 e0       	ldi	r25, 0x06	; 6
    17e8:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
    17ec:	0e e7       	ldi	r16, 0x7E	; 126
    17ee:	10 e0       	ldi	r17, 0x00	; 0
    17f0:	c1 e0       	ldi	r28, 0x01	; 1
    17f2:	d0 e0       	ldi	r29, 0x00	; 0
    17f4:	4f c0       	rjmp	.+158    	; 0x1894 <DoPPP+0x2dc>
	  	} 
	   	
		// Send a full PPP packet
		else if (tx_end)										// Do we have data to send?
		{
	     	c = tx_str[tx_ptr];									// Get character from buffer
    17f6:	0e 2f       	mov	r16, r30
    17f8:	10 e0       	ldi	r17, 0x00	; 0
				
				Debug("7e\r\n");
				
				ExitFlag = 1;
	     	}
			else if (EscapeFlag)								// Sending escape sequence?
    17fa:	80 91 82 0a 	lds	r24, 0x0A82
    17fe:	88 23       	and	r24, r24
    1800:	a1 f0       	breq	.+40     	; 0x182a <DoPPP+0x272>
			{
				CharCount++;
    1802:	08 94       	sec
    1804:	e1 1c       	adc	r14, r1
    1806:	f1 1c       	adc	r15, r1
				PrintHex(c);
    1808:	8e 2f       	mov	r24, r30
    180a:	0e 94 09 01 	call	0x212	; 0x212 <PrintHex>

				if (CharCount % 16 == 0)
    180e:	c7 01       	movw	r24, r14
    1810:	8f 70       	andi	r24, 0x0F	; 15
    1812:	90 70       	andi	r25, 0x00	; 0
    1814:	89 2b       	or	r24, r25
    1816:	21 f4       	brne	.+8      	; 0x1820 <DoPPP+0x268>
					Debug("\r\n");
    1818:	80 e3       	ldi	r24, 0x30	; 48
    181a:	96 e0       	ldi	r25, 0x06	; 6
    181c:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>

				c ^= 0x20;										// Yes then convert character
    1820:	08 25       	eor	r16, r8
    1822:	19 25       	eor	r17, r9
	        	EscapeFlag = 0;									// Clear escape flag
    1824:	10 92 82 0a 	sts	0x0A82, r1
    1828:	2a c0       	rjmp	.+84     	; 0x187e <DoPPP+0x2c6>
	        	tx_ptr++;										// Point to next character
	     	}
			else if (c < 0x20 || c == 0x7d || c == 0x7e) 		// If escape sequence required?
    182a:	00 32       	cpi	r16, 0x20	; 32
    182c:	11 05       	cpc	r17, r1
    182e:	34 f0       	brlt	.+12     	; 0x183c <DoPPP+0x284>
    1830:	0d 37       	cpi	r16, 0x7D	; 125
    1832:	11 05       	cpc	r17, r1
    1834:	19 f0       	breq	.+6      	; 0x183c <DoPPP+0x284>
    1836:	0e 37       	cpi	r16, 0x7E	; 126
    1838:	11 05       	cpc	r17, r1
    183a:	31 f4       	brne	.+12     	; 0x1848 <DoPPP+0x290>
			{
	        	EscapeFlag = 1;									// Set escape flag
    183c:	51 e0       	ldi	r21, 0x01	; 1
    183e:	50 93 82 0a 	sts	0x0A82, r21
    1842:	0d e7       	ldi	r16, 0x7D	; 125
    1844:	10 e0       	ldi	r17, 0x00	; 0
    1846:	24 c0       	rjmp	.+72     	; 0x1890 <DoPPP+0x2d8>
	        	c = 0x7d;										// Send escape character
	     	}
			else 
			{		
	       		if (!tx_ptr)
    1848:	23 2b       	or	r18, r19
    184a:	51 f4       	brne	.+20     	; 0x1860 <DoPPP+0x2a8>
				{
					c = 0x7e;									// Send frame character if first character of packet
					Debug("\r\n\r\nSend:\r\n");
    184c:	83 e3       	ldi	r24, 0x33	; 51
    184e:	96 e0       	ldi	r25, 0x06	; 6
    1850:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
					CharCount = 0;
					EscapeFlag = 0;
    1854:	10 92 82 0a 	sts	0x0A82, r1
    1858:	0e e7       	ldi	r16, 0x7E	; 126
    185a:	10 e0       	ldi	r17, 0x00	; 0
    185c:	ee 24       	eor	r14, r14
    185e:	ff 24       	eor	r15, r15
				}

	       		CharCount++;
    1860:	08 94       	sec
    1862:	e1 1c       	adc	r14, r1
    1864:	f1 1c       	adc	r15, r1
				PrintHex(c);
    1866:	80 2f       	mov	r24, r16
    1868:	0e 94 09 01 	call	0x212	; 0x212 <PrintHex>

				if (CharCount % 16 == 0)
    186c:	c7 01       	movw	r24, r14
    186e:	8f 70       	andi	r24, 0x0F	; 15
    1870:	90 70       	andi	r25, 0x00	; 0
    1872:	89 2b       	or	r24, r25
    1874:	21 f4       	brne	.+8      	; 0x187e <DoPPP+0x2c6>
					Debug("\r\n");
    1876:	80 e3       	ldi	r24, 0x30	; 48
    1878:	96 e0       	ldi	r25, 0x06	; 6
    187a:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>

				tx_ptr++;
    187e:	80 91 b5 0a 	lds	r24, 0x0AB5
    1882:	90 91 b6 0a 	lds	r25, 0x0AB6
    1886:	01 96       	adiw	r24, 0x01	; 1
    1888:	90 93 b6 0a 	sts	0x0AB6, r25
    188c:	80 93 b5 0a 	sts	0x0AB5, r24
    1890:	c0 e0       	ldi	r28, 0x00	; 0
    1892:	d0 e0       	ldi	r29, 0x00	; 0
			}

			modem_putc(c);										// Put character in transmitter
    1894:	80 2f       	mov	r24, r16
    1896:	44 db       	rcall	.-2424   	; 0xf20 <modem_putc>

		// Nothing to Send or Receive
		else													
			ExitFlag = 1;
	}
	while (ExitFlag == 0);
    1898:	cd 2b       	or	r28, r29
    189a:	09 f4       	brne	.+2      	; 0x189e <DoPPP+0x2e6>
    189c:	ae ce       	rjmp	.-676    	; 0x15fa <DoPPP+0x42>
}
    189e:	df 91       	pop	r29
    18a0:	cf 91       	pop	r28
    18a2:	1f 91       	pop	r17
    18a4:	0f 91       	pop	r16
    18a6:	ff 90       	pop	r15
    18a8:	ef 90       	pop	r14
    18aa:	df 90       	pop	r13
    18ac:	cf 90       	pop	r12
    18ae:	bf 90       	pop	r11
    18b0:	af 90       	pop	r10
    18b2:	9f 90       	pop	r9
    18b4:	8f 90       	pop	r8
    18b6:	7f 90       	pop	r7
    18b8:	6f 90       	pop	r6
    18ba:	5f 90       	pop	r5
    18bc:	4f 90       	pop	r4
    18be:	3f 90       	pop	r3
    18c0:	2f 90       	pop	r2
    18c2:	08 95       	ret

000018c4 <timer_reset>:
 *
 * \sa timer_restart()
 */
void
timer_reset(struct timer *t)
{
    18c4:	fc 01       	movw	r30, r24
  t->start += t->interval;
    18c6:	80 81       	ld	r24, Z
    18c8:	91 81       	ldd	r25, Z+1	; 0x01
    18ca:	22 81       	ldd	r18, Z+2	; 0x02
    18cc:	33 81       	ldd	r19, Z+3	; 0x03
    18ce:	82 0f       	add	r24, r18
    18d0:	93 1f       	adc	r25, r19
    18d2:	91 83       	std	Z+1, r25	; 0x01
    18d4:	80 83       	st	Z, r24
}
    18d6:	08 95       	ret

000018d8 <timer_expired>:
 * \return Non-zero if the timer has expired, zero otherwise.
 *
 */
int
timer_expired(struct timer *t)
{
    18d8:	0f 93       	push	r16
    18da:	1f 93       	push	r17
    18dc:	8c 01       	movw	r16, r24
  return (clock_time_t)(clock_time() - t->start) >= (clock_time_t)t->interval;
    18de:	0e 94 f7 14 	call	0x29ee	; 0x29ee <clock_time>
    18e2:	40 e0       	ldi	r20, 0x00	; 0
    18e4:	50 e0       	ldi	r21, 0x00	; 0
    18e6:	f8 01       	movw	r30, r16
    18e8:	20 81       	ld	r18, Z
    18ea:	31 81       	ldd	r19, Z+1	; 0x01
    18ec:	82 1b       	sub	r24, r18
    18ee:	93 0b       	sbc	r25, r19
    18f0:	22 81       	ldd	r18, Z+2	; 0x02
    18f2:	33 81       	ldd	r19, Z+3	; 0x03
    18f4:	82 17       	cp	r24, r18
    18f6:	93 07       	cpc	r25, r19
    18f8:	10 f0       	brcs	.+4      	; 0x18fe <timer_expired+0x26>
    18fa:	41 e0       	ldi	r20, 0x01	; 1
    18fc:	50 e0       	ldi	r21, 0x00	; 0
}
    18fe:	ca 01       	movw	r24, r20
    1900:	1f 91       	pop	r17
    1902:	0f 91       	pop	r16
    1904:	08 95       	ret

00001906 <timer_set>:
 * \param interval The interval before the timer expires.
 *
 */
void
timer_set(struct timer *t, clock_time_t interval)
{
    1906:	0f 93       	push	r16
    1908:	1f 93       	push	r17
    190a:	8c 01       	movw	r16, r24
  t->interval = interval;
    190c:	fc 01       	movw	r30, r24
    190e:	73 83       	std	Z+3, r23	; 0x03
    1910:	62 83       	std	Z+2, r22	; 0x02
  t->start = clock_time();
    1912:	0e 94 f7 14 	call	0x29ee	; 0x29ee <clock_time>
    1916:	f8 01       	movw	r30, r16
    1918:	91 83       	std	Z+1, r25	; 0x01
    191a:	80 83       	st	Z, r24
}
    191c:	1f 91       	pop	r17
    191e:	0f 91       	pop	r16
    1920:	08 95       	ret

00001922 <uip_add32>:
#endif /* UIP_LOGGING == 1 */

#if ! UIP_ARCH_ADD32
void
uip_add32(u8_t *op32, u16_t op16)
{
    1922:	fc 01       	movw	r30, r24
  uip_acc32[3] = op32[3] + (op16 & 0xff);
    1924:	53 81       	ldd	r21, Z+3	; 0x03
    1926:	56 0f       	add	r21, r22
    1928:	50 93 d2 0e 	sts	0x0ED2, r21
  uip_acc32[2] = op32[2] + (op16 >> 8);
    192c:	27 2f       	mov	r18, r23
    192e:	33 27       	eor	r19, r19
    1930:	42 81       	ldd	r20, Z+2	; 0x02
    1932:	42 0f       	add	r20, r18
    1934:	40 93 d1 0e 	sts	0x0ED1, r20
  uip_acc32[1] = op32[1];
    1938:	a1 81       	ldd	r26, Z+1	; 0x01
    193a:	a0 93 d0 0e 	sts	0x0ED0, r26
  uip_acc32[0] = op32[0];
    193e:	e0 81       	ld	r30, Z
    1940:	e0 93 cf 0e 	sts	0x0ECF, r30
  
  if(uip_acc32[2] < (op16 >> 8)) {
    1944:	84 2f       	mov	r24, r20
    1946:	90 e0       	ldi	r25, 0x00	; 0
    1948:	82 17       	cp	r24, r18
    194a:	93 07       	cpc	r25, r19
    194c:	48 f4       	brcc	.+18     	; 0x1960 <uip_add32+0x3e>
    ++uip_acc32[1];
    194e:	8a 2f       	mov	r24, r26
    1950:	8f 5f       	subi	r24, 0xFF	; 255
    1952:	80 93 d0 0e 	sts	0x0ED0, r24
    if(uip_acc32[1] == 0) {
    1956:	88 23       	and	r24, r24
    1958:	19 f4       	brne	.+6      	; 0x1960 <uip_add32+0x3e>
      ++uip_acc32[0];
    195a:	ef 5f       	subi	r30, 0xFF	; 255
    195c:	e0 93 cf 0e 	sts	0x0ECF, r30
    }
  }
  
  
  if(uip_acc32[3] < (op16 & 0xff)) {
    1960:	85 2f       	mov	r24, r21
    1962:	90 e0       	ldi	r25, 0x00	; 0
    1964:	70 70       	andi	r23, 0x00	; 0
    1966:	86 17       	cp	r24, r22
    1968:	97 07       	cpc	r25, r23
    196a:	90 f4       	brcc	.+36     	; 0x1990 <uip_add32+0x6e>
    ++uip_acc32[2];
    196c:	84 2f       	mov	r24, r20
    196e:	8f 5f       	subi	r24, 0xFF	; 255
    1970:	80 93 d1 0e 	sts	0x0ED1, r24
    if(uip_acc32[2] == 0) {
    1974:	88 23       	and	r24, r24
    1976:	61 f4       	brne	.+24     	; 0x1990 <uip_add32+0x6e>
      ++uip_acc32[1];
    1978:	80 91 d0 0e 	lds	r24, 0x0ED0
    197c:	8f 5f       	subi	r24, 0xFF	; 255
    197e:	80 93 d0 0e 	sts	0x0ED0, r24
      if(uip_acc32[1] == 0) {
    1982:	88 23       	and	r24, r24
    1984:	29 f4       	brne	.+10     	; 0x1990 <uip_add32+0x6e>
	++uip_acc32[0];
    1986:	80 91 cf 0e 	lds	r24, 0x0ECF
    198a:	8f 5f       	subi	r24, 0xFF	; 255
    198c:	80 93 cf 0e 	sts	0x0ECF, r24
    1990:	08 95       	ret

00001992 <chksum>:

#if ! UIP_ARCH_CHKSUM
/*---------------------------------------------------------------------------*/
static u16_t
chksum(u16_t sum, const u8_t *data, u16_t len)
{
    1992:	9c 01       	movw	r18, r24
  u16_t t;
  const u8_t *dataptr;
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
    1994:	41 50       	subi	r20, 0x01	; 1
    1996:	50 40       	sbci	r21, 0x00	; 0
    1998:	46 0f       	add	r20, r22
    199a:	57 1f       	adc	r21, r23
    199c:	fb 01       	movw	r30, r22
    199e:	0e c0       	rjmp	.+28     	; 0x19bc <chksum+0x2a>
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    t = (dataptr[0] << 8) + dataptr[1];
    19a0:	70 81       	ld	r23, Z
    19a2:	60 e0       	ldi	r22, 0x00	; 0
    19a4:	81 81       	ldd	r24, Z+1	; 0x01
    19a6:	db 01       	movw	r26, r22
    19a8:	a8 0f       	add	r26, r24
    19aa:	b1 1d       	adc	r27, r1
    sum += t;
    19ac:	2a 0f       	add	r18, r26
    19ae:	3b 1f       	adc	r19, r27
    if(sum < t) {
    19b0:	2a 17       	cp	r18, r26
    19b2:	3b 07       	cpc	r19, r27
    19b4:	10 f4       	brcc	.+4      	; 0x19ba <chksum+0x28>
      sum++;		/* carry */
    19b6:	2f 5f       	subi	r18, 0xFF	; 255
    19b8:	3f 4f       	sbci	r19, 0xFF	; 255
    }
    dataptr += 2;
    19ba:	32 96       	adiw	r30, 0x02	; 2
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
  
  while(dataptr < last_byte) {	/* At least two more bytes */
    19bc:	e4 17       	cp	r30, r20
    19be:	f5 07       	cpc	r31, r21
    19c0:	78 f3       	brcs	.-34     	; 0x19a0 <chksum+0xe>
      sum++;		/* carry */
    }
    dataptr += 2;
  }
  
  if(dataptr == last_byte) {
    19c2:	e4 17       	cp	r30, r20
    19c4:	f5 07       	cpc	r31, r21
    19c6:	49 f4       	brne	.+18     	; 0x19da <chksum+0x48>
    t = (dataptr[0] << 8) + 0;
    19c8:	90 81       	ld	r25, Z
    19ca:	80 e0       	ldi	r24, 0x00	; 0
    sum += t;
    19cc:	28 0f       	add	r18, r24
    19ce:	39 1f       	adc	r19, r25
    if(sum < t) {
    19d0:	28 17       	cp	r18, r24
    19d2:	39 07       	cpc	r19, r25
    19d4:	10 f4       	brcc	.+4      	; 0x19da <chksum+0x48>
      sum++;		/* carry */
    19d6:	2f 5f       	subi	r18, 0xFF	; 255
    19d8:	3f 4f       	sbci	r19, 0xFF	; 255
    }
  }

  /* Return sum in host byte order. */
  return sum;
}
    19da:	c9 01       	movw	r24, r18
    19dc:	08 95       	ret

000019de <uip_ipchksum>:
u16_t
uip_ipchksum(void)
{
  u16_t sum;

  sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
    19de:	80 e0       	ldi	r24, 0x00	; 0
    19e0:	90 e0       	ldi	r25, 0x00	; 0
    19e2:	66 e0       	ldi	r22, 0x06	; 6
    19e4:	7f e0       	ldi	r23, 0x0F	; 15
    19e6:	44 e1       	ldi	r20, 0x14	; 20
    19e8:	50 e0       	ldi	r21, 0x00	; 0
    19ea:	d3 df       	rcall	.-90     	; 0x1992 <chksum>
  DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : htons(sum);
    19ec:	00 97       	sbiw	r24, 0x00	; 0
    19ee:	19 f4       	brne	.+6      	; 0x19f6 <uip_ipchksum+0x18>
    19f0:	2f ef       	ldi	r18, 0xFF	; 255
    19f2:	3f ef       	ldi	r19, 0xFF	; 255
    19f4:	02 c0       	rjmp	.+4      	; 0x19fa <uip_ipchksum+0x1c>
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
  return HTONS(val);
    19f6:	38 2f       	mov	r19, r24
    19f8:	29 2f       	mov	r18, r25
  u16_t sum;

  sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
  DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : htons(sum);
}
    19fa:	c9 01       	movw	r24, r18
    19fc:	08 95       	ret

000019fe <uip_tcpchksum>:
}
#endif /* UIP_CONF_IPV6 */
/*---------------------------------------------------------------------------*/
u16_t
uip_tcpchksum(void)
{
    19fe:	0f 93       	push	r16
    1a00:	1f 93       	push	r17
  u16_t sum;
  
#if UIP_CONF_IPV6
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
#else /* UIP_CONF_IPV6 */
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
    1a02:	00 91 09 0f 	lds	r16, 0x0F09
    1a06:	10 e0       	ldi	r17, 0x00	; 0
    1a08:	04 51       	subi	r16, 0x14	; 20
    1a0a:	10 40       	sbci	r17, 0x00	; 0
    1a0c:	90 91 08 0f 	lds	r25, 0x0F08
    1a10:	80 e0       	ldi	r24, 0x00	; 0
    1a12:	08 0f       	add	r16, r24
    1a14:	19 1f       	adc	r17, r25
  /* First sum pseudoheader. */
  
  /* IP protocol and length fields. This addition cannot carry. */
  sum = upper_layer_len + proto;
  /* Sum IP source and destination addresses. */
  sum = chksum(sum, (u8_t *)&BUF->srcipaddr[0], 2 * sizeof(uip_ipaddr_t));
    1a16:	c8 01       	movw	r24, r16
    1a18:	06 96       	adiw	r24, 0x06	; 6
    1a1a:	62 e1       	ldi	r22, 0x12	; 18
    1a1c:	7f e0       	ldi	r23, 0x0F	; 15
    1a1e:	48 e0       	ldi	r20, 0x08	; 8
    1a20:	50 e0       	ldi	r21, 0x00	; 0
    1a22:	b7 df       	rcall	.-146    	; 0x1992 <chksum>

  /* Sum TCP header and data. */
  sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
    1a24:	6a e1       	ldi	r22, 0x1A	; 26
    1a26:	7f e0       	ldi	r23, 0x0F	; 15
    1a28:	a8 01       	movw	r20, r16
    1a2a:	b3 df       	rcall	.-154    	; 0x1992 <chksum>
	       upper_layer_len);
    
  return (sum == 0) ? 0xffff : htons(sum);
    1a2c:	00 97       	sbiw	r24, 0x00	; 0
    1a2e:	19 f4       	brne	.+6      	; 0x1a36 <uip_tcpchksum+0x38>
    1a30:	2f ef       	ldi	r18, 0xFF	; 255
    1a32:	3f ef       	ldi	r19, 0xFF	; 255
    1a34:	02 c0       	rjmp	.+4      	; 0x1a3a <uip_tcpchksum+0x3c>
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
  return HTONS(val);
    1a36:	38 2f       	mov	r19, r24
    1a38:	29 2f       	mov	r18, r25
/*---------------------------------------------------------------------------*/
u16_t
uip_tcpchksum(void)
{
  return upper_layer_chksum(UIP_PROTO_TCP);
}
    1a3a:	c9 01       	movw	r24, r18
    1a3c:	1f 91       	pop	r17
    1a3e:	0f 91       	pop	r16
    1a40:	08 95       	ret

00001a42 <uip_init>:
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    1a42:	10 92 f9 0e 	sts	0x0EF9, r1
    1a46:	10 92 f8 0e 	sts	0x0EF8, r1
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    1a4a:	10 92 f3 0e 	sts	0x0EF3, r1
    uip_conns[c].tcpstateflags = UIP_CLOSED;
  }
#if UIP_ACTIVE_OPEN
  lastport = 1024;
    1a4e:	80 e0       	ldi	r24, 0x00	; 0
    1a50:	94 e0       	ldi	r25, 0x04	; 4
    1a52:	90 93 91 0a 	sts	0x0A91, r25
    1a56:	80 93 90 0a 	sts	0x0A90, r24
#endif /* UIP_ACTIVE_OPEN */

#if UIP_UDP
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    1a5a:	10 92 67 11 	sts	0x1167, r1
    1a5e:	10 92 66 11 	sts	0x1166, r1
    1a62:	81 e0       	ldi	r24, 0x01	; 1
    1a64:	80 93 92 0a 	sts	0x0A92, r24
  /* IPv4 initialization. */
#if UIP_FIXEDADDR == 0
  /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
#endif /* UIP_FIXEDADDR */

}
    1a68:	08 95       	ret

00001a6a <uip_connect>:
/*---------------------------------------------------------------------------*/
#if UIP_ACTIVE_OPEN
struct uip_conn *
uip_connect(uip_ipaddr_t *ripaddr, u16_t rport)
{
    1a6a:	dc 01       	movw	r26, r24

  /* Check if this port is already in use, and if so try to find
     another one. */
  for(c = 0; c < UIP_CONNS; ++c) {
    conn = &uip_conns[c];
    if(conn->tcpstateflags != UIP_CLOSED &&
    1a6c:	40 91 f3 0e 	lds	r20, 0x0EF3
    1a70:	e0 91 de 0e 	lds	r30, 0x0EDE
    1a74:	f0 91 df 0e 	lds	r31, 0x0EDF
    1a78:	20 91 90 0a 	lds	r18, 0x0A90
    1a7c:	30 91 91 0a 	lds	r19, 0x0A91
{
  register struct uip_conn *conn, *cconn;
  
  /* Find an unused local port. */
 again:
  ++lastport;
    1a80:	2f 5f       	subi	r18, 0xFF	; 255
    1a82:	3f 4f       	sbci	r19, 0xFF	; 255

  if(lastport >= 32000) {
    1a84:	5d e7       	ldi	r21, 0x7D	; 125
    1a86:	20 30       	cpi	r18, 0x00	; 0
    1a88:	35 07       	cpc	r19, r21
    1a8a:	10 f0       	brcs	.+4      	; 0x1a90 <uip_connect+0x26>
    1a8c:	20 e0       	ldi	r18, 0x00	; 0
    1a8e:	30 e1       	ldi	r19, 0x10	; 16
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
  return HTONS(val);
    1a90:	92 2f       	mov	r25, r18
    1a92:	83 2f       	mov	r24, r19

  /* Check if this port is already in use, and if so try to find
     another one. */
  for(c = 0; c < UIP_CONNS; ++c) {
    conn = &uip_conns[c];
    if(conn->tcpstateflags != UIP_CLOSED &&
    1a94:	44 23       	and	r20, r20
    1a96:	19 f0       	breq	.+6      	; 0x1a9e <uip_connect+0x34>
    1a98:	e8 17       	cp	r30, r24
    1a9a:	f9 07       	cpc	r31, r25
    1a9c:	89 f3       	breq	.-30     	; 0x1a80 <uip_connect+0x16>
    lastport = 4096;
  }

  /* Check if this port is already in use, and if so try to find
     another one. */
  for(c = 0; c < UIP_CONNS; ++c) {
    1a9e:	20 93 90 0a 	sts	0x0A90, r18
    1aa2:	30 93 91 0a 	sts	0x0A91, r19
    if(cconn->tcpstateflags == UIP_CLOSED) {
      conn = cconn;
      break;
    }
    if(cconn->tcpstateflags == UIP_TIME_WAIT) {
      if(conn == 0 ||
    1aa6:	80 e0       	ldi	r24, 0x00	; 0
    1aa8:	90 e0       	ldi	r25, 0x00	; 0
  }

  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    cconn = &uip_conns[c];
    if(cconn->tcpstateflags == UIP_CLOSED) {
    1aaa:	44 23       	and	r20, r20
    1aac:	29 f4       	brne	.+10     	; 0x1ab8 <uip_connect+0x4e>
    1aae:	10 92 92 0a 	sts	0x0A92, r1
    1ab2:	ea ed       	ldi	r30, 0xDA	; 218
    1ab4:	fe e0       	ldi	r31, 0x0E	; 14
    1ab6:	0a c0       	rjmp	.+20     	; 0x1acc <uip_connect+0x62>
      conn = cconn;
      break;
    }
    if(cconn->tcpstateflags == UIP_TIME_WAIT) {
    1ab8:	47 30       	cpi	r20, 0x07	; 7
    1aba:	11 f4       	brne	.+4      	; 0x1ac0 <uip_connect+0x56>
      if(conn == 0 ||
    1abc:	8a ed       	ldi	r24, 0xDA	; 218
    1abe:	9e e0       	ldi	r25, 0x0E	; 14
      goto again;
    }
  }

  conn = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    1ac0:	fc 01       	movw	r30, r24
    1ac2:	81 e0       	ldi	r24, 0x01	; 1
    1ac4:	80 93 92 0a 	sts	0x0A92, r24
	conn = cconn;
      }
    }
  }

  if(conn == 0) {
    1ac8:	30 97       	sbiw	r30, 0x00	; 0
    1aca:	79 f1       	breq	.+94     	; 0x1b2a <uip_connect+0xc0>
    return 0;
  }
  
  conn->tcpstateflags = UIP_SYN_SENT;
    1acc:	82 e0       	ldi	r24, 0x02	; 2
    1ace:	81 8f       	std	Z+25, r24	; 0x19

  conn->snd_nxt[0] = iss[0];
    1ad0:	80 91 8c 0a 	lds	r24, 0x0A8C
    1ad4:	84 87       	std	Z+12, r24	; 0x0c
  conn->snd_nxt[1] = iss[1];
    1ad6:	80 91 8d 0a 	lds	r24, 0x0A8D
    1ada:	85 87       	std	Z+13, r24	; 0x0d
  conn->snd_nxt[2] = iss[2];
    1adc:	80 91 8e 0a 	lds	r24, 0x0A8E
    1ae0:	86 87       	std	Z+14, r24	; 0x0e
  conn->snd_nxt[3] = iss[3];
    1ae2:	80 91 8f 0a 	lds	r24, 0x0A8F
    1ae6:	87 87       	std	Z+15, r24	; 0x0f

  conn->initialmss = conn->mss = UIP_TCP_MSS;
    1ae8:	80 e3       	ldi	r24, 0x30	; 48
    1aea:	92 e0       	ldi	r25, 0x02	; 2
    1aec:	93 8b       	std	Z+19, r25	; 0x13
    1aee:	82 8b       	std	Z+18, r24	; 0x12
    1af0:	95 8b       	std	Z+21, r25	; 0x15
    1af2:	84 8b       	std	Z+20, r24	; 0x14
  
  conn->len = 1;   /* TCP length of the SYN is one. */
    1af4:	81 e0       	ldi	r24, 0x01	; 1
    1af6:	90 e0       	ldi	r25, 0x00	; 0
    1af8:	91 8b       	std	Z+17, r25	; 0x11
    1afa:	80 8b       	std	Z+16, r24	; 0x10
  conn->nrtx = 0;
    1afc:	13 8e       	std	Z+27, r1	; 0x1b
  conn->timer = 1; /* Send the SYN next time around. */
    1afe:	81 e0       	ldi	r24, 0x01	; 1
    1b00:	82 8f       	std	Z+26, r24	; 0x1a
  conn->rto = UIP_RTO;
    1b02:	83 e0       	ldi	r24, 0x03	; 3
    1b04:	80 8f       	std	Z+24, r24	; 0x18
  conn->sa = 0;
    1b06:	16 8a       	std	Z+22, r1	; 0x16
  conn->sv = 16;   /* Initial value of the RTT variance. */
    1b08:	80 e1       	ldi	r24, 0x10	; 16
    1b0a:	87 8b       	std	Z+23, r24	; 0x17
  conn->lport = htons(lastport);
    1b0c:	34 83       	std	Z+4, r19	; 0x04
    1b0e:	25 83       	std	Z+5, r18	; 0x05
  conn->rport = rport;
    1b10:	77 83       	std	Z+7, r23	; 0x07
    1b12:	66 83       	std	Z+6, r22	; 0x06
  uip_ipaddr_copy(&conn->ripaddr, ripaddr);
    1b14:	8d 91       	ld	r24, X+
    1b16:	9c 91       	ld	r25, X
    1b18:	11 97       	sbiw	r26, 0x01	; 1
    1b1a:	91 83       	std	Z+1, r25	; 0x01
    1b1c:	80 83       	st	Z, r24
    1b1e:	12 96       	adiw	r26, 0x02	; 2
    1b20:	8d 91       	ld	r24, X+
    1b22:	9c 91       	ld	r25, X
    1b24:	13 97       	sbiw	r26, 0x03	; 3
    1b26:	93 83       	std	Z+3, r25	; 0x03
    1b28:	82 83       	std	Z+2, r24	; 0x02
  
  return conn;
}
    1b2a:	cf 01       	movw	r24, r30
    1b2c:	08 95       	ret

00001b2e <uip_add_rcv_nxt>:
}
#endif /* UIP_REASSEMBLY */
/*---------------------------------------------------------------------------*/
static void
uip_add_rcv_nxt(u16_t n)
{
    1b2e:	bc 01       	movw	r22, r24
  uip_add32(uip_conn->rcv_nxt, n);
    1b30:	80 91 d8 0e 	lds	r24, 0x0ED8
    1b34:	90 91 d9 0e 	lds	r25, 0x0ED9
    1b38:	08 96       	adiw	r24, 0x08	; 8
    1b3a:	f3 de       	rcall	.-538    	; 0x1922 <uip_add32>
  uip_conn->rcv_nxt[0] = uip_acc32[0];
    1b3c:	e0 91 d8 0e 	lds	r30, 0x0ED8
    1b40:	f0 91 d9 0e 	lds	r31, 0x0ED9
    1b44:	80 91 cf 0e 	lds	r24, 0x0ECF
    1b48:	80 87       	std	Z+8, r24	; 0x08
  uip_conn->rcv_nxt[1] = uip_acc32[1];
    1b4a:	80 91 d0 0e 	lds	r24, 0x0ED0
    1b4e:	81 87       	std	Z+9, r24	; 0x09
  uip_conn->rcv_nxt[2] = uip_acc32[2];
    1b50:	80 91 d1 0e 	lds	r24, 0x0ED1
    1b54:	82 87       	std	Z+10, r24	; 0x0a
  uip_conn->rcv_nxt[3] = uip_acc32[3];
    1b56:	80 91 d2 0e 	lds	r24, 0x0ED2
    1b5a:	83 87       	std	Z+11, r24	; 0x0b
}
    1b5c:	08 95       	ret

00001b5e <uip_send>:
  return HTONS(val);
}
/*---------------------------------------------------------------------------*/
void
uip_send(const void *data, int len)
{
    1b5e:	ac 01       	movw	r20, r24
    1b60:	fb 01       	movw	r30, r22
  if(len > 0) {
    1b62:	16 16       	cp	r1, r22
    1b64:	17 06       	cpc	r1, r23
    1b66:	84 f4       	brge	.+32     	; 0x1b88 <uip_send+0x2a>
    uip_slen = len;
    1b68:	60 93 60 11 	sts	0x1160, r22
    1b6c:	f0 93 61 11 	sts	0x1161, r31
    if(data != uip_sappdata) {
    1b70:	20 91 cd 0e 	lds	r18, 0x0ECD
    1b74:	30 91 ce 0e 	lds	r19, 0x0ECE
    1b78:	82 17       	cp	r24, r18
    1b7a:	93 07       	cpc	r25, r19
    1b7c:	29 f0       	breq	.+10     	; 0x1b88 <uip_send+0x2a>
      memcpy(uip_sappdata, (data), uip_slen);
    1b7e:	c9 01       	movw	r24, r18
    1b80:	ba 01       	movw	r22, r20
    1b82:	af 01       	movw	r20, r30
    1b84:	0c 94 74 00 	jmp	0xe8	; 0xe8 <memcpy>
    1b88:	08 95       	ret

00001b8a <uip_process>:
  uip_conn->rcv_nxt[3] = uip_acc32[3];
}
/*---------------------------------------------------------------------------*/
void
uip_process(u8_t flag)
{
    1b8a:	0f 93       	push	r16
    1b8c:	1f 93       	push	r17
    1b8e:	cf 93       	push	r28
    1b90:	df 93       	push	r29
  register struct uip_conn *uip_connr = uip_conn;
    1b92:	c0 91 d8 0e 	lds	r28, 0x0ED8
    1b96:	d0 91 d9 0e 	lds	r29, 0x0ED9

#if UIP_UDP
  if(flag == UIP_UDP_SEND_CONN) {
    1b9a:	84 30       	cpi	r24, 0x04	; 4
    1b9c:	09 f4       	brne	.+2      	; 0x1ba0 <uip_process+0x16>
    1b9e:	d4 c1       	rjmp	.+936    	; 0x1f48 <uip_process+0x3be>
    goto udp_send;
  }
#endif /* UIP_UDP */
  
  uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
    1ba0:	2e e2       	ldi	r18, 0x2E	; 46
    1ba2:	3f e0       	ldi	r19, 0x0F	; 15
    1ba4:	30 93 d7 0e 	sts	0x0ED7, r19
    1ba8:	20 93 d6 0e 	sts	0x0ED6, r18
    1bac:	30 93 ce 0e 	sts	0x0ECE, r19
    1bb0:	20 93 cd 0e 	sts	0x0ECD, r18

  /* Check if we were invoked because of a poll request for a
     particular connection. */
  if(flag == UIP_POLL_REQUEST) {
    1bb4:	83 30       	cpi	r24, 0x03	; 3
    1bb6:	59 f4       	brne	.+22     	; 0x1bce <uip_process+0x44>
    if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
    1bb8:	89 8d       	ldd	r24, Y+25	; 0x19
    1bba:	8f 70       	andi	r24, 0x0F	; 15
    1bbc:	83 30       	cpi	r24, 0x03	; 3
    1bbe:	09 f0       	breq	.+2      	; 0x1bc2 <uip_process+0x38>
    1bc0:	ea c6       	rjmp	.+3540   	; 0x2996 <__stack+0x897>
    1bc2:	88 89       	ldd	r24, Y+16	; 0x10
    1bc4:	99 89       	ldd	r25, Y+17	; 0x11
    1bc6:	89 2b       	or	r24, r25
    1bc8:	09 f0       	breq	.+2      	; 0x1bcc <uip_process+0x42>
    1bca:	e5 c6       	rjmp	.+3530   	; 0x2996 <__stack+0x897>
    1bcc:	89 c0       	rjmp	.+274    	; 0x1ce0 <uip_process+0x156>
	goto appsend;
    }
    goto drop;
    
    /* Check if we were invoked because of the perodic timer fireing. */
  } else if(flag == UIP_TIMER) {
    1bce:	82 30       	cpi	r24, 0x02	; 2
    1bd0:	09 f0       	breq	.+2      	; 0x1bd4 <uip_process+0x4a>
    1bd2:	8a c0       	rjmp	.+276    	; 0x1ce8 <uip_process+0x15e>
    if(uip_reasstmr != 0) {
      --uip_reasstmr;
    }
#endif /* UIP_REASSEMBLY */
    /* Increase the initial sequence number. */
    if(++iss[3] == 0) {
    1bd4:	80 91 8f 0a 	lds	r24, 0x0A8F
    1bd8:	8f 5f       	subi	r24, 0xFF	; 255
    1bda:	80 93 8f 0a 	sts	0x0A8F, r24
    1bde:	88 23       	and	r24, r24
    1be0:	99 f4       	brne	.+38     	; 0x1c08 <uip_process+0x7e>
      if(++iss[2] == 0) {
    1be2:	80 91 8e 0a 	lds	r24, 0x0A8E
    1be6:	8f 5f       	subi	r24, 0xFF	; 255
    1be8:	80 93 8e 0a 	sts	0x0A8E, r24
    1bec:	88 23       	and	r24, r24
    1bee:	61 f4       	brne	.+24     	; 0x1c08 <uip_process+0x7e>
	if(++iss[1] == 0) {
    1bf0:	80 91 8d 0a 	lds	r24, 0x0A8D
    1bf4:	8f 5f       	subi	r24, 0xFF	; 255
    1bf6:	80 93 8d 0a 	sts	0x0A8D, r24
    1bfa:	88 23       	and	r24, r24
    1bfc:	29 f4       	brne	.+10     	; 0x1c08 <uip_process+0x7e>
	  ++iss[0];
    1bfe:	80 91 8c 0a 	lds	r24, 0x0A8C
    1c02:	8f 5f       	subi	r24, 0xFF	; 255
    1c04:	80 93 8c 0a 	sts	0x0A8C, r24
	}
      }
    }

    /* Reset the length variables. */
    uip_len = 0;
    1c08:	10 92 cc 0e 	sts	0x0ECC, r1
    1c0c:	10 92 cb 0e 	sts	0x0ECB, r1
    uip_slen = 0;
    1c10:	10 92 61 11 	sts	0x1161, r1
    1c14:	10 92 60 11 	sts	0x1160, r1

    /* Check if the connection is in a state in which we simply wait
       for the connection to time out. If so, we increase the
       connection's timer and remove the connection if it times
       out. */
    if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
    1c18:	29 8d       	ldd	r18, Y+25	; 0x19
    1c1a:	27 30       	cpi	r18, 0x07	; 7
    1c1c:	11 f0       	breq	.+4      	; 0x1c22 <uip_process+0x98>
    1c1e:	25 30       	cpi	r18, 0x05	; 5
    1c20:	41 f4       	brne	.+16     	; 0x1c32 <uip_process+0xa8>
       uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
      ++(uip_connr->timer);
    1c22:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c24:	8f 5f       	subi	r24, 0xFF	; 255
    1c26:	8a 8f       	std	Y+26, r24	; 0x1a
      if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
    1c28:	88 37       	cpi	r24, 0x78	; 120
    1c2a:	09 f0       	breq	.+2      	; 0x1c2e <uip_process+0xa4>
    1c2c:	b4 c6       	rjmp	.+3432   	; 0x2996 <__stack+0x897>
	uip_connr->tcpstateflags = UIP_CLOSED;
    1c2e:	19 8e       	std	Y+25, r1	; 0x19
    1c30:	b2 c6       	rjmp	.+3428   	; 0x2996 <__stack+0x897>
      }
    } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
    1c32:	22 23       	and	r18, r18
    1c34:	09 f4       	brne	.+2      	; 0x1c38 <uip_process+0xae>
    1c36:	af c6       	rjmp	.+3422   	; 0x2996 <__stack+0x897>
      /* If the connection has outstanding data, we increase the
	 connection's timer and see if it has reached the RTO value
	 in which case we retransmit. */
      if(uip_outstanding(uip_connr)) {
    1c38:	88 89       	ldd	r24, Y+16	; 0x10
    1c3a:	99 89       	ldd	r25, Y+17	; 0x11
    1c3c:	89 2b       	or	r24, r25
    1c3e:	09 f4       	brne	.+2      	; 0x1c42 <uip_process+0xb8>
    1c40:	4b c0       	rjmp	.+150    	; 0x1cd8 <uip_process+0x14e>
	if(uip_connr->timer-- == 0) {
    1c42:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1c44:	81 50       	subi	r24, 0x01	; 1
    1c46:	8a 8f       	std	Y+26, r24	; 0x1a
    1c48:	8f 5f       	subi	r24, 0xFF	; 255
    1c4a:	09 f0       	breq	.+2      	; 0x1c4e <uip_process+0xc4>
    1c4c:	a4 c6       	rjmp	.+3400   	; 0x2996 <__stack+0x897>
	  if(uip_connr->nrtx == UIP_MAXRTX ||
    1c4e:	3b 8d       	ldd	r19, Y+27	; 0x1b
    1c50:	38 30       	cpi	r19, 0x08	; 8
    1c52:	29 f0       	breq	.+10     	; 0x1c5e <uip_process+0xd4>
    1c54:	21 50       	subi	r18, 0x01	; 1
    1c56:	22 30       	cpi	r18, 0x02	; 2
    1c58:	48 f4       	brcc	.+18     	; 0x1c6c <uip_process+0xe2>
    1c5a:	35 30       	cpi	r19, 0x05	; 5
    1c5c:	39 f4       	brne	.+14     	; 0x1c6c <uip_process+0xe2>
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
	    uip_connr->tcpstateflags = UIP_CLOSED;
    1c5e:	19 8e       	std	Y+25, r1	; 0x19

	    /* We call UIP_APPCALL() with uip_flags set to
	       UIP_TIMEDOUT to inform the application that the
	       connection has timed out. */
	    uip_flags = UIP_TIMEDOUT;
    1c60:	80 e8       	ldi	r24, 0x80	; 128
    1c62:	80 93 d3 0e 	sts	0x0ED3, r24
	    UIP_APPCALL();
    1c66:	0e 94 8a 03 	call	0x714	; 0x714 <TCPCallback>
    1c6a:	50 c5       	rjmp	.+2720   	; 0x270c <__stack+0x60d>
	    BUF->flags = TCP_RST | TCP_ACK;
	    goto tcp_send_nodata;
	  }

	  /* Exponential backoff. */
	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
    1c6c:	35 30       	cpi	r19, 0x05	; 5
    1c6e:	10 f0       	brcs	.+4      	; 0x1c74 <uip_process+0xea>
    1c70:	80 e3       	ldi	r24, 0x30	; 48
    1c72:	07 c0       	rjmp	.+14     	; 0x1c82 <uip_process+0xf8>
    1c74:	83 e0       	ldi	r24, 0x03	; 3
    1c76:	90 e0       	ldi	r25, 0x00	; 0
    1c78:	02 c0       	rjmp	.+4      	; 0x1c7e <uip_process+0xf4>
    1c7a:	88 0f       	add	r24, r24
    1c7c:	99 1f       	adc	r25, r25
    1c7e:	3a 95       	dec	r19
    1c80:	e2 f7       	brpl	.-8      	; 0x1c7a <uip_process+0xf0>
    1c82:	8a 8f       	std	Y+26, r24	; 0x1a
					 4:
					 uip_connr->nrtx);
	  ++(uip_connr->nrtx);
    1c84:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1c86:	8f 5f       	subi	r24, 0xFF	; 255
    1c88:	8b 8f       	std	Y+27, r24	; 0x1b
	     call upon the application so that it may prepare the
	     data for the retransmit. In SYN_RCVD, we resend the
	     SYNACK that we sent earlier and in LAST_ACK we have to
	     retransmit our FINACK. */
	  UIP_STAT(++uip_stat.tcp.rexmit);
	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    1c8a:	89 8d       	ldd	r24, Y+25	; 0x19
    1c8c:	90 e0       	ldi	r25, 0x00	; 0
    1c8e:	8f 70       	andi	r24, 0x0F	; 15
    1c90:	90 70       	andi	r25, 0x00	; 0
    1c92:	83 30       	cpi	r24, 0x03	; 3
    1c94:	91 05       	cpc	r25, r1
    1c96:	d1 f0       	breq	.+52     	; 0x1ccc <uip_process+0x142>
    1c98:	84 30       	cpi	r24, 0x04	; 4
    1c9a:	91 05       	cpc	r25, r1
    1c9c:	44 f4       	brge	.+16     	; 0x1cae <uip_process+0x124>
    1c9e:	81 30       	cpi	r24, 0x01	; 1
    1ca0:	91 05       	cpc	r25, r1
    1ca2:	09 f4       	brne	.+2      	; 0x1ca6 <uip_process+0x11c>
    1ca4:	1f c3       	rjmp	.+1598   	; 0x22e4 <__stack+0x1e5>
    1ca6:	02 97       	sbiw	r24, 0x02	; 2
    1ca8:	09 f0       	breq	.+2      	; 0x1cac <uip_process+0x122>
    1caa:	75 c6       	rjmp	.+3306   	; 0x2996 <__stack+0x897>
    1cac:	0c c0       	rjmp	.+24     	; 0x1cc6 <uip_process+0x13c>
    1cae:	86 30       	cpi	r24, 0x06	; 6
    1cb0:	91 05       	cpc	r25, r1
    1cb2:	09 f4       	brne	.+2      	; 0x1cb6 <uip_process+0x12c>
    1cb4:	bf c4       	rjmp	.+2430   	; 0x2634 <__stack+0x535>
    1cb6:	88 30       	cpi	r24, 0x08	; 8
    1cb8:	91 05       	cpc	r25, r1
    1cba:	09 f4       	brne	.+2      	; 0x1cbe <uip_process+0x134>
    1cbc:	bb c4       	rjmp	.+2422   	; 0x2634 <__stack+0x535>
    1cbe:	04 97       	sbiw	r24, 0x04	; 4
    1cc0:	09 f0       	breq	.+2      	; 0x1cc4 <uip_process+0x13a>
    1cc2:	69 c6       	rjmp	.+3282   	; 0x2996 <__stack+0x897>
    1cc4:	b7 c4       	rjmp	.+2414   	; 0x2634 <__stack+0x535>
	    goto tcp_send_synack;
	    
#if UIP_ACTIVE_OPEN
	  case UIP_SYN_SENT:
	    /* In the SYN_SENT state, we retransmit out SYN. */
	    BUF->flags = 0;
    1cc6:	10 92 27 0f 	sts	0x0F27, r1
    1cca:	0f c3       	rjmp	.+1566   	; 0x22ea <__stack+0x1eb>
	  case UIP_ESTABLISHED:
	    /* In the ESTABLISHED state, we call upon the application
               to do the actual retransmit after which we jump into
               the code for sending out the packet (the apprexmit
               label). */
	    uip_flags = UIP_REXMIT;
    1ccc:	84 e0       	ldi	r24, 0x04	; 4
    1cce:	80 93 d3 0e 	sts	0x0ED3, r24
	    UIP_APPCALL();
    1cd2:	0e 94 8a 03 	call	0x714	; 0x714 <TCPCallback>
    1cd6:	4f c5       	rjmp	.+2718   	; 0x2776 <__stack+0x677>
	    /* In all these states we should retransmit a FINACK. */
	    goto tcp_send_finack;
	    
	  }
	}
      } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
    1cd8:	2f 70       	andi	r18, 0x0F	; 15
    1cda:	23 30       	cpi	r18, 0x03	; 3
    1cdc:	09 f0       	breq	.+2      	; 0x1ce0 <uip_process+0x156>
    1cde:	5b c6       	rjmp	.+3254   	; 0x2996 <__stack+0x897>
	/* If there was no need for a retransmission, we poll the
           application for new data. */
	uip_flags = UIP_POLL;
    1ce0:	88 e0       	ldi	r24, 0x08	; 8
    1ce2:	80 93 d3 0e 	sts	0x0ED3, r24
    1ce6:	06 c5       	rjmp	.+2572   	; 0x26f4 <__stack+0x5f5>
      }
    }
    goto drop;
  }
#if UIP_UDP
  if(flag == UIP_UDP_TIMER) {
    1ce8:	85 30       	cpi	r24, 0x05	; 5
    1cea:	19 f5       	brne	.+70     	; 0x1d32 <uip_process+0x1a8>
    if(uip_udp_conn->lport != 0) {
    1cec:	e0 91 d4 0e 	lds	r30, 0x0ED4
    1cf0:	f0 91 d5 0e 	lds	r31, 0x0ED5
    1cf4:	84 81       	ldd	r24, Z+4	; 0x04
    1cf6:	95 81       	ldd	r25, Z+5	; 0x05
    1cf8:	89 2b       	or	r24, r25
    1cfa:	09 f4       	brne	.+2      	; 0x1cfe <uip_process+0x174>
    1cfc:	4c c6       	rjmp	.+3224   	; 0x2996 <__stack+0x897>
      uip_conn = NULL;
    1cfe:	10 92 d9 0e 	sts	0x0ED9, r1
    1d02:	10 92 d8 0e 	sts	0x0ED8, r1
      uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
    1d06:	c9 01       	movw	r24, r18
    1d08:	0c 97       	sbiw	r24, 0x0c	; 12
    1d0a:	90 93 d7 0e 	sts	0x0ED7, r25
    1d0e:	80 93 d6 0e 	sts	0x0ED6, r24
    1d12:	90 93 ce 0e 	sts	0x0ECE, r25
    1d16:	80 93 cd 0e 	sts	0x0ECD, r24
      uip_len = uip_slen = 0;
    1d1a:	10 92 61 11 	sts	0x1161, r1
    1d1e:	10 92 60 11 	sts	0x1160, r1
    1d22:	10 92 cc 0e 	sts	0x0ECC, r1
    1d26:	10 92 cb 0e 	sts	0x0ECB, r1
      uip_flags = UIP_POLL;
    1d2a:	88 e0       	ldi	r24, 0x08	; 8
    1d2c:	80 93 d3 0e 	sts	0x0ED3, r24
    1d30:	09 c1       	rjmp	.+530    	; 0x1f44 <uip_process+0x3ba>
    UIP_LOG("ipv6: invalid version.");
    goto drop;
  }
#else /* UIP_CONF_IPV6 */
  /* Check validity of the IP header. */
  if(BUF->vhl != 0x45)  { /* IP version and header length. */
    1d32:	89 01       	movw	r16, r18
    1d34:	08 52       	subi	r16, 0x28	; 40
    1d36:	10 40       	sbci	r17, 0x00	; 0
    1d38:	80 91 06 0f 	lds	r24, 0x0F06
    1d3c:	85 34       	cpi	r24, 0x45	; 69
    1d3e:	09 f0       	breq	.+2      	; 0x1d42 <uip_process+0x1b8>
    1d40:	2a c6       	rjmp	.+3156   	; 0x2996 <__stack+0x897>
     that the packet has been corrupted in transit. If the size of
     uip_len is larger than the size reported in the IP packet header,
     the packet has been padded and we set uip_len to the correct
     value.. */

  if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
    1d42:	90 91 08 0f 	lds	r25, 0x0F08
    1d46:	80 e0       	ldi	r24, 0x00	; 0
    1d48:	20 91 09 0f 	lds	r18, 0x0F09
    1d4c:	ac 01       	movw	r20, r24
    1d4e:	42 0f       	add	r20, r18
    1d50:	51 1d       	adc	r21, r1
    1d52:	80 91 cb 0e 	lds	r24, 0x0ECB
    1d56:	90 91 cc 0e 	lds	r25, 0x0ECC
    1d5a:	84 17       	cp	r24, r20
    1d5c:	95 07       	cpc	r25, r21
    1d5e:	08 f4       	brcc	.+2      	; 0x1d62 <uip_process+0x1d8>
    1d60:	1a c6       	rjmp	.+3124   	; 0x2996 <__stack+0x897>
    uip_len = (BUF->len[0] << 8) + BUF->len[1];
    1d62:	50 93 cc 0e 	sts	0x0ECC, r21
    1d66:	40 93 cb 0e 	sts	0x0ECB, r20
    goto drop;
  }

#if !UIP_CONF_IPV6
  /* Check the fragment flag. */
  if((BUF->ipoffset[0] & 0x3f) != 0 ||
    1d6a:	80 91 0c 0f 	lds	r24, 0x0F0C
    1d6e:	90 e0       	ldi	r25, 0x00	; 0
    1d70:	8f 73       	andi	r24, 0x3F	; 63
    1d72:	90 70       	andi	r25, 0x00	; 0
    1d74:	89 2b       	or	r24, r25
    1d76:	09 f0       	breq	.+2      	; 0x1d7a <uip_process+0x1f0>
    1d78:	0e c6       	rjmp	.+3100   	; 0x2996 <__stack+0x897>
    1d7a:	80 91 0d 0f 	lds	r24, 0x0F0D
    1d7e:	88 23       	and	r24, r24
    1d80:	09 f0       	breq	.+2      	; 0x1d84 <uip_process+0x1fa>
    1d82:	09 c6       	rjmp	.+3090   	; 0x2996 <__stack+0x897>
    goto drop;
#endif /* UIP_REASSEMBLY */
  }
#endif /* UIP_CONF_IPV6 */

  if(uip_ipaddr_cmp(uip_hostaddr, all_zeroes_addr)) {
    1d84:	20 91 02 0f 	lds	r18, 0x0F02
    1d88:	30 91 03 0f 	lds	r19, 0x0F03
    1d8c:	80 91 3f 06 	lds	r24, 0x063F
    1d90:	90 91 40 06 	lds	r25, 0x0640
    1d94:	28 17       	cp	r18, r24
    1d96:	39 07       	cpc	r19, r25
    1d98:	31 f4       	brne	.+12     	; 0x1da6 <uip_process+0x21c>
    1d9a:	80 91 04 0f 	lds	r24, 0x0F04
    1d9e:	90 91 05 0f 	lds	r25, 0x0F05
    1da2:	89 2b       	or	r24, r25
    1da4:	a1 f0       	breq	.+40     	; 0x1dce <uip_process+0x244>
    }
#endif /* UIP_BROADCAST */
    
    /* Check if the packet is destined for our IP address. */
#if !UIP_CONF_IPV6
    if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr)) {
    1da6:	80 91 16 0f 	lds	r24, 0x0F16
    1daa:	90 91 17 0f 	lds	r25, 0x0F17
    1dae:	82 17       	cp	r24, r18
    1db0:	93 07       	cpc	r25, r19
    1db2:	09 f0       	breq	.+2      	; 0x1db6 <uip_process+0x22c>
    1db4:	f0 c5       	rjmp	.+3040   	; 0x2996 <__stack+0x897>
    1db6:	20 91 18 0f 	lds	r18, 0x0F18
    1dba:	30 91 19 0f 	lds	r19, 0x0F19
    1dbe:	80 91 04 0f 	lds	r24, 0x0F04
    1dc2:	90 91 05 0f 	lds	r25, 0x0F05
    1dc6:	28 17       	cp	r18, r24
    1dc8:	39 07       	cpc	r19, r25
    1dca:	09 f0       	breq	.+2      	; 0x1dce <uip_process+0x244>
    1dcc:	e4 c5       	rjmp	.+3016   	; 0x2996 <__stack+0x897>
    }
#endif /* UIP_CONF_IPV6 */
  }

#if !UIP_CONF_IPV6
  if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
    1dce:	07 de       	rcall	.-1010   	; 0x19de <uip_ipchksum>
    1dd0:	8f 5f       	subi	r24, 0xFF	; 255
    1dd2:	9f 4f       	sbci	r25, 0xFF	; 255
    1dd4:	09 f0       	breq	.+2      	; 0x1dd8 <uip_process+0x24e>
    1dd6:	df c5       	rjmp	.+3006   	; 0x2996 <__stack+0x897>
    UIP_LOG("ip: bad checksum.");
    goto drop;
  }
#endif /* UIP_CONF_IPV6 */

  if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
    1dd8:	80 91 0f 0f 	lds	r24, 0x0F0F
    1ddc:	86 30       	cpi	r24, 0x06	; 6
    1dde:	09 f4       	brne	.+2      	; 0x1de2 <uip_process+0x258>
    1de0:	08 c1       	rjmp	.+528    	; 0x1ff2 <uip_process+0x468>
				       processing. */
    goto tcp_input;
  }

#if UIP_UDP
  if(BUF->proto == UIP_PROTO_UDP) {
    1de2:	81 31       	cpi	r24, 0x11	; 17
    1de4:	d1 f1       	breq	.+116    	; 0x1e5a <uip_process+0x2d0>
  }
#endif /* UIP_UDP */

#if !UIP_CONF_IPV6
  /* ICMPv4 processing code follows. */
  if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
    1de6:	81 30       	cpi	r24, 0x01	; 1
    1de8:	09 f0       	breq	.+2      	; 0x1dec <uip_process+0x262>
    1dea:	d5 c5       	rjmp	.+2986   	; 0x2996 <__stack+0x897>
  UIP_STAT(++uip_stat.icmp.recv);

  /* ICMP echo (i.e., ping) processing. This is simple, we only change
     the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
     checksum before we return the packet. */
  if(ICMPBUF->type != ICMP_ECHO) {
    1dec:	80 91 1a 0f 	lds	r24, 0x0F1A
    1df0:	88 30       	cpi	r24, 0x08	; 8
    1df2:	09 f0       	breq	.+2      	; 0x1df6 <uip_process+0x26c>
    1df4:	d0 c5       	rjmp	.+2976   	; 0x2996 <__stack+0x897>
    uip_hostaddr[0] = BUF->destipaddr[0];
    uip_hostaddr[1] = BUF->destipaddr[1];
  }
#endif /* UIP_PINGADDRCONF */

  ICMPBUF->type = ICMP_ECHO_REPLY;
    1df6:	10 92 1a 0f 	sts	0x0F1A, r1

  if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
    1dfa:	80 91 1c 0f 	lds	r24, 0x0F1C
    1dfe:	90 91 1d 0f 	lds	r25, 0x0F1D
    1e02:	ef ef       	ldi	r30, 0xFF	; 255
    1e04:	87 3f       	cpi	r24, 0xF7	; 247
    1e06:	9e 07       	cpc	r25, r30
    1e08:	10 f0       	brcs	.+4      	; 0x1e0e <uip_process+0x284>
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
    1e0a:	09 96       	adiw	r24, 0x09	; 9
    1e0c:	01 c0       	rjmp	.+2      	; 0x1e10 <uip_process+0x286>
  } else {
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
    1e0e:	08 96       	adiw	r24, 0x08	; 8
    1e10:	90 93 1d 0f 	sts	0x0F1D, r25
    1e14:	80 93 1c 0f 	sts	0x0F1C, r24
  }

  /* Swap IP addresses. */
  uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
    1e18:	80 91 12 0f 	lds	r24, 0x0F12
    1e1c:	90 91 13 0f 	lds	r25, 0x0F13
    1e20:	90 93 17 0f 	sts	0x0F17, r25
    1e24:	80 93 16 0f 	sts	0x0F16, r24
    1e28:	80 91 14 0f 	lds	r24, 0x0F14
    1e2c:	90 91 15 0f 	lds	r25, 0x0F15
    1e30:	90 93 19 0f 	sts	0x0F19, r25
    1e34:	80 93 18 0f 	sts	0x0F18, r24
  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
    1e38:	80 91 02 0f 	lds	r24, 0x0F02
    1e3c:	90 91 03 0f 	lds	r25, 0x0F03
    1e40:	90 93 13 0f 	sts	0x0F13, r25
    1e44:	80 93 12 0f 	sts	0x0F12, r24
    1e48:	80 91 04 0f 	lds	r24, 0x0F04
    1e4c:	90 91 05 0f 	lds	r25, 0x0F05
    1e50:	90 93 15 0f 	sts	0x0F15, r25
    1e54:	80 93 14 0f 	sts	0x0F14, r24
    1e58:	a2 c5       	rjmp	.+2884   	; 0x299e <__stack+0x89f>
    UIP_STAT(++uip_stat.udp.chkerr);
    UIP_LOG("udp: bad checksum.");
    goto drop;
  }
#else /* UIP_UDP_CHECKSUMS */
  uip_len = uip_len - UIP_IPUDPH_LEN;
    1e5a:	80 91 cb 0e 	lds	r24, 0x0ECB
    1e5e:	90 91 cc 0e 	lds	r25, 0x0ECC
    1e62:	4c 97       	sbiw	r24, 0x1c	; 28
    1e64:	90 93 cc 0e 	sts	0x0ECC, r25
    1e68:	80 93 cb 0e 	sts	0x0ECB, r24
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
    1e6c:	82 e6       	ldi	r24, 0x62	; 98
    1e6e:	91 e1       	ldi	r25, 0x11	; 17
    1e70:	90 93 d5 0e 	sts	0x0ED5, r25
    1e74:	80 93 d4 0e 	sts	0x0ED4, r24
    1e78:	46 c0       	rjmp	.+140    	; 0x1f06 <uip_process+0x37c>
       destination port number in the received packet. If the two port
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
    1e7a:	24 81       	ldd	r18, Z+4	; 0x04
    1e7c:	35 81       	ldd	r19, Z+5	; 0x05
    1e7e:	21 15       	cp	r18, r1
    1e80:	31 05       	cpc	r19, r1
    1e82:	e1 f1       	breq	.+120    	; 0x1efc <uip_process+0x372>
    1e84:	80 91 1c 0f 	lds	r24, 0x0F1C
    1e88:	90 91 1d 0f 	lds	r25, 0x0F1D
    1e8c:	82 17       	cp	r24, r18
    1e8e:	93 07       	cpc	r25, r19
    1e90:	a9 f5       	brne	.+106    	; 0x1efc <uip_process+0x372>
    1e92:	26 81       	ldd	r18, Z+6	; 0x06
    1e94:	37 81       	ldd	r19, Z+7	; 0x07
    1e96:	21 15       	cp	r18, r1
    1e98:	31 05       	cpc	r19, r1
    1e9a:	39 f0       	breq	.+14     	; 0x1eaa <uip_process+0x320>
    1e9c:	80 91 1a 0f 	lds	r24, 0x0F1A
    1ea0:	90 91 1b 0f 	lds	r25, 0x0F1B
    1ea4:	82 17       	cp	r24, r18
    1ea6:	93 07       	cpc	r25, r19
    1ea8:	49 f5       	brne	.+82     	; 0x1efc <uip_process+0x372>
    1eaa:	20 81       	ld	r18, Z
    1eac:	31 81       	ldd	r19, Z+1	; 0x01
    1eae:	80 91 3f 06 	lds	r24, 0x063F
    1eb2:	90 91 40 06 	lds	r25, 0x0640
    1eb6:	28 17       	cp	r18, r24
    1eb8:	39 07       	cpc	r19, r25
    1eba:	21 f4       	brne	.+8      	; 0x1ec4 <uip_process+0x33a>
    1ebc:	82 81       	ldd	r24, Z+2	; 0x02
    1ebe:	93 81       	ldd	r25, Z+3	; 0x03
    1ec0:	89 2b       	or	r24, r25
    1ec2:	59 f1       	breq	.+86     	; 0x1f1a <uip_process+0x390>
    1ec4:	80 91 43 06 	lds	r24, 0x0643
    1ec8:	90 91 44 06 	lds	r25, 0x0644
    1ecc:	28 17       	cp	r18, r24
    1ece:	39 07       	cpc	r19, r25
    1ed0:	29 f4       	brne	.+10     	; 0x1edc <uip_process+0x352>
    1ed2:	82 81       	ldd	r24, Z+2	; 0x02
    1ed4:	93 81       	ldd	r25, Z+3	; 0x03
    1ed6:	8f 5f       	subi	r24, 0xFF	; 255
    1ed8:	9f 4f       	sbci	r25, 0xFF	; 255
    1eda:	f9 f0       	breq	.+62     	; 0x1f1a <uip_process+0x390>
    1edc:	80 91 12 0f 	lds	r24, 0x0F12
    1ee0:	90 91 13 0f 	lds	r25, 0x0F13
    1ee4:	82 17       	cp	r24, r18
    1ee6:	93 07       	cpc	r25, r19
    1ee8:	49 f4       	brne	.+18     	; 0x1efc <uip_process+0x372>
    1eea:	20 91 14 0f 	lds	r18, 0x0F14
    1eee:	30 91 15 0f 	lds	r19, 0x0F15
    1ef2:	82 81       	ldd	r24, Z+2	; 0x02
    1ef4:	93 81       	ldd	r25, Z+3	; 0x03
    1ef6:	28 17       	cp	r18, r24
    1ef8:	39 07       	cpc	r19, r25
    1efa:	79 f0       	breq	.+30     	; 0x1f1a <uip_process+0x390>
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
      ++uip_udp_conn) {
    1efc:	3b 96       	adiw	r30, 0x0b	; 11
    1efe:	f0 93 d5 0e 	sts	0x0ED5, r31
    1f02:	e0 93 d4 0e 	sts	0x0ED4, r30
  uip_len = uip_len - UIP_IPUDPH_LEN;
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
    1f06:	e0 91 d4 0e 	lds	r30, 0x0ED4
    1f0a:	f0 91 d5 0e 	lds	r31, 0x0ED5
    1f0e:	51 e1       	ldi	r21, 0x11	; 17
    1f10:	ed 36       	cpi	r30, 0x6D	; 109
    1f12:	f5 07       	cpc	r31, r21
    1f14:	08 f4       	brcc	.+2      	; 0x1f18 <uip_process+0x38e>
    1f16:	b1 cf       	rjmp	.-158    	; 0x1e7a <uip_process+0x2f0>
    1f18:	3e c5       	rjmp	.+2684   	; 0x2996 <__stack+0x897>
  }
  UIP_LOG("udp: no matching connection found");
  goto drop;
  
 udp_found:
  uip_conn = NULL;
    1f1a:	10 92 d9 0e 	sts	0x0ED9, r1
    1f1e:	10 92 d8 0e 	sts	0x0ED8, r1
  uip_flags = UIP_NEWDATA;
    1f22:	82 e0       	ldi	r24, 0x02	; 2
    1f24:	80 93 d3 0e 	sts	0x0ED3, r24
  uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
    1f28:	82 e2       	ldi	r24, 0x22	; 34
    1f2a:	9f e0       	ldi	r25, 0x0F	; 15
    1f2c:	90 93 d7 0e 	sts	0x0ED7, r25
    1f30:	80 93 d6 0e 	sts	0x0ED6, r24
    1f34:	90 93 ce 0e 	sts	0x0ECE, r25
    1f38:	80 93 cd 0e 	sts	0x0ECD, r24
  uip_slen = 0;
    1f3c:	10 92 61 11 	sts	0x1161, r1
    1f40:	10 92 60 11 	sts	0x1160, r1
  UIP_UDP_APPCALL();
    1f44:	0e 94 8a 03 	call	0x714	; 0x714 <TCPCallback>
 udp_send:
  if(uip_slen == 0) {
    1f48:	20 91 60 11 	lds	r18, 0x1160
    1f4c:	30 91 61 11 	lds	r19, 0x1161
    1f50:	21 15       	cp	r18, r1
    1f52:	31 05       	cpc	r19, r1
    1f54:	09 f4       	brne	.+2      	; 0x1f58 <uip_process+0x3ce>
    1f56:	1f c5       	rjmp	.+2622   	; 0x2996 <__stack+0x897>
    goto drop;
  }
  uip_len = uip_slen + UIP_IPUDPH_LEN;
    1f58:	c9 01       	movw	r24, r18
    1f5a:	4c 96       	adiw	r24, 0x1c	; 28
    1f5c:	90 93 cc 0e 	sts	0x0ECC, r25
    1f60:	80 93 cb 0e 	sts	0x0ECB, r24
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
    1f64:	90 93 08 0f 	sts	0x0F08, r25
  BUF->len[1] = (uip_len & 0xff);
    1f68:	80 93 09 0f 	sts	0x0F09, r24
#endif /* UIP_CONF_IPV6 */

  BUF->ttl = uip_udp_conn->ttl;
    1f6c:	e0 91 d4 0e 	lds	r30, 0x0ED4
    1f70:	f0 91 d5 0e 	lds	r31, 0x0ED5
    1f74:	80 85       	ldd	r24, Z+8	; 0x08
    1f76:	80 93 0e 0f 	sts	0x0F0E, r24
  BUF->proto = UIP_PROTO_UDP;
    1f7a:	81 e1       	ldi	r24, 0x11	; 17
    1f7c:	80 93 0f 0f 	sts	0x0F0F, r24

  UDPBUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);
    1f80:	c9 01       	movw	r24, r18
    1f82:	08 96       	adiw	r24, 0x08	; 8
    1f84:	90 93 1e 0f 	sts	0x0F1E, r25
    1f88:	80 93 1f 0f 	sts	0x0F1F, r24
  UDPBUF->udpchksum = 0;
    1f8c:	10 92 21 0f 	sts	0x0F21, r1
    1f90:	10 92 20 0f 	sts	0x0F20, r1

  BUF->srcport  = uip_udp_conn->lport;
    1f94:	84 81       	ldd	r24, Z+4	; 0x04
    1f96:	95 81       	ldd	r25, Z+5	; 0x05
    1f98:	90 93 1b 0f 	sts	0x0F1B, r25
    1f9c:	80 93 1a 0f 	sts	0x0F1A, r24
  BUF->destport = uip_udp_conn->rport;
    1fa0:	86 81       	ldd	r24, Z+6	; 0x06
    1fa2:	97 81       	ldd	r25, Z+7	; 0x07
    1fa4:	90 93 1d 0f 	sts	0x0F1D, r25
    1fa8:	80 93 1c 0f 	sts	0x0F1C, r24

  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
    1fac:	80 91 02 0f 	lds	r24, 0x0F02
    1fb0:	90 91 03 0f 	lds	r25, 0x0F03
    1fb4:	90 93 13 0f 	sts	0x0F13, r25
    1fb8:	80 93 12 0f 	sts	0x0F12, r24
    1fbc:	80 91 04 0f 	lds	r24, 0x0F04
    1fc0:	90 91 05 0f 	lds	r25, 0x0F05
    1fc4:	90 93 15 0f 	sts	0x0F15, r25
    1fc8:	80 93 14 0f 	sts	0x0F14, r24
  uip_ipaddr_copy(BUF->destipaddr, uip_udp_conn->ripaddr);
    1fcc:	80 81       	ld	r24, Z
    1fce:	91 81       	ldd	r25, Z+1	; 0x01
    1fd0:	90 93 17 0f 	sts	0x0F17, r25
    1fd4:	80 93 16 0f 	sts	0x0F16, r24
    1fd8:	82 81       	ldd	r24, Z+2	; 0x02
    1fda:	93 81       	ldd	r25, Z+3	; 0x03
    1fdc:	90 93 19 0f 	sts	0x0F19, r25
    1fe0:	80 93 18 0f 	sts	0x0F18, r24
   
  uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
    1fe4:	8e e2       	ldi	r24, 0x2E	; 46
    1fe6:	9f e0       	ldi	r25, 0x0F	; 15
    1fe8:	90 93 d7 0e 	sts	0x0ED7, r25
    1fec:	80 93 d6 0e 	sts	0x0ED6, r24
    1ff0:	b0 c4       	rjmp	.+2400   	; 0x2952 <__stack+0x853>
 tcp_input:
  UIP_STAT(++uip_stat.tcp.recv);

  /* Start of TCP input header processing code. */
  
  if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
    1ff2:	05 dd       	rcall	.-1526   	; 0x19fe <uip_tcpchksum>
    1ff4:	8f 5f       	subi	r24, 0xFF	; 255
    1ff6:	9f 4f       	sbci	r25, 0xFF	; 255
    1ff8:	09 f0       	breq	.+2      	; 0x1ffc <uip_process+0x472>
    1ffa:	cd c4       	rjmp	.+2458   	; 0x2996 <__stack+0x897>
				       checksum. */
    UIP_STAT(++uip_stat.tcp.drop);
    UIP_STAT(++uip_stat.tcp.chkerr);
    UIP_LOG("tcp: bad checksum.");
    goto drop;
    1ffc:	ca ed       	ldi	r28, 0xDA	; 218
    1ffe:	de e0       	ldi	r29, 0x0E	; 14
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
    2000:	89 8d       	ldd	r24, Y+25	; 0x19
    2002:	88 23       	and	r24, r24
    2004:	29 f1       	breq	.+74     	; 0x2050 <uip_process+0x4c6>
    2006:	20 91 1c 0f 	lds	r18, 0x0F1C
    200a:	30 91 1d 0f 	lds	r19, 0x0F1D
    200e:	8c 81       	ldd	r24, Y+4	; 0x04
    2010:	9d 81       	ldd	r25, Y+5	; 0x05
    2012:	28 17       	cp	r18, r24
    2014:	39 07       	cpc	r19, r25
    2016:	e1 f4       	brne	.+56     	; 0x2050 <uip_process+0x4c6>
    2018:	20 91 1a 0f 	lds	r18, 0x0F1A
    201c:	30 91 1b 0f 	lds	r19, 0x0F1B
    2020:	8e 81       	ldd	r24, Y+6	; 0x06
    2022:	9f 81       	ldd	r25, Y+7	; 0x07
    2024:	28 17       	cp	r18, r24
    2026:	39 07       	cpc	r19, r25
    2028:	99 f4       	brne	.+38     	; 0x2050 <uip_process+0x4c6>
    202a:	20 91 12 0f 	lds	r18, 0x0F12
    202e:	30 91 13 0f 	lds	r19, 0x0F13
    2032:	88 81       	ld	r24, Y
    2034:	99 81       	ldd	r25, Y+1	; 0x01
    2036:	28 17       	cp	r18, r24
    2038:	39 07       	cpc	r19, r25
    203a:	51 f4       	brne	.+20     	; 0x2050 <uip_process+0x4c6>
    203c:	20 91 14 0f 	lds	r18, 0x0F14
    2040:	30 91 15 0f 	lds	r19, 0x0F15
    2044:	8a 81       	ldd	r24, Y+2	; 0x02
    2046:	9b 81       	ldd	r25, Y+3	; 0x03
    2048:	28 17       	cp	r18, r24
    204a:	39 07       	cpc	r19, r25
    204c:	09 f4       	brne	.+2      	; 0x2050 <uip_process+0x4c6>
    204e:	65 c1       	rjmp	.+714    	; 0x231a <__stack+0x21b>
  
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    2050:	6e 96       	adiw	r28, 0x1e	; 30
  }
  
  
  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
    2052:	fe e0       	ldi	r31, 0x0E	; 14
    2054:	ca 3d       	cpi	r28, 0xDA	; 218
    2056:	df 07       	cpc	r29, r31
    2058:	99 f2       	breq	.-90     	; 0x2000 <uip_process+0x476>
    205a:	90 f2       	brcs	.-92     	; 0x2000 <uip_process+0x476>

  /* If we didn't find and active connection that expected the packet,
     either this packet is an old duplicate, or this is a SYN packet
     destined for a connection in LISTEN. If the SYN flag isn't set,
     it is an old packet and we send a RST. */
  if((BUF->flags & TCP_CTL) != TCP_SYN) {
    205c:	80 91 27 0f 	lds	r24, 0x0F27
    2060:	8f 73       	andi	r24, 0x3F	; 63
    2062:	82 30       	cpi	r24, 0x02	; 2
    2064:	f1 f4       	brne	.+60     	; 0x20a2 <uip_process+0x518>
    goto reset;
  }
  
  tmp16 = BUF->destport;
    2066:	80 91 1c 0f 	lds	r24, 0x0F1C
    206a:	90 91 1d 0f 	lds	r25, 0x0F1D
    206e:	90 93 95 0a 	sts	0x0A95, r25
    2072:	80 93 94 0a 	sts	0x0A94, r24
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    2076:	10 92 92 0a 	sts	0x0A92, r1
    207a:	41 e0       	ldi	r20, 0x01	; 1
    207c:	0e c0       	rjmp	.+28     	; 0x209a <uip_process+0x510>
    if(tmp16 == uip_listenports[c])
    207e:	20 91 94 0a 	lds	r18, 0x0A94
    2082:	30 91 95 0a 	lds	r19, 0x0A95
    2086:	80 91 f8 0e 	lds	r24, 0x0EF8
    208a:	90 91 f9 0e 	lds	r25, 0x0EF9
    208e:	28 17       	cp	r18, r24
    2090:	39 07       	cpc	r19, r25
    2092:	09 f4       	brne	.+2      	; 0x2096 <uip_process+0x50c>
    2094:	70 c0       	rjmp	.+224    	; 0x2176 <__stack+0x77>
    goto reset;
  }
  
  tmp16 = BUF->destport;
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    2096:	40 93 92 0a 	sts	0x0A92, r20
    209a:	80 91 92 0a 	lds	r24, 0x0A92
    209e:	88 23       	and	r24, r24
    20a0:	71 f3       	breq	.-36     	; 0x207e <uip_process+0x4f4>
  /* No matching connection found, so we send a RST packet. */
  UIP_STAT(++uip_stat.tcp.synrst);
 reset:

  /* We do not send resets in response to resets. */
  if(BUF->flags & TCP_RST) {
    20a2:	80 91 27 0f 	lds	r24, 0x0F27
    20a6:	82 fd       	sbrc	r24, 2
    20a8:	76 c4       	rjmp	.+2284   	; 0x2996 <__stack+0x897>
    goto drop;
  }

  UIP_STAT(++uip_stat.tcp.rst);
  
  BUF->flags = TCP_RST | TCP_ACK;
    20aa:	84 e1       	ldi	r24, 0x14	; 20
    20ac:	f8 01       	movw	r30, r16
    20ae:	81 a3       	std	Z+33, r24	; 0x21
  uip_len = UIP_IPTCPH_LEN;
    20b0:	88 e2       	ldi	r24, 0x28	; 40
    20b2:	90 e0       	ldi	r25, 0x00	; 0
    20b4:	90 93 cc 0e 	sts	0x0ECC, r25
    20b8:	80 93 cb 0e 	sts	0x0ECB, r24
  BUF->tcpoffset = 5 << 4;
    20bc:	80 e5       	ldi	r24, 0x50	; 80
    20be:	80 a3       	std	Z+32, r24	; 0x20

  /* Flip the seqno and ackno fields in the TCP header. */
  c = BUF->seqno[3];
    20c0:	90 91 21 0f 	lds	r25, 0x0F21
  BUF->seqno[3] = BUF->ackno[3];
    20c4:	80 91 25 0f 	lds	r24, 0x0F25
    20c8:	83 8f       	std	Z+27, r24	; 0x1b
  BUF->ackno[3] = c;
  
  c = BUF->seqno[2];
    20ca:	30 91 20 0f 	lds	r19, 0x0F20
  BUF->seqno[2] = BUF->ackno[2];
    20ce:	80 91 24 0f 	lds	r24, 0x0F24
    20d2:	82 8f       	std	Z+26, r24	; 0x1a
  BUF->ackno[2] = c;
    20d4:	36 8f       	std	Z+30, r19	; 0x1e
  
  c = BUF->seqno[1];
    20d6:	40 91 1f 0f 	lds	r20, 0x0F1F
  BUF->seqno[1] = BUF->ackno[1];
    20da:	80 91 23 0f 	lds	r24, 0x0F23
    20de:	81 8f       	std	Z+25, r24	; 0x19
  BUF->ackno[1] = c;
    20e0:	45 8f       	std	Z+29, r20	; 0x1d
  
  c = BUF->seqno[0];
    20e2:	20 91 1e 0f 	lds	r18, 0x0F1E
    20e6:	20 93 92 0a 	sts	0x0A92, r18
  BUF->seqno[0] = BUF->ackno[0];
    20ea:	80 91 22 0f 	lds	r24, 0x0F22
    20ee:	80 8f       	std	Z+24, r24	; 0x18
  BUF->ackno[0] = c;
    20f0:	24 8f       	std	Z+28, r18	; 0x1c

  /* We also have to increase the sequence number we are
     acknowledging. If the least significant byte overflowed, we need
     to propagate the carry to the other bytes as well. */
  if(++BUF->ackno[3] == 0) {
    20f2:	9f 5f       	subi	r25, 0xFF	; 255
    20f4:	97 8f       	std	Z+31, r25	; 0x1f
    20f6:	99 23       	and	r25, r25
    20f8:	61 f4       	brne	.+24     	; 0x2112 <__stack+0x13>
    if(++BUF->ackno[2] == 0) {
    20fa:	83 2f       	mov	r24, r19
    20fc:	8f 5f       	subi	r24, 0xFF	; 255
    20fe:	86 8f       	std	Z+30, r24	; 0x1e
    2100:	88 23       	and	r24, r24
    2102:	39 f4       	brne	.+14     	; 0x2112 <__stack+0x13>
      if(++BUF->ackno[1] == 0) {
    2104:	84 2f       	mov	r24, r20
    2106:	8f 5f       	subi	r24, 0xFF	; 255
    2108:	85 8f       	std	Z+29, r24	; 0x1d
    210a:	88 23       	and	r24, r24
    210c:	11 f4       	brne	.+4      	; 0x2112 <__stack+0x13>
	++BUF->ackno[0];
    210e:	2f 5f       	subi	r18, 0xFF	; 255
    2110:	24 8f       	std	Z+28, r18	; 0x1c
      }
    }
  }
 
  /* Swap port numbers. */
  tmp16 = BUF->srcport;
    2112:	20 91 1a 0f 	lds	r18, 0x0F1A
    2116:	30 91 1b 0f 	lds	r19, 0x0F1B
    211a:	30 93 95 0a 	sts	0x0A95, r19
    211e:	20 93 94 0a 	sts	0x0A94, r18
  BUF->srcport = BUF->destport;
    2122:	80 91 1c 0f 	lds	r24, 0x0F1C
    2126:	90 91 1d 0f 	lds	r25, 0x0F1D
    212a:	f8 01       	movw	r30, r16
    212c:	95 8b       	std	Z+21, r25	; 0x15
    212e:	84 8b       	std	Z+20, r24	; 0x14
  BUF->destport = tmp16;
    2130:	37 8b       	std	Z+23, r19	; 0x17
    2132:	26 8b       	std	Z+22, r18	; 0x16
  
  /* Swap IP addresses. */
  uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
    2134:	80 91 12 0f 	lds	r24, 0x0F12
    2138:	90 91 13 0f 	lds	r25, 0x0F13
    213c:	90 93 17 0f 	sts	0x0F17, r25
    2140:	80 93 16 0f 	sts	0x0F16, r24
    2144:	80 91 14 0f 	lds	r24, 0x0F14
    2148:	90 91 15 0f 	lds	r25, 0x0F15
    214c:	90 93 19 0f 	sts	0x0F19, r25
    2150:	80 93 18 0f 	sts	0x0F18, r24
  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
    2154:	80 91 02 0f 	lds	r24, 0x0F02
    2158:	90 91 03 0f 	lds	r25, 0x0F03
    215c:	90 93 13 0f 	sts	0x0F13, r25
    2160:	80 93 12 0f 	sts	0x0F12, r24
    2164:	80 91 04 0f 	lds	r24, 0x0F04
    2168:	90 91 05 0f 	lds	r25, 0x0F05
    216c:	90 93 15 0f 	sts	0x0F15, r25
    2170:	80 93 14 0f 	sts	0x0F14, r24
    2174:	d4 c3       	rjmp	.+1960   	; 0x291e <__stack+0x81f>
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    2176:	10 92 92 0a 	sts	0x0A92, r1
    217a:	c0 e0       	ldi	r28, 0x00	; 0
    217c:	d0 e0       	ldi	r29, 0x00	; 0
    217e:	21 e0       	ldi	r18, 0x01	; 1
    2180:	14 c0       	rjmp	.+40     	; 0x21aa <__stack+0xab>
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
    2182:	80 91 f3 0e 	lds	r24, 0x0EF3
    2186:	88 23       	and	r24, r24
    2188:	19 f4       	brne	.+6      	; 0x2190 <__stack+0x91>
    218a:	ca ed       	ldi	r28, 0xDA	; 218
    218c:	de e0       	ldi	r29, 0x0E	; 14
    218e:	14 c0       	rjmp	.+40     	; 0x21b8 <__stack+0xb9>
      uip_connr = &uip_conns[c];
      break;
    }
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
    2190:	87 30       	cpi	r24, 0x07	; 7
    2192:	49 f4       	brne	.+18     	; 0x21a6 <__stack+0xa7>
      if(uip_connr == 0 ||
    2194:	20 97       	sbiw	r28, 0x00	; 0
    2196:	29 f0       	breq	.+10     	; 0x21a2 <__stack+0xa3>
    2198:	90 91 f4 0e 	lds	r25, 0x0EF4
    219c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    219e:	89 17       	cp	r24, r25
    21a0:	10 f4       	brcc	.+4      	; 0x21a6 <__stack+0xa7>
    21a2:	ca ed       	ldi	r28, 0xDA	; 218
    21a4:	de e0       	ldi	r29, 0x0E	; 14
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    21a6:	20 93 92 0a 	sts	0x0A92, r18
    21aa:	80 91 92 0a 	lds	r24, 0x0A92
    21ae:	88 23       	and	r24, r24
    21b0:	41 f3       	breq	.-48     	; 0x2182 <__stack+0x83>
	uip_connr = &uip_conns[c];
      }
    }
  }

  if(uip_connr == 0) {
    21b2:	20 97       	sbiw	r28, 0x00	; 0
    21b4:	09 f4       	brne	.+2      	; 0x21b8 <__stack+0xb9>
    21b6:	ef c3       	rjmp	.+2014   	; 0x2996 <__stack+0x897>
       have more spare connections. */
    UIP_STAT(++uip_stat.tcp.syndrop);
    UIP_LOG("tcp: found no unused connections.");
    goto drop;
  }
  uip_conn = uip_connr;
    21b8:	d0 93 d9 0e 	sts	0x0ED9, r29
    21bc:	c0 93 d8 0e 	sts	0x0ED8, r28
  
  /* Fill in the necessary fields for the new connection. */
  uip_connr->rto = uip_connr->timer = UIP_RTO;
    21c0:	83 e0       	ldi	r24, 0x03	; 3
    21c2:	8a 8f       	std	Y+26, r24	; 0x1a
    21c4:	88 8f       	std	Y+24, r24	; 0x18
  uip_connr->sa = 0;
    21c6:	1e 8a       	std	Y+22, r1	; 0x16
  uip_connr->sv = 4;
    21c8:	84 e0       	ldi	r24, 0x04	; 4
    21ca:	8f 8b       	std	Y+23, r24	; 0x17
  uip_connr->nrtx = 0;
    21cc:	1b 8e       	std	Y+27, r1	; 0x1b
  uip_connr->lport = BUF->destport;
    21ce:	80 91 1c 0f 	lds	r24, 0x0F1C
    21d2:	90 91 1d 0f 	lds	r25, 0x0F1D
    21d6:	9d 83       	std	Y+5, r25	; 0x05
    21d8:	8c 83       	std	Y+4, r24	; 0x04
  uip_connr->rport = BUF->srcport;
    21da:	80 91 1a 0f 	lds	r24, 0x0F1A
    21de:	90 91 1b 0f 	lds	r25, 0x0F1B
    21e2:	9f 83       	std	Y+7, r25	; 0x07
    21e4:	8e 83       	std	Y+6, r24	; 0x06
  uip_ipaddr_copy(uip_connr->ripaddr, BUF->srcipaddr);
    21e6:	80 91 12 0f 	lds	r24, 0x0F12
    21ea:	90 91 13 0f 	lds	r25, 0x0F13
    21ee:	99 83       	std	Y+1, r25	; 0x01
    21f0:	88 83       	st	Y, r24
    21f2:	80 91 14 0f 	lds	r24, 0x0F14
    21f6:	90 91 15 0f 	lds	r25, 0x0F15
    21fa:	9b 83       	std	Y+3, r25	; 0x03
    21fc:	8a 83       	std	Y+2, r24	; 0x02
  uip_connr->tcpstateflags = UIP_SYN_RCVD;
    21fe:	81 e0       	ldi	r24, 0x01	; 1
    2200:	89 8f       	std	Y+25, r24	; 0x19

  uip_connr->snd_nxt[0] = iss[0];
    2202:	80 91 8c 0a 	lds	r24, 0x0A8C
    2206:	8c 87       	std	Y+12, r24	; 0x0c
  uip_connr->snd_nxt[1] = iss[1];
    2208:	80 91 8d 0a 	lds	r24, 0x0A8D
    220c:	8d 87       	std	Y+13, r24	; 0x0d
  uip_connr->snd_nxt[2] = iss[2];
    220e:	80 91 8e 0a 	lds	r24, 0x0A8E
    2212:	8e 87       	std	Y+14, r24	; 0x0e
  uip_connr->snd_nxt[3] = iss[3];
    2214:	80 91 8f 0a 	lds	r24, 0x0A8F
    2218:	8f 87       	std	Y+15, r24	; 0x0f
  uip_connr->len = 1;
    221a:	81 e0       	ldi	r24, 0x01	; 1
    221c:	90 e0       	ldi	r25, 0x00	; 0
    221e:	99 8b       	std	Y+17, r25	; 0x11
    2220:	88 8b       	std	Y+16, r24	; 0x10

  /* rcv_nxt should be the seqno from the incoming packet + 1. */
  uip_connr->rcv_nxt[3] = BUF->seqno[3];
    2222:	80 91 21 0f 	lds	r24, 0x0F21
    2226:	8b 87       	std	Y+11, r24	; 0x0b
  uip_connr->rcv_nxt[2] = BUF->seqno[2];
    2228:	80 91 20 0f 	lds	r24, 0x0F20
    222c:	8a 87       	std	Y+10, r24	; 0x0a
  uip_connr->rcv_nxt[1] = BUF->seqno[1];
    222e:	80 91 1f 0f 	lds	r24, 0x0F1F
    2232:	89 87       	std	Y+9, r24	; 0x09
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
    2234:	80 91 1e 0f 	lds	r24, 0x0F1E
    2238:	88 87       	std	Y+8, r24	; 0x08
  uip_add_rcv_nxt(1);
    223a:	81 e0       	ldi	r24, 0x01	; 1
    223c:	90 e0       	ldi	r25, 0x00	; 0
    223e:	77 dc       	rcall	.-1810   	; 0x1b2e <uip_add_rcv_nxt>

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    2240:	80 91 26 0f 	lds	r24, 0x0F26
    2244:	90 e0       	ldi	r25, 0x00	; 0
    2246:	80 7f       	andi	r24, 0xF0	; 240
    2248:	90 70       	andi	r25, 0x00	; 0
    224a:	81 35       	cpi	r24, 0x51	; 81
    224c:	91 05       	cpc	r25, r1
    224e:	0c f4       	brge	.+2      	; 0x2252 <__stack+0x153>
    2250:	49 c0       	rjmp	.+146    	; 0x22e4 <__stack+0x1e5>
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    2252:	10 92 92 0a 	sts	0x0A92, r1
    2256:	34 c0       	rjmp	.+104    	; 0x22c0 <__stack+0x1c1>
      opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
    2258:	f9 01       	movw	r30, r18
    225a:	ea 5f       	subi	r30, 0xFA	; 250
    225c:	f0 4f       	sbci	r31, 0xF0	; 240
    225e:	80 a5       	ldd	r24, Z+40	; 0x28
    2260:	80 93 93 0a 	sts	0x0A93, r24
      if(opt == TCP_OPT_END) {
    2264:	88 23       	and	r24, r24
    2266:	f1 f1       	breq	.+124    	; 0x22e4 <__stack+0x1e5>
	/* End of options. */
	break;
      } else if(opt == TCP_OPT_NOOP) {
    2268:	81 30       	cpi	r24, 0x01	; 1
    226a:	21 f4       	brne	.+8      	; 0x2274 <__stack+0x175>
	++c;
    226c:	4f 5f       	subi	r20, 0xFF	; 255
    226e:	40 93 92 0a 	sts	0x0A92, r20
    2272:	26 c0       	rjmp	.+76     	; 0x22c0 <__stack+0x1c1>
	/* NOP option. */
      } else if(opt == TCP_OPT_MSS &&
    2274:	82 30       	cpi	r24, 0x02	; 2
    2276:	c1 f4       	brne	.+48     	; 0x22a8 <__stack+0x1a9>
    2278:	81 a5       	ldd	r24, Z+41	; 0x29
    227a:	84 30       	cpi	r24, 0x04	; 4
    227c:	a9 f4       	brne	.+42     	; 0x22a8 <__stack+0x1a9>
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    227e:	32 a5       	ldd	r19, Z+42	; 0x2a
    2280:	20 e0       	ldi	r18, 0x00	; 0
    2282:	83 a5       	ldd	r24, Z+43	; 0x2b
    2284:	90 e0       	ldi	r25, 0x00	; 0
    2286:	82 2b       	or	r24, r18
    2288:	93 2b       	or	r25, r19
    228a:	90 93 95 0a 	sts	0x0A95, r25
    228e:	80 93 94 0a 	sts	0x0A94, r24
	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
	uip_connr->initialmss = uip_connr->mss =
    2292:	f2 e0       	ldi	r31, 0x02	; 2
    2294:	81 33       	cpi	r24, 0x31	; 49
    2296:	9f 07       	cpc	r25, r31
    2298:	10 f0       	brcs	.+4      	; 0x229e <__stack+0x19f>
    229a:	80 e3       	ldi	r24, 0x30	; 48
    229c:	92 e0       	ldi	r25, 0x02	; 2
    229e:	9b 8b       	std	Y+19, r25	; 0x13
    22a0:	8a 8b       	std	Y+18, r24	; 0x12
    22a2:	9d 8b       	std	Y+21, r25	; 0x15
    22a4:	8c 8b       	std	Y+20, r24	; 0x14
    22a6:	1e c0       	rjmp	.+60     	; 0x22e4 <__stack+0x1e5>
	/* And we are done processing options. */
	break;
      } else {
	/* All other options have a length field, so that we easily
	   can skip past them. */
	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    22a8:	90 91 92 0a 	lds	r25, 0x0A92
    22ac:	e9 2f       	mov	r30, r25
    22ae:	f0 e0       	ldi	r31, 0x00	; 0
    22b0:	ea 5f       	subi	r30, 0xFA	; 250
    22b2:	f0 4f       	sbci	r31, 0xF0	; 240
    22b4:	81 a5       	ldd	r24, Z+41	; 0x29
    22b6:	88 23       	and	r24, r24
    22b8:	a9 f0       	breq	.+42     	; 0x22e4 <__stack+0x1e5>
	  /* If the length field is zero, the options are malformed
	     and we don't process them further. */
	  break;
	}
	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    22ba:	89 0f       	add	r24, r25
    22bc:	80 93 92 0a 	sts	0x0A92, r24
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
  uip_add_rcv_nxt(1);

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    22c0:	40 91 92 0a 	lds	r20, 0x0A92
    22c4:	24 2f       	mov	r18, r20
    22c6:	30 e0       	ldi	r19, 0x00	; 0
    22c8:	80 91 26 0f 	lds	r24, 0x0F26
    22cc:	82 95       	swap	r24
    22ce:	8f 70       	andi	r24, 0x0F	; 15
    22d0:	90 e0       	ldi	r25, 0x00	; 0
    22d2:	05 97       	sbiw	r24, 0x05	; 5
    22d4:	88 0f       	add	r24, r24
    22d6:	99 1f       	adc	r25, r25
    22d8:	88 0f       	add	r24, r24
    22da:	99 1f       	adc	r25, r25
    22dc:	28 17       	cp	r18, r24
    22de:	39 07       	cpc	r19, r25
    22e0:	0c f4       	brge	.+2      	; 0x22e4 <__stack+0x1e5>
    22e2:	ba cf       	rjmp	.-140    	; 0x2258 <__stack+0x159>
  }
  
  /* Our response will be a SYNACK. */
#if UIP_ACTIVE_OPEN
 tcp_send_synack:
  BUF->flags = TCP_ACK;
    22e4:	80 e1       	ldi	r24, 0x10	; 16
    22e6:	80 93 27 0f 	sts	0x0F27, r24
  
 tcp_send_syn:
  BUF->flags |= TCP_SYN;
    22ea:	80 91 27 0f 	lds	r24, 0x0F27
    22ee:	82 60       	ori	r24, 0x02	; 2
    22f0:	80 93 27 0f 	sts	0x0F27, r24
  BUF->flags = TCP_SYN | TCP_ACK;
#endif /* UIP_ACTIVE_OPEN */
  
  /* We send out the TCP Maximum Segment Size option with our
     SYNACK. */
  BUF->optdata[0] = TCP_OPT_MSS;
    22f4:	92 e0       	ldi	r25, 0x02	; 2
    22f6:	90 93 2e 0f 	sts	0x0F2E, r25
  BUF->optdata[1] = TCP_OPT_MSS_LEN;
    22fa:	84 e0       	ldi	r24, 0x04	; 4
    22fc:	80 93 2f 0f 	sts	0x0F2F, r24
  BUF->optdata[2] = (UIP_TCP_MSS) / 256;
    2300:	90 93 30 0f 	sts	0x0F30, r25
  BUF->optdata[3] = (UIP_TCP_MSS) & 255;
    2304:	80 e3       	ldi	r24, 0x30	; 48
    2306:	80 93 31 0f 	sts	0x0F31, r24
  uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
    230a:	8c e2       	ldi	r24, 0x2C	; 44
    230c:	90 e0       	ldi	r25, 0x00	; 0
    230e:	90 93 cc 0e 	sts	0x0ECC, r25
    2312:	80 93 cb 0e 	sts	0x0ECB, r24
  BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
    2316:	80 e6       	ldi	r24, 0x60	; 96
    2318:	af c2       	rjmp	.+1374   	; 0x2878 <__stack+0x779>
  goto tcp_send;

  /* This label will be jumped to if we found an active connection. */
 found:
  uip_conn = uip_connr;
    231a:	d0 93 d9 0e 	sts	0x0ED9, r29
    231e:	c0 93 d8 0e 	sts	0x0ED8, r28
  uip_flags = 0;
    2322:	10 92 d3 0e 	sts	0x0ED3, r1
  /* We do a very naive form of TCP reset processing; we just accept
     any RST and kill our connection. We should in fact check if the
     sequence number of this reset is wihtin our advertised window
     before we accept the reset. */
  if(BUF->flags & TCP_RST) {
    2326:	80 91 27 0f 	lds	r24, 0x0F27
    232a:	48 2f       	mov	r20, r24
    232c:	50 e0       	ldi	r21, 0x00	; 0
    232e:	82 ff       	sbrs	r24, 2
    2330:	03 c0       	rjmp	.+6      	; 0x2338 <__stack+0x239>
    uip_connr->tcpstateflags = UIP_CLOSED;
    2332:	19 8e       	std	Y+25, r1	; 0x19
    UIP_LOG("tcp: got reset, aborting connection.");
    uip_flags = UIP_ABORT;
    2334:	80 e2       	ldi	r24, 0x20	; 32
    2336:	4c c2       	rjmp	.+1176   	; 0x27d0 <__stack+0x6d1>
    UIP_APPCALL();
    goto drop;
  }
  /* Calculated the length of the data, if the application has sent
     any data to us. */
  c = (BUF->tcpoffset >> 4) << 2;
    2338:	80 91 26 0f 	lds	r24, 0x0F26
    233c:	82 95       	swap	r24
    233e:	8f 70       	andi	r24, 0x0F	; 15
    2340:	88 0f       	add	r24, r24
    2342:	88 0f       	add	r24, r24
    2344:	80 93 92 0a 	sts	0x0A92, r24
  /* uip_len will contain the length of the actual TCP data. This is
     calculated by subtracing the length of the TCP header (in
     c) and the length of the IP header (20 bytes). */
  uip_len = uip_len - c - UIP_IPH_LEN;
    2348:	20 91 cb 0e 	lds	r18, 0x0ECB
    234c:	30 91 cc 0e 	lds	r19, 0x0ECC
    2350:	24 51       	subi	r18, 0x14	; 20
    2352:	30 40       	sbci	r19, 0x00	; 0
    2354:	28 1b       	sub	r18, r24
    2356:	31 09       	sbc	r19, r1
    2358:	30 93 cc 0e 	sts	0x0ECC, r19
    235c:	20 93 cb 0e 	sts	0x0ECB, r18

  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in. */
  if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
    2360:	89 8d       	ldd	r24, Y+25	; 0x19
    2362:	8f 70       	andi	r24, 0x0F	; 15
    2364:	82 30       	cpi	r24, 0x02	; 2
    2366:	29 f4       	brne	.+10     	; 0x2372 <__stack+0x273>
    2368:	4f 73       	andi	r20, 0x3F	; 63
    236a:	50 70       	andi	r21, 0x00	; 0
    236c:	42 31       	cpi	r20, 0x12	; 18
    236e:	51 05       	cpc	r21, r1
    2370:	09 f1       	breq	.+66     	; 0x23b4 <__stack+0x2b5>
       ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
    if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
    2372:	23 2b       	or	r18, r19
    2374:	39 f4       	brne	.+14     	; 0x2384 <__stack+0x285>
    2376:	80 91 27 0f 	lds	r24, 0x0F27
    237a:	90 e0       	ldi	r25, 0x00	; 0
    237c:	83 70       	andi	r24, 0x03	; 3
    237e:	90 70       	andi	r25, 0x00	; 0
    2380:	89 2b       	or	r24, r25
    2382:	c1 f0       	breq	.+48     	; 0x23b4 <__stack+0x2b5>
    2384:	90 91 1e 0f 	lds	r25, 0x0F1E
    2388:	88 85       	ldd	r24, Y+8	; 0x08
    238a:	98 17       	cp	r25, r24
    238c:	09 f0       	breq	.+2      	; 0x2390 <__stack+0x291>
    238e:	6a c2       	rjmp	.+1236   	; 0x2864 <__stack+0x765>
    2390:	90 91 1f 0f 	lds	r25, 0x0F1F
    2394:	89 85       	ldd	r24, Y+9	; 0x09
    2396:	98 17       	cp	r25, r24
    2398:	09 f0       	breq	.+2      	; 0x239c <__stack+0x29d>
    239a:	64 c2       	rjmp	.+1224   	; 0x2864 <__stack+0x765>
    239c:	90 91 20 0f 	lds	r25, 0x0F20
    23a0:	8a 85       	ldd	r24, Y+10	; 0x0a
    23a2:	98 17       	cp	r25, r24
    23a4:	09 f0       	breq	.+2      	; 0x23a8 <__stack+0x2a9>
    23a6:	5e c2       	rjmp	.+1212   	; 0x2864 <__stack+0x765>
    23a8:	90 91 21 0f 	lds	r25, 0x0F21
    23ac:	8b 85       	ldd	r24, Y+11	; 0x0b
    23ae:	98 17       	cp	r25, r24
    23b0:	09 f0       	breq	.+2      	; 0x23b4 <__stack+0x2b5>
    23b2:	58 c2       	rjmp	.+1200   	; 0x2864 <__stack+0x765>

  /* Next, check if the incoming segment acknowledges any outstanding
     data. If so, we update the sequence number, reset the length of
     the outstanding data, calculate RTT estimations, and reset the
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    23b4:	80 91 27 0f 	lds	r24, 0x0F27
    23b8:	84 ff       	sbrs	r24, 4
    23ba:	50 c0       	rjmp	.+160    	; 0x245c <__stack+0x35d>
    23bc:	68 89       	ldd	r22, Y+16	; 0x10
    23be:	79 89       	ldd	r23, Y+17	; 0x11
    23c0:	61 15       	cp	r22, r1
    23c2:	71 05       	cpc	r23, r1
    23c4:	09 f4       	brne	.+2      	; 0x23c8 <__stack+0x2c9>
    23c6:	4a c0       	rjmp	.+148    	; 0x245c <__stack+0x35d>
    uip_add32(uip_connr->snd_nxt, uip_connr->len);
    23c8:	ce 01       	movw	r24, r28
    23ca:	0c 96       	adiw	r24, 0x0c	; 12
    23cc:	aa da       	rcall	.-2732   	; 0x1922 <uip_add32>

    if(BUF->ackno[0] == uip_acc32[0] &&
    23ce:	20 91 22 0f 	lds	r18, 0x0F22
    23d2:	80 91 cf 0e 	lds	r24, 0x0ECF
    23d6:	28 17       	cp	r18, r24
    23d8:	09 f0       	breq	.+2      	; 0x23dc <__stack+0x2dd>
    23da:	40 c0       	rjmp	.+128    	; 0x245c <__stack+0x35d>
    23dc:	90 91 23 0f 	lds	r25, 0x0F23
    23e0:	80 91 d0 0e 	lds	r24, 0x0ED0
    23e4:	98 17       	cp	r25, r24
    23e6:	d1 f5       	brne	.+116    	; 0x245c <__stack+0x35d>
    23e8:	90 91 24 0f 	lds	r25, 0x0F24
    23ec:	80 91 d1 0e 	lds	r24, 0x0ED1
    23f0:	98 17       	cp	r25, r24
    23f2:	a1 f5       	brne	.+104    	; 0x245c <__stack+0x35d>
    23f4:	90 91 25 0f 	lds	r25, 0x0F25
    23f8:	80 91 d2 0e 	lds	r24, 0x0ED2
    23fc:	98 17       	cp	r25, r24
    23fe:	71 f5       	brne	.+92     	; 0x245c <__stack+0x35d>
       BUF->ackno[1] == uip_acc32[1] &&
       BUF->ackno[2] == uip_acc32[2] &&
       BUF->ackno[3] == uip_acc32[3]) {
      /* Update sequence number. */
      uip_connr->snd_nxt[0] = uip_acc32[0];
    2400:	2c 87       	std	Y+12, r18	; 0x0c
      uip_connr->snd_nxt[1] = uip_acc32[1];
    2402:	80 91 d0 0e 	lds	r24, 0x0ED0
    2406:	8d 87       	std	Y+13, r24	; 0x0d
      uip_connr->snd_nxt[2] = uip_acc32[2];
    2408:	80 91 d1 0e 	lds	r24, 0x0ED1
    240c:	8e 87       	std	Y+14, r24	; 0x0e
      uip_connr->snd_nxt[3] = uip_acc32[3];
    240e:	80 91 d2 0e 	lds	r24, 0x0ED2
    2412:	8f 87       	std	Y+15, r24	; 0x0f
	

      /* Do RTT estimation, unless we have done retransmissions. */
      if(uip_connr->nrtx == 0) {
    2414:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2416:	88 23       	and	r24, r24
    2418:	d1 f4       	brne	.+52     	; 0x244e <__stack+0x34f>
	signed char m;
	m = uip_connr->rto - uip_connr->timer;
	/* This is taken directly from VJs original code in his paper */
	m = m - (uip_connr->sa >> 3);
    241a:	2e 89       	ldd	r18, Y+22	; 0x16
    241c:	98 8d       	ldd	r25, Y+24	; 0x18
    241e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2420:	98 1b       	sub	r25, r24
    2422:	82 2f       	mov	r24, r18
    2424:	86 95       	lsr	r24
    2426:	86 95       	lsr	r24
    2428:	86 95       	lsr	r24
    242a:	98 1b       	sub	r25, r24
	uip_connr->sa += m;
    242c:	39 2f       	mov	r19, r25
    242e:	32 0f       	add	r19, r18
    2430:	3e 8b       	std	Y+22, r19	; 0x16
	if(m < 0) {
	  m = -m;
	}
	m = m - (uip_connr->sv >> 2);
    2432:	8f 89       	ldd	r24, Y+23	; 0x17
	uip_connr->sv += m;
    2434:	28 2f       	mov	r18, r24
    2436:	26 95       	lsr	r18
    2438:	26 95       	lsr	r18
    243a:	82 1b       	sub	r24, r18
    243c:	97 fd       	sbrc	r25, 7
    243e:	91 95       	neg	r25
    2440:	89 0f       	add	r24, r25
    2442:	8f 8b       	std	Y+23, r24	; 0x17
	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
    2444:	36 95       	lsr	r19
    2446:	36 95       	lsr	r19
    2448:	36 95       	lsr	r19
    244a:	83 0f       	add	r24, r19
    244c:	88 8f       	std	Y+24, r24	; 0x18

      }
      /* Set the acknowledged flag. */
      uip_flags = UIP_ACKDATA;
    244e:	81 e0       	ldi	r24, 0x01	; 1
    2450:	80 93 d3 0e 	sts	0x0ED3, r24
      /* Reset the retransmission timer. */
      uip_connr->timer = uip_connr->rto;
    2454:	88 8d       	ldd	r24, Y+24	; 0x18
    2456:	8a 8f       	std	Y+26, r24	; 0x1a

      /* Reset length of outstanding data. */
      uip_connr->len = 0;
    2458:	19 8a       	std	Y+17, r1	; 0x11
    245a:	18 8a       	std	Y+16, r1	; 0x10
    }
    
  }

  /* Do different things depending on in what state the connection is. */
  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    245c:	89 8d       	ldd	r24, Y+25	; 0x19
    245e:	28 2f       	mov	r18, r24
    2460:	30 e0       	ldi	r19, 0x00	; 0
    2462:	c9 01       	movw	r24, r18
    2464:	8f 70       	andi	r24, 0x0F	; 15
    2466:	90 70       	andi	r25, 0x00	; 0
    2468:	84 30       	cpi	r24, 0x04	; 4
    246a:	91 05       	cpc	r25, r1
    246c:	09 f4       	brne	.+2      	; 0x2470 <__stack+0x371>
    246e:	b5 c1       	rjmp	.+874    	; 0x27da <__stack+0x6db>
    2470:	85 30       	cpi	r24, 0x05	; 5
    2472:	91 05       	cpc	r25, r1
    2474:	5c f4       	brge	.+22     	; 0x248c <__stack+0x38d>
    2476:	82 30       	cpi	r24, 0x02	; 2
    2478:	91 05       	cpc	r25, r1
    247a:	89 f1       	breq	.+98     	; 0x24de <__stack+0x3df>
    247c:	83 30       	cpi	r24, 0x03	; 3
    247e:	91 05       	cpc	r25, r1
    2480:	0c f0       	brlt	.+2      	; 0x2484 <__stack+0x385>
    2482:	af c0       	rjmp	.+350    	; 0x25e2 <__stack+0x4e3>
    2484:	01 97       	sbiw	r24, 0x01	; 1
    2486:	09 f0       	breq	.+2      	; 0x248a <__stack+0x38b>
    2488:	86 c2       	rjmp	.+1292   	; 0x2996 <__stack+0x897>
    248a:	10 c0       	rjmp	.+32     	; 0x24ac <__stack+0x3ad>
    248c:	86 30       	cpi	r24, 0x06	; 6
    248e:	91 05       	cpc	r25, r1
    2490:	09 f4       	brne	.+2      	; 0x2494 <__stack+0x395>
    2492:	e0 c1       	rjmp	.+960    	; 0x2854 <__stack+0x755>
    2494:	86 30       	cpi	r24, 0x06	; 6
    2496:	91 05       	cpc	r25, r1
    2498:	0c f4       	brge	.+2      	; 0x249c <__stack+0x39d>
    249a:	be c1       	rjmp	.+892    	; 0x2818 <__stack+0x719>
    249c:	87 30       	cpi	r24, 0x07	; 7
    249e:	91 05       	cpc	r25, r1
    24a0:	09 f4       	brne	.+2      	; 0x24a4 <__stack+0x3a5>
    24a2:	e0 c1       	rjmp	.+960    	; 0x2864 <__stack+0x765>
    24a4:	08 97       	sbiw	r24, 0x08	; 8
    24a6:	09 f0       	breq	.+2      	; 0x24aa <__stack+0x3ab>
    24a8:	76 c2       	rjmp	.+1260   	; 0x2996 <__stack+0x897>
    24aa:	8c c1       	rjmp	.+792    	; 0x27c4 <__stack+0x6c5>
  case UIP_SYN_RCVD:
    /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
       we are waiting for an ACK that acknowledges the data we sent
       out the last time. Therefore, we want to have the UIP_ACKDATA
       flag set. If so, we enter the ESTABLISHED state. */
    if(uip_flags & UIP_ACKDATA) {
    24ac:	80 91 d3 0e 	lds	r24, 0x0ED3
    24b0:	80 ff       	sbrs	r24, 0
    24b2:	71 c2       	rjmp	.+1250   	; 0x2996 <__stack+0x897>
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    24b4:	83 e0       	ldi	r24, 0x03	; 3
    24b6:	89 8f       	std	Y+25, r24	; 0x19
      uip_flags = UIP_CONNECTED;
    24b8:	80 e4       	ldi	r24, 0x40	; 64
    24ba:	80 93 d3 0e 	sts	0x0ED3, r24
      uip_connr->len = 0;
    24be:	19 8a       	std	Y+17, r1	; 0x11
    24c0:	18 8a       	std	Y+16, r1	; 0x10
      if(uip_len > 0) {
    24c2:	20 91 cb 0e 	lds	r18, 0x0ECB
    24c6:	30 91 cc 0e 	lds	r19, 0x0ECC
    24ca:	21 15       	cp	r18, r1
    24cc:	31 05       	cpc	r19, r1
    24ce:	09 f4       	brne	.+2      	; 0x24d2 <__stack+0x3d3>
    24d0:	0d c1       	rjmp	.+538    	; 0x26ec <__stack+0x5ed>
        uip_flags |= UIP_NEWDATA;
    24d2:	82 e4       	ldi	r24, 0x42	; 66
    24d4:	80 93 d3 0e 	sts	0x0ED3, r24
        uip_add_rcv_nxt(uip_len);
    24d8:	c9 01       	movw	r24, r18
    24da:	29 db       	rcall	.-2478   	; 0x1b2e <uip_add_rcv_nxt>
    24dc:	07 c1       	rjmp	.+526    	; 0x26ec <__stack+0x5ed>
  case UIP_SYN_SENT:
    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
       our SYN. The rcv_nxt is set to sequence number in the SYNACK
       plus one, and we send an ACK. We move into the ESTABLISHED
       state. */
    if((uip_flags & UIP_ACKDATA) &&
    24de:	80 91 d3 0e 	lds	r24, 0x0ED3
    24e2:	80 ff       	sbrs	r24, 0
    24e4:	73 c0       	rjmp	.+230    	; 0x25cc <__stack+0x4cd>
    24e6:	80 91 27 0f 	lds	r24, 0x0F27
    24ea:	8f 73       	andi	r24, 0x3F	; 63
    24ec:	82 31       	cpi	r24, 0x12	; 18
    24ee:	09 f0       	breq	.+2      	; 0x24f2 <__stack+0x3f3>
    24f0:	6d c0       	rjmp	.+218    	; 0x25cc <__stack+0x4cd>
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
    24f2:	80 91 26 0f 	lds	r24, 0x0F26
    24f6:	90 e0       	ldi	r25, 0x00	; 0
    24f8:	80 7f       	andi	r24, 0xF0	; 240
    24fa:	90 70       	andi	r25, 0x00	; 0
    24fc:	81 35       	cpi	r24, 0x51	; 81
    24fe:	91 05       	cpc	r25, r1
    2500:	0c f4       	brge	.+2      	; 0x2504 <__stack+0x405>
    2502:	49 c0       	rjmp	.+146    	; 0x2596 <__stack+0x497>
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    2504:	10 92 92 0a 	sts	0x0A92, r1
    2508:	34 c0       	rjmp	.+104    	; 0x2572 <__stack+0x473>
	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
    250a:	f9 01       	movw	r30, r18
    250c:	ea 5f       	subi	r30, 0xFA	; 250
    250e:	f0 4f       	sbci	r31, 0xF0	; 240
    2510:	80 a5       	ldd	r24, Z+40	; 0x28
    2512:	80 93 93 0a 	sts	0x0A93, r24
	  if(opt == TCP_OPT_END) {
    2516:	88 23       	and	r24, r24
    2518:	f1 f1       	breq	.+124    	; 0x2596 <__stack+0x497>
	    /* End of options. */
	    break;
	  } else if(opt == TCP_OPT_NOOP) {
    251a:	81 30       	cpi	r24, 0x01	; 1
    251c:	21 f4       	brne	.+8      	; 0x2526 <__stack+0x427>
	    ++c;
    251e:	4f 5f       	subi	r20, 0xFF	; 255
    2520:	40 93 92 0a 	sts	0x0A92, r20
    2524:	26 c0       	rjmp	.+76     	; 0x2572 <__stack+0x473>
	    /* NOP option. */
	  } else if(opt == TCP_OPT_MSS &&
    2526:	82 30       	cpi	r24, 0x02	; 2
    2528:	c1 f4       	brne	.+48     	; 0x255a <__stack+0x45b>
    252a:	81 a5       	ldd	r24, Z+41	; 0x29
    252c:	84 30       	cpi	r24, 0x04	; 4
    252e:	a9 f4       	brne	.+42     	; 0x255a <__stack+0x45b>
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    2530:	32 a5       	ldd	r19, Z+42	; 0x2a
    2532:	20 e0       	ldi	r18, 0x00	; 0
    2534:	83 a5       	ldd	r24, Z+43	; 0x2b
    2536:	90 e0       	ldi	r25, 0x00	; 0
    2538:	82 2b       	or	r24, r18
    253a:	93 2b       	or	r25, r19
    253c:	90 93 95 0a 	sts	0x0A95, r25
    2540:	80 93 94 0a 	sts	0x0A94, r24
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
	    uip_connr->initialmss =
    2544:	22 e0       	ldi	r18, 0x02	; 2
    2546:	81 33       	cpi	r24, 0x31	; 49
    2548:	92 07       	cpc	r25, r18
    254a:	10 f0       	brcs	.+4      	; 0x2550 <__stack+0x451>
    254c:	80 e3       	ldi	r24, 0x30	; 48
    254e:	92 e0       	ldi	r25, 0x02	; 2
    2550:	9b 8b       	std	Y+19, r25	; 0x13
    2552:	8a 8b       	std	Y+18, r24	; 0x12
    2554:	9d 8b       	std	Y+21, r25	; 0x15
    2556:	8c 8b       	std	Y+20, r24	; 0x14
    2558:	1e c0       	rjmp	.+60     	; 0x2596 <__stack+0x497>
	    /* And we are done processing options. */
	    break;
	  } else {
	    /* All other options have a length field, so that we easily
	       can skip past them. */
	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    255a:	90 91 92 0a 	lds	r25, 0x0A92
    255e:	e9 2f       	mov	r30, r25
    2560:	f0 e0       	ldi	r31, 0x00	; 0
    2562:	ea 5f       	subi	r30, 0xFA	; 250
    2564:	f0 4f       	sbci	r31, 0xF0	; 240
    2566:	81 a5       	ldd	r24, Z+41	; 0x29
    2568:	88 23       	and	r24, r24
    256a:	a9 f0       	breq	.+42     	; 0x2596 <__stack+0x497>
	      /* If the length field is zero, the options are malformed
		 and we don't process them further. */
	      break;
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    256c:	89 0f       	add	r24, r25
    256e:	80 93 92 0a 	sts	0x0A92, r24
    if((uip_flags & UIP_ACKDATA) &&
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    2572:	40 91 92 0a 	lds	r20, 0x0A92
    2576:	24 2f       	mov	r18, r20
    2578:	30 e0       	ldi	r19, 0x00	; 0
    257a:	80 91 26 0f 	lds	r24, 0x0F26
    257e:	82 95       	swap	r24
    2580:	8f 70       	andi	r24, 0x0F	; 15
    2582:	90 e0       	ldi	r25, 0x00	; 0
    2584:	05 97       	sbiw	r24, 0x05	; 5
    2586:	88 0f       	add	r24, r24
    2588:	99 1f       	adc	r25, r25
    258a:	88 0f       	add	r24, r24
    258c:	99 1f       	adc	r25, r25
    258e:	28 17       	cp	r18, r24
    2590:	39 07       	cpc	r19, r25
    2592:	0c f4       	brge	.+2      	; 0x2596 <__stack+0x497>
    2594:	ba cf       	rjmp	.-140    	; 0x250a <__stack+0x40b>
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
	  }
	}
      }
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    2596:	83 e0       	ldi	r24, 0x03	; 3
    2598:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->rcv_nxt[0] = BUF->seqno[0];
    259a:	80 91 1e 0f 	lds	r24, 0x0F1E
    259e:	88 87       	std	Y+8, r24	; 0x08
      uip_connr->rcv_nxt[1] = BUF->seqno[1];
    25a0:	80 91 1f 0f 	lds	r24, 0x0F1F
    25a4:	89 87       	std	Y+9, r24	; 0x09
      uip_connr->rcv_nxt[2] = BUF->seqno[2];
    25a6:	80 91 20 0f 	lds	r24, 0x0F20
    25aa:	8a 87       	std	Y+10, r24	; 0x0a
      uip_connr->rcv_nxt[3] = BUF->seqno[3];
    25ac:	80 91 21 0f 	lds	r24, 0x0F21
    25b0:	8b 87       	std	Y+11, r24	; 0x0b
      uip_add_rcv_nxt(1);
    25b2:	81 e0       	ldi	r24, 0x01	; 1
    25b4:	90 e0       	ldi	r25, 0x00	; 0
    25b6:	bb da       	rcall	.-2698   	; 0x1b2e <uip_add_rcv_nxt>
      uip_flags = UIP_CONNECTED | UIP_NEWDATA;
    25b8:	82 e4       	ldi	r24, 0x42	; 66
    25ba:	80 93 d3 0e 	sts	0x0ED3, r24
      uip_connr->len = 0;
    25be:	19 8a       	std	Y+17, r1	; 0x11
    25c0:	18 8a       	std	Y+16, r1	; 0x10
      uip_len = 0;
    25c2:	10 92 cc 0e 	sts	0x0ECC, r1
    25c6:	10 92 cb 0e 	sts	0x0ECB, r1
    25ca:	90 c0       	rjmp	.+288    	; 0x26ec <__stack+0x5ed>
      uip_slen = 0;
      UIP_APPCALL();
      goto appsend;
    }
    /* Inform the application that the connection failed */
    uip_flags = UIP_ABORT;
    25cc:	80 e2       	ldi	r24, 0x20	; 32
    25ce:	80 93 d3 0e 	sts	0x0ED3, r24
    UIP_APPCALL();
    25d2:	0e 94 8a 03 	call	0x714	; 0x714 <TCPCallback>
    /* The connection is closed after we send the RST */
    uip_conn->tcpstateflags = UIP_CLOSED;
    25d6:	e0 91 d8 0e 	lds	r30, 0x0ED8
    25da:	f0 91 d9 0e 	lds	r31, 0x0ED9
    25de:	11 8e       	std	Z+25, r1	; 0x19
    25e0:	60 cd       	rjmp	.-1344   	; 0x20a2 <uip_process+0x518>
    If the incoming packet is a FIN, we should close the connection on
    this side as well, and we send out a FIN and enter the LAST_ACK
    state. We require that there is no outstanding data; otherwise the
    sequence numbers will be screwed up. */

    if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    25e2:	80 91 27 0f 	lds	r24, 0x0F27
    25e6:	80 ff       	sbrs	r24, 0
    25e8:	29 c0       	rjmp	.+82     	; 0x263c <__stack+0x53d>
    25ea:	24 fd       	sbrc	r18, 4
    25ec:	27 c0       	rjmp	.+78     	; 0x263c <__stack+0x53d>
      if(uip_outstanding(uip_connr)) {
    25ee:	88 89       	ldd	r24, Y+16	; 0x10
    25f0:	99 89       	ldd	r25, Y+17	; 0x11
    25f2:	89 2b       	or	r24, r25
    25f4:	09 f0       	breq	.+2      	; 0x25f8 <__stack+0x4f9>
    25f6:	cf c1       	rjmp	.+926    	; 0x2996 <__stack+0x897>
	goto drop;
      }
      uip_add_rcv_nxt(1 + uip_len);
    25f8:	80 91 cb 0e 	lds	r24, 0x0ECB
    25fc:	90 91 cc 0e 	lds	r25, 0x0ECC
    2600:	01 96       	adiw	r24, 0x01	; 1
    2602:	95 da       	rcall	.-2774   	; 0x1b2e <uip_add_rcv_nxt>
      uip_flags |= UIP_CLOSE;
    2604:	20 91 d3 0e 	lds	r18, 0x0ED3
    2608:	82 2f       	mov	r24, r18
    260a:	80 61       	ori	r24, 0x10	; 16
    260c:	80 93 d3 0e 	sts	0x0ED3, r24
      if(uip_len > 0) {
    2610:	80 91 cb 0e 	lds	r24, 0x0ECB
    2614:	90 91 cc 0e 	lds	r25, 0x0ECC
    2618:	89 2b       	or	r24, r25
    261a:	19 f0       	breq	.+6      	; 0x2622 <__stack+0x523>
	uip_flags |= UIP_NEWDATA;
    261c:	22 61       	ori	r18, 0x12	; 18
    261e:	20 93 d3 0e 	sts	0x0ED3, r18
      }
      UIP_APPCALL();
    2622:	0e 94 8a 03 	call	0x714	; 0x714 <TCPCallback>
      uip_connr->len = 1;
    2626:	81 e0       	ldi	r24, 0x01	; 1
    2628:	90 e0       	ldi	r25, 0x00	; 0
    262a:	99 8b       	std	Y+17, r25	; 0x11
    262c:	88 8b       	std	Y+16, r24	; 0x10
      uip_connr->tcpstateflags = UIP_LAST_ACK;
    262e:	88 e0       	ldi	r24, 0x08	; 8
    2630:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->nrtx = 0;
    2632:	1b 8e       	std	Y+27, r1	; 0x1b
    tcp_send_finack:
      BUF->flags = TCP_FIN | TCP_ACK;
    2634:	81 e1       	ldi	r24, 0x11	; 17
    2636:	80 93 27 0f 	sts	0x0F27, r24
    263a:	17 c1       	rjmp	.+558    	; 0x286a <__stack+0x76b>
      goto tcp_send_nodata;
    }

    /* Check the URG flag. If this is set, the segment carries urgent
       data that we must pass to the application. */
    if((BUF->flags & TCP_URG) != 0) {
    263c:	85 ff       	sbrs	r24, 5
    263e:	21 c0       	rjmp	.+66     	; 0x2682 <__stack+0x583>
      uip_urgdata = uip_appdata;
      uip_appdata += uip_urglen;
    } else {
      uip_urglen = 0;
#else /* UIP_URGDATA > 0 */
      uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
    2640:	60 91 2c 0f 	lds	r22, 0x0F2C
    2644:	36 2f       	mov	r19, r22
    2646:	20 e0       	ldi	r18, 0x00	; 0
    2648:	40 91 2d 0f 	lds	r20, 0x0F2D
    264c:	50 e0       	ldi	r21, 0x00	; 0
    264e:	24 2b       	or	r18, r20
    2650:	35 2b       	or	r19, r21
    2652:	80 91 d6 0e 	lds	r24, 0x0ED6
    2656:	90 91 d7 0e 	lds	r25, 0x0ED7
    265a:	82 0f       	add	r24, r18
    265c:	93 1f       	adc	r25, r19
    265e:	90 93 d7 0e 	sts	0x0ED7, r25
    2662:	80 93 d6 0e 	sts	0x0ED6, r24
      uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
    2666:	96 2f       	mov	r25, r22
    2668:	80 e0       	ldi	r24, 0x00	; 0
    266a:	84 2b       	or	r24, r20
    266c:	95 2b       	or	r25, r21
    266e:	20 91 cb 0e 	lds	r18, 0x0ECB
    2672:	30 91 cc 0e 	lds	r19, 0x0ECC
    2676:	28 1b       	sub	r18, r24
    2678:	39 0b       	sbc	r19, r25
    267a:	30 93 cc 0e 	sts	0x0ECC, r19
    267e:	20 93 cb 0e 	sts	0x0ECB, r18
    /* If uip_len > 0 we have TCP data in the packet, and we flag this
       by setting the UIP_NEWDATA flag and update the sequence number
       we acknowledge. If the application has stopped the dataflow
       using uip_stop(), we must not accept any data packets from the
       remote host. */
    if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    2682:	20 91 cb 0e 	lds	r18, 0x0ECB
    2686:	30 91 cc 0e 	lds	r19, 0x0ECC
    268a:	21 15       	cp	r18, r1
    268c:	31 05       	cpc	r19, r1
    268e:	51 f0       	breq	.+20     	; 0x26a4 <__stack+0x5a5>
    2690:	89 8d       	ldd	r24, Y+25	; 0x19
    2692:	84 fd       	sbrc	r24, 4
    2694:	07 c0       	rjmp	.+14     	; 0x26a4 <__stack+0x5a5>
      uip_flags |= UIP_NEWDATA;
    2696:	80 91 d3 0e 	lds	r24, 0x0ED3
    269a:	82 60       	ori	r24, 0x02	; 2
    269c:	80 93 d3 0e 	sts	0x0ED3, r24
      uip_add_rcv_nxt(uip_len);
    26a0:	c9 01       	movw	r24, r18
    26a2:	45 da       	rcall	.-2934   	; 0x1b2e <uip_add_rcv_nxt>
       the initial MSS so that the application will send an entire MSS
       of data. This data will not be acknowledged by the receiver,
       and the application will retransmit it. This is called the
       "persistent timer" and uses the retransmission mechanim.
    */
    tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
    26a4:	90 91 28 0f 	lds	r25, 0x0F28
    26a8:	80 e0       	ldi	r24, 0x00	; 0
    26aa:	20 91 29 0f 	lds	r18, 0x0F29
    26ae:	82 0f       	add	r24, r18
    26b0:	91 1d       	adc	r25, r1
    26b2:	90 93 95 0a 	sts	0x0A95, r25
    26b6:	80 93 94 0a 	sts	0x0A94, r24
    if(tmp16 > uip_connr->initialmss ||
    26ba:	2c 89       	ldd	r18, Y+20	; 0x14
    26bc:	3d 89       	ldd	r19, Y+21	; 0x15
    26be:	28 17       	cp	r18, r24
    26c0:	39 07       	cpc	r19, r25
    26c2:	10 f0       	brcs	.+4      	; 0x26c8 <__stack+0x5c9>
    26c4:	89 2b       	or	r24, r25
    26c6:	21 f4       	brne	.+8      	; 0x26d0 <__stack+0x5d1>
       tmp16 == 0) {
      tmp16 = uip_connr->initialmss;
    26c8:	30 93 95 0a 	sts	0x0A95, r19
    26cc:	20 93 94 0a 	sts	0x0A94, r18
    }
    uip_connr->mss = tmp16;
    26d0:	80 91 94 0a 	lds	r24, 0x0A94
    26d4:	90 91 95 0a 	lds	r25, 0x0A95
    26d8:	9b 8b       	std	Y+19, r25	; 0x13
    26da:	8a 8b       	std	Y+18, r24	; 0x12

       If the application wishes to send any data, this data should be
       put into the uip_appdata and the length of the data should be
       put into uip_len. If the application don't have any data to
       send, uip_len must be set to 0. */
    if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
    26dc:	80 91 d3 0e 	lds	r24, 0x0ED3
    26e0:	90 e0       	ldi	r25, 0x00	; 0
    26e2:	83 70       	andi	r24, 0x03	; 3
    26e4:	90 70       	andi	r25, 0x00	; 0
    26e6:	89 2b       	or	r24, r25
    26e8:	09 f4       	brne	.+2      	; 0x26ec <__stack+0x5ed>
    26ea:	55 c1       	rjmp	.+682    	; 0x2996 <__stack+0x897>
      uip_slen = 0;
    26ec:	10 92 61 11 	sts	0x1161, r1
    26f0:	10 92 60 11 	sts	0x1160, r1
      UIP_APPCALL();
    26f4:	0e 94 8a 03 	call	0x714	; 0x714 <TCPCallback>

    appsend:
      
      if(uip_flags & UIP_ABORT) {
    26f8:	80 91 d3 0e 	lds	r24, 0x0ED3
    26fc:	28 2f       	mov	r18, r24
    26fe:	85 ff       	sbrs	r24, 5
    2700:	07 c0       	rjmp	.+14     	; 0x2710 <__stack+0x611>
	uip_slen = 0;
    2702:	10 92 61 11 	sts	0x1161, r1
    2706:	10 92 60 11 	sts	0x1160, r1
	uip_connr->tcpstateflags = UIP_CLOSED;
    270a:	19 8e       	std	Y+25, r1	; 0x19
	BUF->flags = TCP_RST | TCP_ACK;
    270c:	84 e1       	ldi	r24, 0x14	; 20
    270e:	93 cf       	rjmp	.-218    	; 0x2636 <__stack+0x537>
	goto tcp_send_nodata;
      }

      if(uip_flags & UIP_CLOSE) {
    2710:	84 ff       	sbrs	r24, 4
    2712:	0a c0       	rjmp	.+20     	; 0x2728 <__stack+0x629>
	uip_slen = 0;
    2714:	10 92 61 11 	sts	0x1161, r1
    2718:	10 92 60 11 	sts	0x1160, r1
	uip_connr->len = 1;
    271c:	81 e0       	ldi	r24, 0x01	; 1
    271e:	90 e0       	ldi	r25, 0x00	; 0
    2720:	99 8b       	std	Y+17, r25	; 0x11
    2722:	88 8b       	std	Y+16, r24	; 0x10
	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
    2724:	84 e0       	ldi	r24, 0x04	; 4
    2726:	84 cf       	rjmp	.-248    	; 0x2630 <__stack+0x531>
	BUF->flags = TCP_FIN | TCP_ACK;
	goto tcp_send_nodata;
      }

      /* If uip_slen > 0, the application has data to be sent. */
      if(uip_slen > 0) {
    2728:	80 91 60 11 	lds	r24, 0x1160
    272c:	90 91 61 11 	lds	r25, 0x1161
    2730:	89 2b       	or	r24, r25
    2732:	01 f1       	breq	.+64     	; 0x2774 <__stack+0x675>

	/* If the connection has acknowledged data, the contents of
	   the ->len variable should be discarded. */
	if((uip_flags & UIP_ACKDATA) != 0) {
    2734:	20 ff       	sbrs	r18, 0
    2736:	02 c0       	rjmp	.+4      	; 0x273c <__stack+0x63d>
	  uip_connr->len = 0;
    2738:	19 8a       	std	Y+17, r1	; 0x11
    273a:	18 8a       	std	Y+16, r1	; 0x10
	}

	/* If the ->len variable is non-zero the connection has
	   already data in transit and cannot send anymore right
	   now. */
	if(uip_connr->len == 0) {
    273c:	88 89       	ldd	r24, Y+16	; 0x10
    273e:	99 89       	ldd	r25, Y+17	; 0x11
    2740:	00 97       	sbiw	r24, 0x00	; 0
    2742:	a1 f4       	brne	.+40     	; 0x276c <__stack+0x66d>

	  /* The application cannot send more than what is allowed by
	     the mss (the minumum of the MSS and the available
	     window). */
	  if(uip_slen > uip_connr->mss) {
    2744:	2a 89       	ldd	r18, Y+18	; 0x12
    2746:	3b 89       	ldd	r19, Y+19	; 0x13
    2748:	80 91 60 11 	lds	r24, 0x1160
    274c:	90 91 61 11 	lds	r25, 0x1161
    2750:	28 17       	cp	r18, r24
    2752:	39 07       	cpc	r19, r25
    2754:	20 f4       	brcc	.+8      	; 0x275e <__stack+0x65f>
	    uip_slen = uip_connr->mss;
    2756:	30 93 61 11 	sts	0x1161, r19
    275a:	20 93 60 11 	sts	0x1160, r18
	  }

	  /* Remember how much data we send out now so that we know
	     when everything has been acknowledged. */
	  uip_connr->len = uip_slen;
    275e:	80 91 60 11 	lds	r24, 0x1160
    2762:	90 91 61 11 	lds	r25, 0x1161
    2766:	99 8b       	std	Y+17, r25	; 0x11
    2768:	88 8b       	std	Y+16, r24	; 0x10
    276a:	04 c0       	rjmp	.+8      	; 0x2774 <__stack+0x675>
	} else {

	  /* If the application already had unacknowledged data, we
	     make sure that the application does not send (i.e.,
	     retransmit) out more than it previously sent out. */
	  uip_slen = uip_connr->len;
    276c:	90 93 61 11 	sts	0x1161, r25
    2770:	80 93 60 11 	sts	0x1160, r24
	}
      }
      uip_connr->nrtx = 0;
    2774:	1b 8e       	std	Y+27, r1	; 0x1b
    apprexmit:
      uip_appdata = uip_sappdata;
    2776:	80 91 cd 0e 	lds	r24, 0x0ECD
    277a:	90 91 ce 0e 	lds	r25, 0x0ECE
    277e:	90 93 d7 0e 	sts	0x0ED7, r25
    2782:	80 93 d6 0e 	sts	0x0ED6, r24
      
      /* If the application has data to be sent, or if the incoming
         packet had new data in it, we must send out a packet. */
      if(uip_slen > 0 && uip_connr->len > 0) {
    2786:	80 91 60 11 	lds	r24, 0x1160
    278a:	90 91 61 11 	lds	r25, 0x1161
    278e:	89 2b       	or	r24, r25
    2790:	59 f0       	breq	.+22     	; 0x27a8 <__stack+0x6a9>
    2792:	88 89       	ldd	r24, Y+16	; 0x10
    2794:	99 89       	ldd	r25, Y+17	; 0x11
    2796:	00 97       	sbiw	r24, 0x00	; 0
    2798:	39 f0       	breq	.+14     	; 0x27a8 <__stack+0x6a9>
	/* Add the length of the IP and TCP headers. */
	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
    279a:	88 96       	adiw	r24, 0x28	; 40
    279c:	90 93 cc 0e 	sts	0x0ECC, r25
    27a0:	80 93 cb 0e 	sts	0x0ECB, r24
	/* We always set the ACK flag in response packets. */
	BUF->flags = TCP_ACK | TCP_PSH;
    27a4:	88 e1       	ldi	r24, 0x18	; 24
    27a6:	0b c0       	rjmp	.+22     	; 0x27be <__stack+0x6bf>
	/* Send the packet. */
	goto tcp_send_noopts;
      }
      /* If there is no data to send, just send out a pure ACK if
	 there is newdata. */
      if(uip_flags & UIP_NEWDATA) {
    27a8:	80 91 d3 0e 	lds	r24, 0x0ED3
    27ac:	81 ff       	sbrs	r24, 1
    27ae:	f3 c0       	rjmp	.+486    	; 0x2996 <__stack+0x897>
	uip_len = UIP_TCPIP_HLEN;
    27b0:	88 e2       	ldi	r24, 0x28	; 40
    27b2:	90 e0       	ldi	r25, 0x00	; 0
    27b4:	90 93 cc 0e 	sts	0x0ECC, r25
    27b8:	80 93 cb 0e 	sts	0x0ECB, r24
	BUF->flags = TCP_ACK;
    27bc:	80 e1       	ldi	r24, 0x10	; 16
    27be:	80 93 27 0f 	sts	0x0F27, r24
    27c2:	59 c0       	rjmp	.+178    	; 0x2876 <__stack+0x777>
    }
    goto drop;
  case UIP_LAST_ACK:
    /* We can close this connection if the peer has acknowledged our
       FIN. This is indicated by the UIP_ACKDATA flag. */
    if(uip_flags & UIP_ACKDATA) {
    27c4:	80 91 d3 0e 	lds	r24, 0x0ED3
    27c8:	80 ff       	sbrs	r24, 0
    27ca:	e5 c0       	rjmp	.+458    	; 0x2996 <__stack+0x897>
      uip_connr->tcpstateflags = UIP_CLOSED;
    27cc:	19 8e       	std	Y+25, r1	; 0x19
      uip_flags = UIP_CLOSE;
    27ce:	80 e1       	ldi	r24, 0x10	; 16
    27d0:	80 93 d3 0e 	sts	0x0ED3, r24
      UIP_APPCALL();
    27d4:	0e 94 8a 03 	call	0x714	; 0x714 <TCPCallback>
    27d8:	de c0       	rjmp	.+444    	; 0x2996 <__stack+0x897>
    
  case UIP_FIN_WAIT_1:
    /* The application has closed the connection, but the remote host
       hasn't closed its end yet. Thus we do nothing but wait for a
       FIN from the other side. */
    if(uip_len > 0) {
    27da:	80 91 cb 0e 	lds	r24, 0x0ECB
    27de:	90 91 cc 0e 	lds	r25, 0x0ECC
    27e2:	00 97       	sbiw	r24, 0x00	; 0
    27e4:	09 f0       	breq	.+2      	; 0x27e8 <__stack+0x6e9>
      uip_add_rcv_nxt(uip_len);
    27e6:	a3 d9       	rcall	.-3258   	; 0x1b2e <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
    27e8:	80 91 27 0f 	lds	r24, 0x0F27
    27ec:	90 91 d3 0e 	lds	r25, 0x0ED3
    27f0:	80 ff       	sbrs	r24, 0
    27f2:	0b c0       	rjmp	.+22     	; 0x280a <__stack+0x70b>
      if(uip_flags & UIP_ACKDATA) {
    27f4:	90 ff       	sbrs	r25, 0
    27f6:	06 c0       	rjmp	.+12     	; 0x2804 <__stack+0x705>
	uip_connr->tcpstateflags = UIP_TIME_WAIT;
    27f8:	87 e0       	ldi	r24, 0x07	; 7
    27fa:	89 8f       	std	Y+25, r24	; 0x19
	uip_connr->timer = 0;
    27fc:	1a 8e       	std	Y+26, r1	; 0x1a
	uip_connr->len = 0;
    27fe:	19 8a       	std	Y+17, r1	; 0x11
    2800:	18 8a       	std	Y+16, r1	; 0x10
    2802:	18 c0       	rjmp	.+48     	; 0x2834 <__stack+0x735>
      } else {
	uip_connr->tcpstateflags = UIP_CLOSING;
    2804:	86 e0       	ldi	r24, 0x06	; 6
    2806:	89 8f       	std	Y+25, r24	; 0x19
    2808:	15 c0       	rjmp	.+42     	; 0x2834 <__stack+0x735>
      }
      uip_add_rcv_nxt(1);
      uip_flags = UIP_CLOSE;
      UIP_APPCALL();
      goto tcp_send_ack;
    } else if(uip_flags & UIP_ACKDATA) {
    280a:	90 ff       	sbrs	r25, 0
    280c:	1c c0       	rjmp	.+56     	; 0x2846 <__stack+0x747>
      uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
    280e:	85 e0       	ldi	r24, 0x05	; 5
    2810:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->len = 0;
    2812:	19 8a       	std	Y+17, r1	; 0x11
    2814:	18 8a       	std	Y+16, r1	; 0x10
    2816:	bf c0       	rjmp	.+382    	; 0x2996 <__stack+0x897>
      goto tcp_send_ack;
    }
    goto drop;
      
  case UIP_FIN_WAIT_2:
    if(uip_len > 0) {
    2818:	80 91 cb 0e 	lds	r24, 0x0ECB
    281c:	90 91 cc 0e 	lds	r25, 0x0ECC
    2820:	00 97       	sbiw	r24, 0x00	; 0
    2822:	09 f0       	breq	.+2      	; 0x2826 <__stack+0x727>
      uip_add_rcv_nxt(uip_len);
    2824:	84 d9       	rcall	.-3320   	; 0x1b2e <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
    2826:	80 91 27 0f 	lds	r24, 0x0F27
    282a:	80 ff       	sbrs	r24, 0
    282c:	0c c0       	rjmp	.+24     	; 0x2846 <__stack+0x747>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    282e:	87 e0       	ldi	r24, 0x07	; 7
    2830:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->timer = 0;
    2832:	1a 8e       	std	Y+26, r1	; 0x1a
      uip_add_rcv_nxt(1);
    2834:	81 e0       	ldi	r24, 0x01	; 1
    2836:	90 e0       	ldi	r25, 0x00	; 0
    2838:	7a d9       	rcall	.-3340   	; 0x1b2e <uip_add_rcv_nxt>
      uip_flags = UIP_CLOSE;
    283a:	80 e1       	ldi	r24, 0x10	; 16
    283c:	80 93 d3 0e 	sts	0x0ED3, r24
      UIP_APPCALL();
    2840:	0e 94 8a 03 	call	0x714	; 0x714 <TCPCallback>
    2844:	0f c0       	rjmp	.+30     	; 0x2864 <__stack+0x765>
      goto tcp_send_ack;
    }
    if(uip_len > 0) {
    2846:	80 91 cb 0e 	lds	r24, 0x0ECB
    284a:	90 91 cc 0e 	lds	r25, 0x0ECC
    284e:	89 2b       	or	r24, r25
    2850:	49 f4       	brne	.+18     	; 0x2864 <__stack+0x765>
    2852:	a1 c0       	rjmp	.+322    	; 0x2996 <__stack+0x897>

  case UIP_TIME_WAIT:
    goto tcp_send_ack;
    
  case UIP_CLOSING:
    if(uip_flags & UIP_ACKDATA) {
    2854:	80 91 d3 0e 	lds	r24, 0x0ED3
    2858:	80 ff       	sbrs	r24, 0
    285a:	9d c0       	rjmp	.+314    	; 0x2996 <__stack+0x897>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    285c:	87 e0       	ldi	r24, 0x07	; 7
    285e:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->timer = 0;
    2860:	1a 8e       	std	Y+26, r1	; 0x1a
    2862:	99 c0       	rjmp	.+306    	; 0x2996 <__stack+0x897>
  

  /* We jump here when we are ready to send the packet, and just want
     to set the appropriate TCP sequence numbers in the TCP header. */
 tcp_send_ack:
  BUF->flags = TCP_ACK;
    2864:	80 e1       	ldi	r24, 0x10	; 16
    2866:	f8 01       	movw	r30, r16
    2868:	81 a3       	std	Z+33, r24	; 0x21
 tcp_send_nodata:
  uip_len = UIP_IPTCPH_LEN;
    286a:	88 e2       	ldi	r24, 0x28	; 40
    286c:	90 e0       	ldi	r25, 0x00	; 0
    286e:	90 93 cc 0e 	sts	0x0ECC, r25
    2872:	80 93 cb 0e 	sts	0x0ECB, r24
 tcp_send_noopts:
  BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
    2876:	80 e5       	ldi	r24, 0x50	; 80
    2878:	80 93 26 0f 	sts	0x0F26, r24
 tcp_send:
  /* We're done with the input processing. We are now ready to send a
     reply. Our job is to fill in all the fields of the TCP and IP
     headers before calculating the checksum and finally send the
     packet. */
  BUF->ackno[0] = uip_connr->rcv_nxt[0];
    287c:	88 85       	ldd	r24, Y+8	; 0x08
    287e:	80 93 22 0f 	sts	0x0F22, r24
  BUF->ackno[1] = uip_connr->rcv_nxt[1];
    2882:	89 85       	ldd	r24, Y+9	; 0x09
    2884:	80 93 23 0f 	sts	0x0F23, r24
  BUF->ackno[2] = uip_connr->rcv_nxt[2];
    2888:	8a 85       	ldd	r24, Y+10	; 0x0a
    288a:	80 93 24 0f 	sts	0x0F24, r24
  BUF->ackno[3] = uip_connr->rcv_nxt[3];
    288e:	8b 85       	ldd	r24, Y+11	; 0x0b
    2890:	80 93 25 0f 	sts	0x0F25, r24
  
  BUF->seqno[0] = uip_connr->snd_nxt[0];
    2894:	8c 85       	ldd	r24, Y+12	; 0x0c
    2896:	80 93 1e 0f 	sts	0x0F1E, r24
  BUF->seqno[1] = uip_connr->snd_nxt[1];
    289a:	8d 85       	ldd	r24, Y+13	; 0x0d
    289c:	80 93 1f 0f 	sts	0x0F1F, r24
  BUF->seqno[2] = uip_connr->snd_nxt[2];
    28a0:	8e 85       	ldd	r24, Y+14	; 0x0e
    28a2:	80 93 20 0f 	sts	0x0F20, r24
  BUF->seqno[3] = uip_connr->snd_nxt[3];
    28a6:	8f 85       	ldd	r24, Y+15	; 0x0f
    28a8:	80 93 21 0f 	sts	0x0F21, r24

  BUF->proto = UIP_PROTO_TCP;
    28ac:	86 e0       	ldi	r24, 0x06	; 6
    28ae:	80 93 0f 0f 	sts	0x0F0F, r24
  
  BUF->srcport  = uip_connr->lport;
    28b2:	8c 81       	ldd	r24, Y+4	; 0x04
    28b4:	9d 81       	ldd	r25, Y+5	; 0x05
    28b6:	90 93 1b 0f 	sts	0x0F1B, r25
    28ba:	80 93 1a 0f 	sts	0x0F1A, r24
  BUF->destport = uip_connr->rport;
    28be:	8e 81       	ldd	r24, Y+6	; 0x06
    28c0:	9f 81       	ldd	r25, Y+7	; 0x07
    28c2:	90 93 1d 0f 	sts	0x0F1D, r25
    28c6:	80 93 1c 0f 	sts	0x0F1C, r24

  uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
    28ca:	80 91 02 0f 	lds	r24, 0x0F02
    28ce:	90 91 03 0f 	lds	r25, 0x0F03
    28d2:	90 93 13 0f 	sts	0x0F13, r25
    28d6:	80 93 12 0f 	sts	0x0F12, r24
    28da:	80 91 04 0f 	lds	r24, 0x0F04
    28de:	90 91 05 0f 	lds	r25, 0x0F05
    28e2:	90 93 15 0f 	sts	0x0F15, r25
    28e6:	80 93 14 0f 	sts	0x0F14, r24
  uip_ipaddr_copy(BUF->destipaddr, uip_connr->ripaddr);
    28ea:	88 81       	ld	r24, Y
    28ec:	99 81       	ldd	r25, Y+1	; 0x01
    28ee:	90 93 17 0f 	sts	0x0F17, r25
    28f2:	80 93 16 0f 	sts	0x0F16, r24
    28f6:	8a 81       	ldd	r24, Y+2	; 0x02
    28f8:	9b 81       	ldd	r25, Y+3	; 0x03
    28fa:	90 93 19 0f 	sts	0x0F19, r25
    28fe:	80 93 18 0f 	sts	0x0F18, r24

  if(uip_connr->tcpstateflags & UIP_STOPPED) {
    2902:	89 8d       	ldd	r24, Y+25	; 0x19
    2904:	84 ff       	sbrs	r24, 4
    2906:	05 c0       	rjmp	.+10     	; 0x2912 <__stack+0x813>
    /* If the connection has issued uip_stop(), we advertise a zero
       window so that the remote host will stop sending data. */
    BUF->wnd[0] = BUF->wnd[1] = 0;
    2908:	10 92 29 0f 	sts	0x0F29, r1
    290c:	10 92 28 0f 	sts	0x0F28, r1
    2910:	06 c0       	rjmp	.+12     	; 0x291e <__stack+0x81f>
  } else {
    BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
    2912:	82 e0       	ldi	r24, 0x02	; 2
    2914:	80 93 28 0f 	sts	0x0F28, r24
    BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
    2918:	80 e3       	ldi	r24, 0x30	; 48
    291a:	80 93 29 0f 	sts	0x0F29, r24
  }

 tcp_send_noconn:
  BUF->ttl = UIP_TTL;
    291e:	80 e4       	ldi	r24, 0x40	; 64
    2920:	80 93 0e 0f 	sts	0x0F0E, r24
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
    2924:	80 91 cc 0e 	lds	r24, 0x0ECC
    2928:	80 93 08 0f 	sts	0x0F08, r24
  BUF->len[1] = (uip_len & 0xff);
    292c:	80 91 cb 0e 	lds	r24, 0x0ECB
    2930:	80 93 09 0f 	sts	0x0F09, r24
#endif /* UIP_CONF_IPV6 */

  BUF->urgp[0] = BUF->urgp[1] = 0;
    2934:	10 92 2d 0f 	sts	0x0F2D, r1
    2938:	10 92 2c 0f 	sts	0x0F2C, r1
  
  /* Calculate TCP checksum. */
  BUF->tcpchksum = 0;
    293c:	10 92 2b 0f 	sts	0x0F2B, r1
    2940:	10 92 2a 0f 	sts	0x0F2A, r1
  BUF->tcpchksum = ~(uip_tcpchksum());
    2944:	5c d8       	rcall	.-3912   	; 0x19fe <uip_tcpchksum>
    2946:	80 95       	com	r24
    2948:	90 95       	com	r25
    294a:	90 93 2b 0f 	sts	0x0F2B, r25
    294e:	80 93 2a 0f 	sts	0x0F2A, r24
#if UIP_CONF_IPV6
  BUF->vtc = 0x60;
  BUF->tcflow = 0x00;
  BUF->flow = 0x00;
#else /* UIP_CONF_IPV6 */
  BUF->vhl = 0x45;
    2952:	85 e4       	ldi	r24, 0x45	; 69
    2954:	80 93 06 0f 	sts	0x0F06, r24
  BUF->tos = 0;
    2958:	10 92 07 0f 	sts	0x0F07, r1
  BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
    295c:	10 92 0d 0f 	sts	0x0F0D, r1
    2960:	10 92 0c 0f 	sts	0x0F0C, r1
  ++ipid;
    2964:	80 91 8a 0a 	lds	r24, 0x0A8A
    2968:	90 91 8b 0a 	lds	r25, 0x0A8B
    296c:	01 96       	adiw	r24, 0x01	; 1
    296e:	90 93 8b 0a 	sts	0x0A8B, r25
    2972:	80 93 8a 0a 	sts	0x0A8A, r24
  BUF->ipid[0] = ipid >> 8;
    2976:	90 93 0a 0f 	sts	0x0F0A, r25
  BUF->ipid[1] = ipid & 0xff;
    297a:	80 93 0b 0f 	sts	0x0F0B, r24
  /* Calculate IP checksum. */
  BUF->ipchksum = 0;
    297e:	10 92 11 0f 	sts	0x0F11, r1
    2982:	10 92 10 0f 	sts	0x0F10, r1
  BUF->ipchksum = ~(uip_ipchksum());
    2986:	2b d8       	rcall	.-4010   	; 0x19de <uip_ipchksum>
    2988:	80 95       	com	r24
    298a:	90 95       	com	r25
    298c:	90 93 11 0f 	sts	0x0F11, r25
    2990:	80 93 10 0f 	sts	0x0F10, r24
    2994:	04 c0       	rjmp	.+8      	; 0x299e <__stack+0x89f>
  UIP_STAT(++uip_stat.ip.sent);
  /* Return and let the caller do the actual transmission. */
  uip_flags = 0;
  return;
 drop:
  uip_len = 0;
    2996:	10 92 cc 0e 	sts	0x0ECC, r1
    299a:	10 92 cb 0e 	sts	0x0ECB, r1
  uip_flags = 0;
    299e:	10 92 d3 0e 	sts	0x0ED3, r1
  return;
}
    29a2:	df 91       	pop	r29
    29a4:	cf 91       	pop	r28
    29a6:	1f 91       	pop	r17
    29a8:	0f 91       	pop	r16
    29aa:	08 95       	ret

000029ac <__vector_23>:
//Counted time
volatile clock_time_t clock_datetime = 0;

//Overflow interrupt
ISR(TIMER0_OVF_vect)
{
    29ac:	1f 92       	push	r1
    29ae:	0f 92       	push	r0
    29b0:	0f b6       	in	r0, 0x3f	; 63
    29b2:	0f 92       	push	r0
    29b4:	11 24       	eor	r1, r1
    29b6:	8f 93       	push	r24
    29b8:	9f 93       	push	r25
	clock_datetime += 1;
    29ba:	80 91 96 0a 	lds	r24, 0x0A96
    29be:	90 91 97 0a 	lds	r25, 0x0A97
    29c2:	01 96       	adiw	r24, 0x01	; 1
    29c4:	90 93 97 0a 	sts	0x0A97, r25
    29c8:	80 93 96 0a 	sts	0x0A96, r24
}
    29cc:	9f 91       	pop	r25
    29ce:	8f 91       	pop	r24
    29d0:	0f 90       	pop	r0
    29d2:	0f be       	out	0x3f, r0	; 63
    29d4:	0f 90       	pop	r0
    29d6:	1f 90       	pop	r1
    29d8:	18 95       	reti

000029da <clock_init>:

//Initialise the clock
void clock_init()
{
	//Activate overflow interrupt for timer0
	TIMSK0 |= (1<<TOIE0);
    29da:	ee e6       	ldi	r30, 0x6E	; 110
    29dc:	f0 e0       	ldi	r31, 0x00	; 0
    29de:	80 81       	ld	r24, Z
    29e0:	81 60       	ori	r24, 0x01	; 1
    29e2:	80 83       	st	Z, r24

	//Use prescaler 1024
	TCCR0B |= ((1<<CS12)|(1<<CS10));
    29e4:	85 b5       	in	r24, 0x25	; 37
    29e6:	85 60       	ori	r24, 0x05	; 5
    29e8:	85 bd       	out	0x25, r24	; 37

	//Activate interrupts
	sei();
    29ea:	78 94       	sei
}
    29ec:	08 95       	ret

000029ee <clock_time>:
//Return time
clock_time_t clock_time()
{
	clock_time_t time;

	cli();
    29ee:	f8 94       	cli
		time = clock_datetime;
    29f0:	20 91 96 0a 	lds	r18, 0x0A96
    29f4:	30 91 97 0a 	lds	r19, 0x0A97
	sei();
    29f8:	78 94       	sei

	return time;
}
    29fa:	c9 01       	movw	r24, r18
    29fc:	08 95       	ret

000029fe <network_init>:
}

void network_init(void)
{
	//Initialise the device
	InPacket = InHeader = Escape = len = 0;	
    29fe:	10 92 9c 0a 	sts	0x0A9C, r1
    2a02:	10 92 9b 0a 	sts	0x0A9B, r1
    2a06:	10 92 9a 0a 	sts	0x0A9A, r1
    2a0a:	10 92 98 0a 	sts	0x0A98, r1
    2a0e:	10 92 99 0a 	sts	0x0A99, r1
}
    2a12:	08 95       	ret

00002a14 <network_send>:

	return 0;	// Packet not finished yet if we got here.
}

void network_send(void)
{
    2a14:	af 92       	push	r10
    2a16:	bf 92       	push	r11
    2a18:	cf 92       	push	r12
    2a1a:	df 92       	push	r13
    2a1c:	ef 92       	push	r14
    2a1e:	ff 92       	push	r15
    2a20:	0f 93       	push	r16
    2a22:	1f 93       	push	r17
    2a24:	cf 93       	push	r28
    2a26:	df 93       	push	r29
	unsigned int checksum = 0xffff;
	int i, j;

	InPacket = 0; InHeader = 0;
    2a28:	10 92 99 0a 	sts	0x0A99, r1
    2a2c:	10 92 98 0a 	sts	0x0A98, r1
	

	/********************** Debug **********************/
	Debug("\r\nSend:\r\n");
    2a30:	87 e4       	ldi	r24, 0x47	; 71
    2a32:	96 e0       	ldi	r25, 0x06	; 6
    2a34:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
    2a38:	96 e0       	ldi	r25, 0x06	; 6
    2a3a:	a9 2e       	mov	r10, r25
    2a3c:	9f e0       	ldi	r25, 0x0F	; 15
    2a3e:	b9 2e       	mov	r11, r25
    2a40:	65 01       	movw	r12, r10
    2a42:	ee 24       	eor	r14, r14
    2a44:	ff 24       	eor	r15, r15
    2a46:	4b c0       	rjmp	.+150    	; 0x2ade <network_send+0xca>
	
	for (i = 0; i < uip_len; i += 16)
    2a48:	86 01       	movw	r16, r12
    2a4a:	c0 e0       	ldi	r28, 0x00	; 0
    2a4c:	d0 e0       	ldi	r29, 0x00	; 0
	{	
		for (j = 0; j < 16; j++)
		{
			if ((i + j) >= uip_len)
    2a4e:	9e 01       	movw	r18, r28
    2a50:	2e 0d       	add	r18, r14
    2a52:	3f 1d       	adc	r19, r15
    2a54:	80 91 cb 0e 	lds	r24, 0x0ECB
    2a58:	90 91 cc 0e 	lds	r25, 0x0ECC
    2a5c:	28 17       	cp	r18, r24
    2a5e:	39 07       	cpc	r19, r25
    2a60:	48 f4       	brcc	.+18     	; 0x2a74 <network_send+0x60>
				break;

			PrintHex(*(uip_buf + i + j));
    2a62:	f8 01       	movw	r30, r16
    2a64:	81 91       	ld	r24, Z+
    2a66:	8f 01       	movw	r16, r30
    2a68:	0e 94 09 01 	call	0x212	; 0x212 <PrintHex>
	/********************** Debug **********************/
	Debug("\r\nSend:\r\n");
	
	for (i = 0; i < uip_len; i += 16)
	{	
		for (j = 0; j < 16; j++)
    2a6c:	21 96       	adiw	r28, 0x01	; 1
    2a6e:	c0 31       	cpi	r28, 0x10	; 16
    2a70:	d1 05       	cpc	r29, r1
    2a72:	69 f7       	brne	.-38     	; 0x2a4e <network_send+0x3a>

			PrintHex(*(uip_buf + i + j));

		}
		
		Debug("\r\n");	
    2a74:	81 e5       	ldi	r24, 0x51	; 81
    2a76:	96 e0       	ldi	r25, 0x06	; 6
    2a78:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
    2a7c:	86 01       	movw	r16, r12
    2a7e:	c0 e0       	ldi	r28, 0x00	; 0
    2a80:	d0 e0       	ldi	r29, 0x00	; 0
		
		for (j = 0; j < 16; j++)
		{
			if ((i + j) >= uip_len)
    2a82:	9e 01       	movw	r18, r28
    2a84:	2e 0d       	add	r18, r14
    2a86:	3f 1d       	adc	r19, r15
    2a88:	80 91 cb 0e 	lds	r24, 0x0ECB
    2a8c:	90 91 cc 0e 	lds	r25, 0x0ECC
    2a90:	28 17       	cp	r18, r24
    2a92:	39 07       	cpc	r19, r25
    2a94:	d0 f4       	brcc	.+52     	; 0x2aca <network_send+0xb6>
				break;

			if (*(uip_buf + i + j) >= 0x20 && *(uip_buf + i + j) <= 0x7e)
    2a96:	f8 01       	movw	r30, r16
    2a98:	80 81       	ld	r24, Z
    2a9a:	80 52       	subi	r24, 0x20	; 32
    2a9c:	8f 35       	cpi	r24, 0x5F	; 95
    2a9e:	58 f4       	brcc	.+22     	; 0x2ab6 <network_send+0xa2>
			{
				DebugChar(' ');
    2aa0:	80 e2       	ldi	r24, 0x20	; 32
    2aa2:	0e 94 01 01 	call	0x202	; 0x202 <DebugChar>
				DebugChar(*(uip_buf + i + j));
    2aa6:	f8 01       	movw	r30, r16
    2aa8:	80 81       	ld	r24, Z
    2aaa:	0e 94 01 01 	call	0x202	; 0x202 <DebugChar>
				DebugChar(' ');
    2aae:	80 e2       	ldi	r24, 0x20	; 32
    2ab0:	0e 94 01 01 	call	0x202	; 0x202 <DebugChar>
    2ab4:	04 c0       	rjmp	.+8      	; 0x2abe <network_send+0xaa>
			}
			else
				Debug(" . ");
    2ab6:	84 e5       	ldi	r24, 0x54	; 84
    2ab8:	96 e0       	ldi	r25, 0x06	; 6
    2aba:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>

		}
		
		Debug("\r\n");	
		
		for (j = 0; j < 16; j++)
    2abe:	21 96       	adiw	r28, 0x01	; 1
    2ac0:	0f 5f       	subi	r16, 0xFF	; 255
    2ac2:	1f 4f       	sbci	r17, 0xFF	; 255
    2ac4:	c0 31       	cpi	r28, 0x10	; 16
    2ac6:	d1 05       	cpc	r29, r1
    2ac8:	e1 f6       	brne	.-72     	; 0x2a82 <network_send+0x6e>
			}
			else
				Debug(" . ");

		}
		Debug("\r\n");
    2aca:	81 e5       	ldi	r24, 0x51	; 81
    2acc:	96 e0       	ldi	r25, 0x06	; 6
    2ace:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
	

	/********************** Debug **********************/
	Debug("\r\nSend:\r\n");
	
	for (i = 0; i < uip_len; i += 16)
    2ad2:	80 e1       	ldi	r24, 0x10	; 16
    2ad4:	90 e0       	ldi	r25, 0x00	; 0
    2ad6:	e8 0e       	add	r14, r24
    2ad8:	f9 1e       	adc	r15, r25
    2ada:	c8 0e       	add	r12, r24
    2adc:	d9 1e       	adc	r13, r25
    2ade:	80 91 cb 0e 	lds	r24, 0x0ECB
    2ae2:	90 91 cc 0e 	lds	r25, 0x0ECC
    2ae6:	e8 16       	cp	r14, r24
    2ae8:	f9 06       	cpc	r15, r25
    2aea:	08 f4       	brcc	.+2      	; 0x2aee <network_send+0xda>
    2aec:	ad cf       	rjmp	.-166    	; 0x2a48 <network_send+0x34>

	// Send out the packet with HDLC-like framing
	// See http://tools.ietf.org/html/rfc1662
	
	// Start with the framing
	modem_putc(0x7e);
    2aee:	8e e7       	ldi	r24, 0x7E	; 126
    2af0:	0e 94 90 07 	call	0xf20	; 0xf20 <modem_putc>

	// Header	
	modem_putc(0xff);
    2af4:	8f ef       	ldi	r24, 0xFF	; 255
    2af6:	0e 94 90 07 	call	0xf20	; 0xf20 <modem_putc>
	checksum = CRC(checksum, 0xff);
    2afa:	8f ef       	ldi	r24, 0xFF	; 255
    2afc:	9f ef       	ldi	r25, 0xFF	; 255
    2afe:	6f ef       	ldi	r22, 0xFF	; 255
    2b00:	0e 94 36 09 	call	0x126c	; 0x126c <CRC>
    2b04:	8c 01       	movw	r16, r24

	modem_putc(0x03);
    2b06:	83 e0       	ldi	r24, 0x03	; 3
    2b08:	0e 94 90 07 	call	0xf20	; 0xf20 <modem_putc>
	checksum = CRC(checksum, 0x03);
    2b0c:	c8 01       	movw	r24, r16
    2b0e:	63 e0       	ldi	r22, 0x03	; 3
    2b10:	0e 94 36 09 	call	0x126c	; 0x126c <CRC>
    2b14:	8c 01       	movw	r16, r24

	modem_putc(0x00);
    2b16:	80 e0       	ldi	r24, 0x00	; 0
    2b18:	0e 94 90 07 	call	0xf20	; 0xf20 <modem_putc>
	checksum = CRC(checksum, 0x00);
    2b1c:	c8 01       	movw	r24, r16
    2b1e:	60 e0       	ldi	r22, 0x00	; 0
    2b20:	0e 94 36 09 	call	0x126c	; 0x126c <CRC>
    2b24:	8c 01       	movw	r16, r24

	modem_putc(0x21);
    2b26:	81 e2       	ldi	r24, 0x21	; 33
    2b28:	0e 94 90 07 	call	0xf20	; 0xf20 <modem_putc>
	checksum = CRC(checksum, 0x21);
    2b2c:	c8 01       	movw	r24, r16
    2b2e:	61 e2       	ldi	r22, 0x21	; 33
    2b30:	0e 94 36 09 	call	0x126c	; 0x126c <CRC>
    2b34:	8c 01       	movw	r16, r24
    2b36:	c0 e0       	ldi	r28, 0x00	; 0
    2b38:	d0 e0       	ldi	r29, 0x00	; 0
	for (int i = 0; i < uip_len; i++)
	{
			if (*(uip_buf + i) == 0x7d || *(uip_buf + i) == 0x7e)
			{
				modem_putc(0x7d);
				modem_putc(*(uip_buf + i) ^ 0x20);
    2b3a:	80 e2       	ldi	r24, 0x20	; 32
    2b3c:	f8 2e       	mov	r15, r24
    2b3e:	23 c0       	rjmp	.+70     	; 0x2b86 <network_send+0x172>
	checksum = CRC(checksum, 0x21);

	// Add the data, escaping it if necessary
	for (int i = 0; i < uip_len; i++)
	{
			if (*(uip_buf + i) == 0x7d || *(uip_buf + i) == 0x7e)
    2b40:	f5 01       	movw	r30, r10
    2b42:	90 81       	ld	r25, Z
    2b44:	89 2f       	mov	r24, r25
    2b46:	8d 57       	subi	r24, 0x7D	; 125
    2b48:	82 30       	cpi	r24, 0x02	; 2
    2b4a:	38 f4       	brcc	.+14     	; 0x2b5a <network_send+0x146>
			{
				modem_putc(0x7d);
    2b4c:	8d e7       	ldi	r24, 0x7D	; 125
    2b4e:	0e 94 90 07 	call	0xf20	; 0xf20 <modem_putc>
				modem_putc(*(uip_buf + i) ^ 0x20);
    2b52:	f5 01       	movw	r30, r10
    2b54:	80 81       	ld	r24, Z
    2b56:	8f 25       	eor	r24, r15
    2b58:	01 c0       	rjmp	.+2      	; 0x2b5c <network_send+0x148>
			}
			else
			{
				modem_putc(*(uip_buf + i));
    2b5a:	89 2f       	mov	r24, r25
    2b5c:	0e 94 90 07 	call	0xf20	; 0xf20 <modem_putc>
			}

			checksum = CRC(checksum, *(uip_buf + i));
    2b60:	c8 01       	movw	r24, r16
    2b62:	f5 01       	movw	r30, r10
    2b64:	60 81       	ld	r22, Z
    2b66:	0e 94 36 09 	call	0x126c	; 0x126c <CRC>
    2b6a:	8c 01       	movw	r16, r24
		
			if (i % 64 == 0 && i != 0)									// Periodically flush the buffer to the modem
    2b6c:	ce 01       	movw	r24, r28
    2b6e:	8f 73       	andi	r24, 0x3F	; 63
    2b70:	90 70       	andi	r25, 0x00	; 0
    2b72:	89 2b       	or	r24, r25
    2b74:	21 f4       	brne	.+8      	; 0x2b7e <network_send+0x16a>
    2b76:	20 97       	sbiw	r28, 0x00	; 0
    2b78:	11 f0       	breq	.+4      	; 0x2b7e <network_send+0x16a>
			{
				SendDataToAndFromModem();
    2b7a:	0e 94 48 01 	call	0x290	; 0x290 <SendDataToAndFromModem>

	modem_putc(0x21);
	checksum = CRC(checksum, 0x21);

	// Add the data, escaping it if necessary
	for (int i = 0; i < uip_len; i++)
    2b7e:	21 96       	adiw	r28, 0x01	; 1
    2b80:	08 94       	sec
    2b82:	a1 1c       	adc	r10, r1
    2b84:	b1 1c       	adc	r11, r1
    2b86:	80 91 cb 0e 	lds	r24, 0x0ECB
    2b8a:	90 91 cc 0e 	lds	r25, 0x0ECC
    2b8e:	c8 17       	cp	r28, r24
    2b90:	d9 07       	cpc	r29, r25
    2b92:	b0 f2       	brcs	.-84     	; 0x2b40 <network_send+0x12c>
				SendDataToAndFromModem();
			}
	}

	// Add the checksum to the end of the packet, escaping it if necessary
	checksum = ~checksum;
    2b94:	e8 01       	movw	r28, r16
    2b96:	c0 95       	com	r28
    2b98:	d0 95       	com	r29

	if ((checksum & 255) == 0x7d || (checksum & 255) == 0x7e)
    2b9a:	ce 01       	movw	r24, r28
    2b9c:	90 70       	andi	r25, 0x00	; 0
    2b9e:	8d 57       	subi	r24, 0x7D	; 125
    2ba0:	90 40       	sbci	r25, 0x00	; 0
    2ba2:	02 97       	sbiw	r24, 0x02	; 2
    2ba4:	30 f4       	brcc	.+12     	; 0x2bb2 <network_send+0x19e>
	{
		modem_putc(0x7d);
    2ba6:	8d e7       	ldi	r24, 0x7D	; 125
    2ba8:	0e 94 90 07 	call	0xf20	; 0xf20 <modem_putc>
		modem_putc((checksum & 255) ^ 0x20);
    2bac:	80 e2       	ldi	r24, 0x20	; 32
    2bae:	8c 27       	eor	r24, r28
    2bb0:	01 c0       	rjmp	.+2      	; 0x2bb4 <network_send+0x1a0>
	}
   	else
	{
		modem_putc(checksum & 255);								// Insert checksum MSB
    2bb2:	8c 2f       	mov	r24, r28
    2bb4:	0e 94 90 07 	call	0xf20	; 0xf20 <modem_putc>
	}
	
	if ((checksum / 256) == 0x7d || (checksum / 256) == 0x7e)
    2bb8:	ce 01       	movw	r24, r28
    2bba:	80 50       	subi	r24, 0x00	; 0
    2bbc:	9d 47       	sbci	r25, 0x7D	; 125
    2bbe:	80 50       	subi	r24, 0x00	; 0
    2bc0:	92 40       	sbci	r25, 0x02	; 2
    2bc2:	30 f4       	brcc	.+12     	; 0x2bd0 <network_send+0x1bc>
	{
		modem_putc(0x7d);
    2bc4:	8d e7       	ldi	r24, 0x7D	; 125
    2bc6:	0e 94 90 07 	call	0xf20	; 0xf20 <modem_putc>
		modem_putc((checksum / 256) ^ 0x20);
    2bca:	80 e2       	ldi	r24, 0x20	; 32
    2bcc:	8d 27       	eor	r24, r29
    2bce:	01 c0       	rjmp	.+2      	; 0x2bd2 <network_send+0x1be>
	}
	else
	{
		modem_putc(checksum / 256);								// Insert checksum LSB
    2bd0:	8d 2f       	mov	r24, r29
    2bd2:	0e 94 90 07 	call	0xf20	; 0xf20 <modem_putc>
	}
   
	modem_putc(0x7e);											// Framing
    2bd6:	8e e7       	ldi	r24, 0x7E	; 126
    2bd8:	0e 94 90 07 	call	0xf20	; 0xf20 <modem_putc>


	SendDataToAndFromModem();									// Flush the rest of the buffer
    2bdc:	0e 94 48 01 	call	0x290	; 0x290 <SendDataToAndFromModem>
}
    2be0:	df 91       	pop	r29
    2be2:	cf 91       	pop	r28
    2be4:	1f 91       	pop	r17
    2be6:	0f 91       	pop	r16
    2be8:	ff 90       	pop	r15
    2bea:	ef 90       	pop	r14
    2bec:	df 90       	pop	r13
    2bee:	cf 90       	pop	r12
    2bf0:	bf 90       	pop	r11
    2bf2:	af 90       	pop	r10
    2bf4:	08 95       	ret

00002bf6 <network_read>:
char InPacket = 0;
char Escape = 0;
uint16_t len = 0;

unsigned int network_read(void)
{
    2bf6:	0f 93       	push	r16
    2bf8:	1f 93       	push	r17
    2bfa:	cf 93       	push	r28
    2bfc:	df 93       	push	r29
	int c = modem_getc();
    2bfe:	0e 94 2a 07 	call	0xe54	; 0xe54 <modem_getc>
    2c02:	9c 01       	movw	r18, r24
	
	if (c & MODEM_NO_DATA)
    2c04:	90 fd       	sbrc	r25, 0
    2c06:	76 c0       	rjmp	.+236    	; 0x2cf4 <network_read+0xfe>
	{
		do
		{
			if (InPacket == 0 && InHeader == 0 && c == 0x7e)	// New Packet
			{
				InHeader = 1;
    2c08:	01 e0       	ldi	r16, 0x01	; 1
					len--;
				}
				else if (Escape == 1)							// Escaped character. Process now.
				{
					Escape = 0;
					*(uip_buf + len) = (c ^ 0x20);
    2c0a:	10 e2       	ldi	r17, 0x20	; 32
			{
				if (c == 0x21)									// End of Header (Header is 00 21)
				{
					InHeader = 0;
					InPacket = 1;
					len = -1;
    2c0c:	cf ef       	ldi	r28, 0xFF	; 255
    2c0e:	df ef       	ldi	r29, 0xFF	; 255
	}
	else
	{
		do
		{
			if (InPacket == 0 && InHeader == 0 && c == 0x7e)	// New Packet
    2c10:	90 91 99 0a 	lds	r25, 0x0A99
    2c14:	99 23       	and	r25, r25
    2c16:	69 f4       	brne	.+26     	; 0x2c32 <network_read+0x3c>
    2c18:	80 91 98 0a 	lds	r24, 0x0A98
    2c1c:	88 23       	and	r24, r24
    2c1e:	49 f4       	brne	.+18     	; 0x2c32 <network_read+0x3c>
    2c20:	2e 37       	cpi	r18, 0x7E	; 126
    2c22:	31 05       	cpc	r19, r1
    2c24:	31 f4       	brne	.+12     	; 0x2c32 <network_read+0x3c>
			{
				InHeader = 1;
    2c26:	00 93 98 0a 	sts	0x0A98, r16
				len = 0;
    2c2a:	10 92 9c 0a 	sts	0x0A9C, r1
    2c2e:	10 92 9b 0a 	sts	0x0A9B, r1
			}

			if (InHeader == 1)
    2c32:	80 91 98 0a 	lds	r24, 0x0A98
    2c36:	81 30       	cpi	r24, 0x01	; 1
    2c38:	b9 f4       	brne	.+46     	; 0x2c68 <network_read+0x72>
			{
				if (c == 0x21)									// End of Header (Header is 00 21)
    2c3a:	21 32       	cpi	r18, 0x21	; 33
    2c3c:	31 05       	cpc	r19, r1
    2c3e:	49 f4       	brne	.+18     	; 0x2c52 <network_read+0x5c>
				{
					InHeader = 0;
    2c40:	10 92 98 0a 	sts	0x0A98, r1
					InPacket = 1;
    2c44:	80 93 99 0a 	sts	0x0A99, r24
					len = -1;
    2c48:	d0 93 9c 0a 	sts	0x0A9C, r29
    2c4c:	c0 93 9b 0a 	sts	0x0A9B, r28
    2c50:	43 c0       	rjmp	.+134    	; 0x2cd8 <network_read+0xe2>
				}
				else if (len == 1 && c != 0x00)					// Got a non-SLIP packet, probably LCP-TERM. Need to re-establish link.
    2c52:	80 91 9b 0a 	lds	r24, 0x0A9B
    2c56:	90 91 9c 0a 	lds	r25, 0x0A9C
    2c5a:	01 97       	sbiw	r24, 0x01	; 1
    2c5c:	e9 f5       	brne	.+122    	; 0x2cd8 <network_read+0xe2>
    2c5e:	23 2b       	or	r18, r19
    2c60:	d9 f1       	breq	.+118    	; 0x2cd8 <network_read+0xe2>
    2c62:	2f ef       	ldi	r18, 0xFF	; 255
    2c64:	3f ef       	ldi	r19, 0xFF	; 255
    2c66:	48 c0       	rjmp	.+144    	; 0x2cf8 <network_read+0x102>
				{
					return -1;
				}
			}
			else if (InPacket == 1)
    2c68:	91 30       	cpi	r25, 0x01	; 1
    2c6a:	b1 f5       	brne	.+108    	; 0x2cd8 <network_read+0xe2>
			{
				if (c == 0x7d)									// Escaped character. Set flag and process next time around
    2c6c:	2d 37       	cpi	r18, 0x7D	; 125
    2c6e:	31 05       	cpc	r19, r1
    2c70:	61 f4       	brne	.+24     	; 0x2c8a <network_read+0x94>
				{
					Escape = 1;
    2c72:	90 93 9a 0a 	sts	0x0A9A, r25
					len--;
    2c76:	80 91 9b 0a 	lds	r24, 0x0A9B
    2c7a:	90 91 9c 0a 	lds	r25, 0x0A9C
    2c7e:	01 97       	sbiw	r24, 0x01	; 1
    2c80:	90 93 9c 0a 	sts	0x0A9C, r25
    2c84:	80 93 9b 0a 	sts	0x0A9B, r24
    2c88:	27 c0       	rjmp	.+78     	; 0x2cd8 <network_read+0xe2>
				}
				else if (Escape == 1)							// Escaped character. Process now.
    2c8a:	80 91 9a 0a 	lds	r24, 0x0A9A
    2c8e:	81 30       	cpi	r24, 0x01	; 1
    2c90:	61 f4       	brne	.+24     	; 0x2caa <network_read+0xb4>
				{
					Escape = 0;
    2c92:	10 92 9a 0a 	sts	0x0A9A, r1
					*(uip_buf + len) = (c ^ 0x20);
    2c96:	e0 91 9b 0a 	lds	r30, 0x0A9B
    2c9a:	f0 91 9c 0a 	lds	r31, 0x0A9C
    2c9e:	ea 5f       	subi	r30, 0xFA	; 250
    2ca0:	f0 4f       	sbci	r31, 0xF0	; 240
    2ca2:	82 2f       	mov	r24, r18
    2ca4:	81 27       	eor	r24, r17
    2ca6:	80 83       	st	Z, r24
    2ca8:	17 c0       	rjmp	.+46     	; 0x2cd8 <network_read+0xe2>
				}
				else if (c == 0x7e)								// End of packet
    2caa:	2e 37       	cpi	r18, 0x7E	; 126
    2cac:	31 05       	cpc	r19, r1
    2cae:	69 f4       	brne	.+26     	; 0x2cca <network_read+0xd4>
				{
					InPacket = 0;
    2cb0:	10 92 99 0a 	sts	0x0A99, r1
					Debug("\r\n");
    2cb4:	81 e5       	ldi	r24, 0x51	; 81
    2cb6:	96 e0       	ldi	r25, 0x06	; 6
    2cb8:	0e 94 a4 00 	call	0x148	; 0x148 <Debug>
					return len - 2; 							// (-2) = Strip off checksum and framing
    2cbc:	20 91 9b 0a 	lds	r18, 0x0A9B
    2cc0:	30 91 9c 0a 	lds	r19, 0x0A9C
    2cc4:	22 50       	subi	r18, 0x02	; 2
    2cc6:	30 40       	sbci	r19, 0x00	; 0
    2cc8:	17 c0       	rjmp	.+46     	; 0x2cf8 <network_read+0x102>
				}
				else
				{	
					*(uip_buf + len) = c;
    2cca:	e0 91 9b 0a 	lds	r30, 0x0A9B
    2cce:	f0 91 9c 0a 	lds	r31, 0x0A9C
    2cd2:	ea 5f       	subi	r30, 0xFA	; 250
    2cd4:	f0 4f       	sbci	r31, 0xF0	; 240
    2cd6:	20 83       	st	Z, r18
				}
			}			
			
			len++;
    2cd8:	80 91 9b 0a 	lds	r24, 0x0A9B
    2cdc:	90 91 9c 0a 	lds	r25, 0x0A9C
    2ce0:	01 96       	adiw	r24, 0x01	; 1
    2ce2:	90 93 9c 0a 	sts	0x0A9C, r25
    2ce6:	80 93 9b 0a 	sts	0x0A9B, r24
			c = modem_getc();
    2cea:	0e 94 2a 07 	call	0xe54	; 0xe54 <modem_getc>
    2cee:	9c 01       	movw	r18, r24
		}
		while (!(c & MODEM_NO_DATA));
    2cf0:	90 ff       	sbrs	r25, 0
    2cf2:	8e cf       	rjmp	.-228    	; 0x2c10 <network_read+0x1a>
    2cf4:	20 e0       	ldi	r18, 0x00	; 0
    2cf6:	30 e0       	ldi	r19, 0x00	; 0
	}

	return 0;	// Packet not finished yet if we got here.
}
    2cf8:	c9 01       	movw	r24, r18
    2cfa:	df 91       	pop	r29
    2cfc:	cf 91       	pop	r28
    2cfe:	1f 91       	pop	r17
    2d00:	0f 91       	pop	r16
    2d02:	08 95       	ret

00002d04 <USB_Host_WaitMS>:
		USB_ResetInterface();
	}
}

uint8_t USB_Host_WaitMS(uint8_t MS)
{
    2d04:	98 2f       	mov	r25, r24
	bool    BusSuspended = USB_Host_IsBusSuspended();
    2d06:	20 91 9e 00 	lds	r18, 0x009E
	uint8_t ErrorCode    = HOST_WAITERROR_Successful;
	
	USB_Host_ResumeBus();
    2d0a:	80 91 9e 00 	lds	r24, 0x009E
    2d0e:	81 60       	ori	r24, 0x01	; 1
    2d10:	80 93 9e 00 	sts	0x009E, r24
    2d14:	26 c0       	rjmp	.+76     	; 0x2d62 <USB_Host_WaitMS+0x5e>

	while (MS)
	{
		if (USB_INT_HasOccurred(USB_INT_HSOFI))
    2d16:	80 91 9f 00 	lds	r24, 0x009F
    2d1a:	85 ff       	sbrs	r24, 5
    2d1c:	06 c0       	rjmp	.+12     	; 0x2d2a <USB_Host_WaitMS+0x26>
		{
			USB_INT_Clear(USB_INT_HSOFI);
    2d1e:	80 91 9f 00 	lds	r24, 0x009F
    2d22:	8f 7d       	andi	r24, 0xDF	; 223
    2d24:	80 93 9f 00 	sts	0x009F, r24
			MS--;
    2d28:	91 50       	subi	r25, 0x01	; 1
		}
					
		if ((USB_HostState == HOST_STATE_Unattached) || (USB_CurrentMode == USB_MODE_DEVICE))
    2d2a:	80 91 76 11 	lds	r24, 0x1176
    2d2e:	82 30       	cpi	r24, 0x02	; 2
    2d30:	11 f4       	brne	.+4      	; 0x2d36 <USB_Host_WaitMS+0x32>
    2d32:	91 e0       	ldi	r25, 0x01	; 1
    2d34:	18 c0       	rjmp	.+48     	; 0x2d66 <USB_Host_WaitMS+0x62>
			ErrorCode = HOST_WAITERROR_DeviceDisconnect;
			
			break;
		}

		if (Pipe_IsError() == true)
    2d36:	80 91 a6 00 	lds	r24, 0x00A6
    2d3a:	84 ff       	sbrs	r24, 4
    2d3c:	07 c0       	rjmp	.+14     	; 0x2d4c <USB_Host_WaitMS+0x48>
		{
			Pipe_ClearError();
    2d3e:	80 91 a6 00 	lds	r24, 0x00A6
    2d42:	8f 7e       	andi	r24, 0xEF	; 239
    2d44:	80 93 a6 00 	sts	0x00A6, r24
    2d48:	92 e0       	ldi	r25, 0x02	; 2
    2d4a:	0d c0       	rjmp	.+26     	; 0x2d66 <USB_Host_WaitMS+0x62>
			ErrorCode = HOST_WAITERROR_PipeError;
			
			break;
		}
		
		if (Pipe_IsStalled() == true)
    2d4c:	80 91 a6 00 	lds	r24, 0x00A6
    2d50:	81 ff       	sbrs	r24, 1
    2d52:	07 c0       	rjmp	.+14     	; 0x2d62 <USB_Host_WaitMS+0x5e>
		{
			Pipe_ClearStall();
    2d54:	80 91 a6 00 	lds	r24, 0x00A6
    2d58:	8d 7f       	andi	r24, 0xFD	; 253
    2d5a:	80 93 a6 00 	sts	0x00A6, r24
    2d5e:	93 e0       	ldi	r25, 0x03	; 3
    2d60:	02 c0       	rjmp	.+4      	; 0x2d66 <USB_Host_WaitMS+0x62>
	bool    BusSuspended = USB_Host_IsBusSuspended();
	uint8_t ErrorCode    = HOST_WAITERROR_Successful;
	
	USB_Host_ResumeBus();

	while (MS)
    2d62:	99 23       	and	r25, r25
    2d64:	c1 f6       	brne	.-80     	; 0x2d16 <USB_Host_WaitMS+0x12>
			
			break;			
		}
	}

	if (BusSuspended)
    2d66:	20 fd       	sbrc	r18, 0
    2d68:	05 c0       	rjmp	.+10     	; 0x2d74 <USB_Host_WaitMS+0x70>
	  USB_Host_SuspendBus();
    2d6a:	80 91 9e 00 	lds	r24, 0x009E
    2d6e:	8e 7f       	andi	r24, 0xFE	; 254
    2d70:	80 93 9e 00 	sts	0x009E, r24

	return ErrorCode;
}
    2d74:	89 2f       	mov	r24, r25
    2d76:	08 95       	ret

00002d78 <USB_Host_ResetDevice>:

static void USB_Host_ResetDevice(void)
{
	bool BusSuspended = USB_Host_IsBusSuspended();
    2d78:	30 91 9e 00 	lds	r19, 0x009E

	USB_INT_Disable(USB_INT_DDISCI);
    2d7c:	80 91 a0 00 	lds	r24, 0x00A0
    2d80:	8d 7f       	andi	r24, 0xFD	; 253
    2d82:	80 93 a0 00 	sts	0x00A0, r24
	
	USB_Host_ResetBus();
    2d86:	80 91 9e 00 	lds	r24, 0x009E
    2d8a:	82 60       	ori	r24, 0x02	; 2
    2d8c:	80 93 9e 00 	sts	0x009E, r24
	while (!(USB_Host_IsBusResetComplete()));
    2d90:	80 91 9e 00 	lds	r24, 0x009E
    2d94:	81 fd       	sbrc	r24, 1
    2d96:	fc cf       	rjmp	.-8      	; 0x2d90 <USB_Host_ResetDevice+0x18>

	USB_Host_ResumeBus();
    2d98:	80 91 9e 00 	lds	r24, 0x009E
    2d9c:	81 60       	ori	r24, 0x01	; 1
    2d9e:	80 93 9e 00 	sts	0x009E, r24

	USB_INT_Clear(USB_INT_HSOFI);
    2da2:	80 91 9f 00 	lds	r24, 0x009F
    2da6:	8f 7d       	andi	r24, 0xDF	; 223
    2da8:	80 93 9f 00 	sts	0x009F, r24
    2dac:	2a e0       	ldi	r18, 0x0A	; 10
    2dae:	40 ed       	ldi	r20, 0xD0	; 208
    2db0:	57 e0       	ldi	r21, 0x07	; 7
		/* Workaround for powerless-pull-up devices. After a USB bus reset,
		   all disconnection interrupts are suppressed while a USB frame is
		   looked for - if it is found within 10ms, the device is still
		   present.                                                        */

		if (USB_INT_HasOccurred(USB_INT_HSOFI))
    2db2:	80 91 9f 00 	lds	r24, 0x009F
    2db6:	85 ff       	sbrs	r24, 5
    2db8:	0b c0       	rjmp	.+22     	; 0x2dd0 <USB_Host_ResetDevice+0x58>
		{
			USB_INT_Clear(USB_INT_HSOFI);
    2dba:	80 91 9f 00 	lds	r24, 0x009F
    2dbe:	8f 7d       	andi	r24, 0xDF	; 223
    2dc0:	80 93 9f 00 	sts	0x009F, r24
			USB_INT_Clear(USB_INT_DDISCI);
    2dc4:	80 91 9f 00 	lds	r24, 0x009F
    2dc8:	8d 7f       	andi	r24, 0xFD	; 253
    2dca:	80 93 9f 00 	sts	0x009F, r24
    2dce:	05 c0       	rjmp	.+10     	; 0x2dda <USB_Host_ResetDevice+0x62>
    2dd0:	ca 01       	movw	r24, r20
    2dd2:	01 97       	sbiw	r24, 0x01	; 1
    2dd4:	f1 f7       	brne	.-4      	; 0x2dd2 <USB_Host_ResetDevice+0x5a>

	USB_Host_ResumeBus();

	USB_INT_Clear(USB_INT_HSOFI);

	for (uint8_t MSRem = 10; MSRem != 0; MSRem--)
    2dd6:	21 50       	subi	r18, 0x01	; 1
    2dd8:	61 f7       	brne	.-40     	; 0x2db2 <USB_Host_ResetDevice+0x3a>
		}
		
		_delay_ms(1);
	}

	if (BusSuspended)
    2dda:	30 fd       	sbrc	r19, 0
    2ddc:	05 c0       	rjmp	.+10     	; 0x2de8 <USB_Host_ResetDevice+0x70>
	  USB_Host_SuspendBus();
    2dde:	80 91 9e 00 	lds	r24, 0x009E
    2de2:	8e 7f       	andi	r24, 0xFE	; 254
    2de4:	80 93 9e 00 	sts	0x009E, r24

	USB_INT_Enable(USB_INT_DDISCI);
    2de8:	80 91 a0 00 	lds	r24, 0x00A0
    2dec:	82 60       	ori	r24, 0x02	; 2
    2dee:	80 93 a0 00 	sts	0x00A0, r24
}
    2df2:	08 95       	ret

00002df4 <USB_Host_ProcessNextHostState>:

#define  INCLUDE_FROM_HOST_C
#include "Host.h"

void USB_Host_ProcessNextHostState(void)
{
    2df4:	ef 92       	push	r14
    2df6:	0f 93       	push	r16
    2df8:	1f 93       	push	r17
    2dfa:	df 93       	push	r29
    2dfc:	cf 93       	push	r28
    2dfe:	cd b7       	in	r28, 0x3d	; 61
    2e00:	de b7       	in	r29, 0x3e	; 62
    2e02:	28 97       	sbiw	r28, 0x08	; 8
    2e04:	0f b6       	in	r0, 0x3f	; 63
    2e06:	f8 94       	cli
    2e08:	de bf       	out	0x3e, r29	; 62
    2e0a:	0f be       	out	0x3f, r0	; 63
    2e0c:	cd bf       	out	0x3d, r28	; 61
	uint8_t SubErrorCode = HOST_ENUMERROR_NoError;

	static uint16_t WaitMSRemaining;
	static uint8_t  PostWaitState;

	switch (USB_HostState)
    2e0e:	80 91 76 11 	lds	r24, 0x1176
    2e12:	86 30       	cpi	r24, 0x06	; 6
    2e14:	09 f4       	brne	.+2      	; 0x2e18 <USB_Host_ProcessNextHostState+0x24>
    2e16:	94 c0       	rjmp	.+296    	; 0x2f40 <USB_Host_ProcessNextHostState+0x14c>
    2e18:	87 30       	cpi	r24, 0x07	; 7
    2e1a:	70 f4       	brcc	.+28     	; 0x2e38 <USB_Host_ProcessNextHostState+0x44>
    2e1c:	83 30       	cpi	r24, 0x03	; 3
    2e1e:	c1 f1       	breq	.+112    	; 0x2e90 <USB_Host_ProcessNextHostState+0x9c>
    2e20:	84 30       	cpi	r24, 0x04	; 4
    2e22:	20 f4       	brcc	.+8      	; 0x2e2c <USB_Host_ProcessNextHostState+0x38>
    2e24:	81 30       	cpi	r24, 0x01	; 1
    2e26:	09 f0       	breq	.+2      	; 0x2e2a <USB_Host_ProcessNextHostState+0x36>
    2e28:	19 c1       	rjmp	.+562    	; 0x305c <USB_Host_ProcessNextHostState+0x268>
    2e2a:	13 c0       	rjmp	.+38     	; 0x2e52 <USB_Host_ProcessNextHostState+0x5e>
    2e2c:	84 30       	cpi	r24, 0x04	; 4
    2e2e:	c1 f1       	breq	.+112    	; 0x2ea0 <USB_Host_ProcessNextHostState+0xac>
    2e30:	85 30       	cpi	r24, 0x05	; 5
    2e32:	09 f0       	breq	.+2      	; 0x2e36 <USB_Host_ProcessNextHostState+0x42>
    2e34:	13 c1       	rjmp	.+550    	; 0x305c <USB_Host_ProcessNextHostState+0x268>
    2e36:	5b c0       	rjmp	.+182    	; 0x2eee <USB_Host_ProcessNextHostState+0xfa>
    2e38:	88 30       	cpi	r24, 0x08	; 8
    2e3a:	09 f4       	brne	.+2      	; 0x2e3e <USB_Host_ProcessNextHostState+0x4a>
    2e3c:	9b c0       	rjmp	.+310    	; 0x2f74 <USB_Host_ProcessNextHostState+0x180>
    2e3e:	88 30       	cpi	r24, 0x08	; 8
    2e40:	08 f4       	brcc	.+2      	; 0x2e44 <USB_Host_ProcessNextHostState+0x50>
    2e42:	8a c0       	rjmp	.+276    	; 0x2f58 <USB_Host_ProcessNextHostState+0x164>
    2e44:	89 30       	cpi	r24, 0x09	; 9
    2e46:	09 f4       	brne	.+2      	; 0x2e4a <USB_Host_ProcessNextHostState+0x56>
    2e48:	b4 c0       	rjmp	.+360    	; 0x2fb2 <USB_Host_ProcessNextHostState+0x1be>
    2e4a:	8a 30       	cpi	r24, 0x0A	; 10
    2e4c:	09 f0       	breq	.+2      	; 0x2e50 <USB_Host_ProcessNextHostState+0x5c>
    2e4e:	06 c1       	rjmp	.+524    	; 0x305c <USB_Host_ProcessNextHostState+0x268>
    2e50:	e8 c0       	rjmp	.+464    	; 0x3022 <USB_Host_ProcessNextHostState+0x22e>
	{
		case HOST_STATE_WaitForDevice:
			if (WaitMSRemaining)
    2e52:	00 91 9e 0a 	lds	r16, 0x0A9E
    2e56:	10 91 9f 0a 	lds	r17, 0x0A9F
    2e5a:	01 15       	cp	r16, r1
    2e5c:	11 05       	cpc	r17, r1
    2e5e:	09 f4       	brne	.+2      	; 0x2e62 <USB_Host_ProcessNextHostState+0x6e>
    2e60:	fd c0       	rjmp	.+506    	; 0x305c <USB_Host_ProcessNextHostState+0x268>
			{
				if ((SubErrorCode = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    2e62:	81 e0       	ldi	r24, 0x01	; 1
    2e64:	4f df       	rcall	.-354    	; 0x2d04 <USB_Host_WaitMS>
    2e66:	68 2f       	mov	r22, r24
    2e68:	88 23       	and	r24, r24
    2e6a:	31 f0       	breq	.+12     	; 0x2e78 <USB_Host_ProcessNextHostState+0x84>
				{
					USB_HostState = PostWaitState;
    2e6c:	80 91 9d 0a 	lds	r24, 0x0A9D
    2e70:	80 93 76 11 	sts	0x1176, r24
    2e74:	91 e0       	ldi	r25, 0x01	; 1
    2e76:	ee c0       	rjmp	.+476    	; 0x3054 <USB_Host_ProcessNextHostState+0x260>
					ErrorCode     = HOST_ENUMERROR_WaitStage;
					break;
				}
				
				if (!(--WaitMSRemaining))
    2e78:	c8 01       	movw	r24, r16
    2e7a:	01 97       	sbiw	r24, 0x01	; 1
    2e7c:	90 93 9f 0a 	sts	0x0A9F, r25
    2e80:	80 93 9e 0a 	sts	0x0A9E, r24
    2e84:	89 2b       	or	r24, r25
    2e86:	09 f0       	breq	.+2      	; 0x2e8a <USB_Host_ProcessNextHostState+0x96>
    2e88:	e9 c0       	rjmp	.+466    	; 0x305c <USB_Host_ProcessNextHostState+0x268>
				  USB_HostState = PostWaitState;
    2e8a:	80 91 9d 0a 	lds	r24, 0x0A9D
    2e8e:	cf c0       	rjmp	.+414    	; 0x302e <USB_Host_ProcessNextHostState+0x23a>
			}
		
			break;
		case HOST_STATE_Powered:
			WaitMSRemaining = HOST_DEVICE_SETTLE_DELAY_MS;
    2e90:	8c ed       	ldi	r24, 0xDC	; 220
    2e92:	95 e0       	ldi	r25, 0x05	; 5
    2e94:	90 93 9f 0a 	sts	0x0A9F, r25
    2e98:	80 93 9e 0a 	sts	0x0A9E, r24
		
			USB_HostState = HOST_STATE_Powered_WaitForDeviceSettle;
    2e9c:	84 e0       	ldi	r24, 0x04	; 4
    2e9e:	c7 c0       	rjmp	.+398    	; 0x302e <USB_Host_ProcessNextHostState+0x23a>
			break;
		case HOST_STATE_Powered_WaitForDeviceSettle:
			if (WaitMSRemaining--)
    2ea0:	80 91 9e 0a 	lds	r24, 0x0A9E
    2ea4:	90 91 9f 0a 	lds	r25, 0x0A9F
    2ea8:	01 97       	sbiw	r24, 0x01	; 1
    2eaa:	90 93 9f 0a 	sts	0x0A9F, r25
    2eae:	80 93 9e 0a 	sts	0x0A9E, r24
    2eb2:	01 96       	adiw	r24, 0x01	; 1
    2eb4:	29 f0       	breq	.+10     	; 0x2ec0 <USB_Host_ProcessNextHostState+0xcc>
    2eb6:	80 ed       	ldi	r24, 0xD0	; 208
    2eb8:	97 e0       	ldi	r25, 0x07	; 7
    2eba:	01 97       	sbiw	r24, 0x01	; 1
    2ebc:	f1 f7       	brne	.-4      	; 0x2eba <USB_Host_ProcessNextHostState+0xc6>
    2ebe:	ce c0       	rjmp	.+412    	; 0x305c <USB_Host_ProcessNextHostState+0x268>
				_delay_ms(1);
				break;
			}
			else
			{
				USB_Host_VBUS_Manual_Off();
    2ec0:	77 98       	cbi	0x0e, 7	; 14

				USB_OTGPAD_On();
    2ec2:	80 91 d8 00 	lds	r24, 0x00D8
    2ec6:	80 61       	ori	r24, 0x10	; 16
    2ec8:	80 93 d8 00 	sts	0x00D8, r24
				USB_Host_VBUS_Auto_Enable();
    2ecc:	80 91 dd 00 	lds	r24, 0x00DD
    2ed0:	8b 7f       	andi	r24, 0xFB	; 251
    2ed2:	80 93 dd 00 	sts	0x00DD, r24
    2ed6:	80 91 d7 00 	lds	r24, 0x00D7
    2eda:	80 61       	ori	r24, 0x10	; 16
    2edc:	80 93 d7 00 	sts	0x00D7, r24
				USB_Host_VBUS_Auto_On();
    2ee0:	80 91 dd 00 	lds	r24, 0x00DD
    2ee4:	82 60       	ori	r24, 0x02	; 2
    2ee6:	80 93 dd 00 	sts	0x00DD, r24
				
				USB_HostState = HOST_STATE_Powered_WaitForConnect;
    2eea:	85 e0       	ldi	r24, 0x05	; 5
    2eec:	a0 c0       	rjmp	.+320    	; 0x302e <USB_Host_ProcessNextHostState+0x23a>
			}
			
			break;
		case HOST_STATE_Powered_WaitForConnect:		
			if (USB_INT_HasOccurred(USB_INT_DCONNI))
    2eee:	80 91 9f 00 	lds	r24, 0x009F
    2ef2:	80 ff       	sbrs	r24, 0
    2ef4:	b3 c0       	rjmp	.+358    	; 0x305c <USB_Host_ProcessNextHostState+0x268>
			{	
				USB_INT_Clear(USB_INT_DCONNI);
    2ef6:	80 91 9f 00 	lds	r24, 0x009F
    2efa:	8e 7f       	andi	r24, 0xFE	; 254
    2efc:	80 93 9f 00 	sts	0x009F, r24
				USB_INT_Clear(USB_INT_DDISCI);
    2f00:	80 91 9f 00 	lds	r24, 0x009F
    2f04:	8d 7f       	andi	r24, 0xFD	; 253
    2f06:	80 93 9f 00 	sts	0x009F, r24

				USB_INT_Clear(USB_INT_VBERRI);
    2f0a:	80 91 df 00 	lds	r24, 0x00DF
    2f0e:	8d 7f       	andi	r24, 0xFD	; 253
    2f10:	80 93 df 00 	sts	0x00DF, r24
				USB_INT_Enable(USB_INT_VBERRI);
    2f14:	80 91 de 00 	lds	r24, 0x00DE
    2f18:	82 60       	ori	r24, 0x02	; 2
    2f1a:	80 93 de 00 	sts	0x00DE, r24
					
				USB_Host_ResumeBus();
    2f1e:	80 91 9e 00 	lds	r24, 0x009E
    2f22:	81 60       	ori	r24, 0x01	; 1
    2f24:	80 93 9e 00 	sts	0x009E, r24
				Pipe_ClearPipes();
    2f28:	97 d2       	rcall	.+1326   	; 0x3458 <Pipe_ClearPipes>
				
				HOST_TASK_NONBLOCK_WAIT(100, HOST_STATE_Powered_DoReset);
    2f2a:	81 e0       	ldi	r24, 0x01	; 1
    2f2c:	80 93 76 11 	sts	0x1176, r24
    2f30:	84 e6       	ldi	r24, 0x64	; 100
    2f32:	90 e0       	ldi	r25, 0x00	; 0
    2f34:	90 93 9f 0a 	sts	0x0A9F, r25
    2f38:	80 93 9e 0a 	sts	0x0A9E, r24
    2f3c:	86 e0       	ldi	r24, 0x06	; 6
    2f3e:	6e c0       	rjmp	.+220    	; 0x301c <USB_Host_ProcessNextHostState+0x228>
			}

			break;
		case HOST_STATE_Powered_DoReset:
			USB_Host_ResetDevice();
    2f40:	1b df       	rcall	.-458    	; 0x2d78 <USB_Host_ResetDevice>

			HOST_TASK_NONBLOCK_WAIT(200, HOST_STATE_Powered_ConfigPipe);
    2f42:	81 e0       	ldi	r24, 0x01	; 1
    2f44:	80 93 76 11 	sts	0x1176, r24
    2f48:	88 ec       	ldi	r24, 0xC8	; 200
    2f4a:	90 e0       	ldi	r25, 0x00	; 0
    2f4c:	90 93 9f 0a 	sts	0x0A9F, r25
    2f50:	80 93 9e 0a 	sts	0x0A9E, r24
    2f54:	87 e0       	ldi	r24, 0x07	; 7
    2f56:	62 c0       	rjmp	.+196    	; 0x301c <USB_Host_ProcessNextHostState+0x228>
			break;
		case HOST_STATE_Powered_ConfigPipe:
			Pipe_ConfigurePipe(PIPE_CONTROLPIPE, EP_TYPE_CONTROL,
    2f58:	80 e0       	ldi	r24, 0x00	; 0
    2f5a:	60 e0       	ldi	r22, 0x00	; 0
    2f5c:	40 e0       	ldi	r20, 0x00	; 0
    2f5e:	20 e0       	ldi	r18, 0x00	; 0
    2f60:	00 e4       	ldi	r16, 0x40	; 64
    2f62:	10 e0       	ldi	r17, 0x00	; 0
    2f64:	ee 24       	eor	r14, r14
    2f66:	36 d2       	rcall	.+1132   	; 0x33d4 <Pipe_ConfigurePipe>
							   PIPE_TOKEN_SETUP, ENDPOINT_CONTROLEP,
							   PIPE_CONTROLPIPE_DEFAULT_SIZE, PIPE_BANK_SINGLE);		
		
			if (!(Pipe_IsConfigured()))
    2f68:	80 91 ac 00 	lds	r24, 0x00AC
    2f6c:	87 ff       	sbrs	r24, 7
    2f6e:	70 c0       	rjmp	.+224    	; 0x3050 <USB_Host_ProcessNextHostState+0x25c>
				ErrorCode    = HOST_ENUMERROR_PipeConfigError;
				SubErrorCode = 0;
				break;
			}

			USB_HostState = HOST_STATE_Default;
    2f70:	88 e0       	ldi	r24, 0x08	; 8
    2f72:	5d c0       	rjmp	.+186    	; 0x302e <USB_Host_ProcessNextHostState+0x23a>
			break;
		case HOST_STATE_Default:
			USB_ControlRequest = (USB_Request_Header_t)
    2f74:	ae e6       	ldi	r26, 0x6E	; 110
    2f76:	b1 e1       	ldi	r27, 0x11	; 17
    2f78:	e8 e6       	ldi	r30, 0x68	; 104
    2f7a:	f6 e0       	ldi	r31, 0x06	; 6
    2f7c:	88 e0       	ldi	r24, 0x08	; 8
    2f7e:	01 90       	ld	r0, Z+
    2f80:	0d 92       	st	X+, r0
    2f82:	81 50       	subi	r24, 0x01	; 1
    2f84:	e1 f7       	brne	.-8      	; 0x2f7e <USB_Host_ProcessNextHostState+0x18a>
					.wLength       = 8,
				};

			uint8_t DataBuffer[8];

			if ((SubErrorCode = USB_Host_SendControlRequest(DataBuffer)) != HOST_SENDCONTROL_Successful)
    2f86:	ce 01       	movw	r24, r28
    2f88:	01 96       	adiw	r24, 0x01	; 1
    2f8a:	9d d0       	rcall	.+314    	; 0x30c6 <USB_Host_SendControlRequest>
    2f8c:	68 2f       	mov	r22, r24
    2f8e:	88 23       	and	r24, r24
    2f90:	09 f0       	breq	.+2      	; 0x2f94 <USB_Host_ProcessNextHostState+0x1a0>
    2f92:	5c c0       	rjmp	.+184    	; 0x304c <USB_Host_ProcessNextHostState+0x258>
			{
				ErrorCode = HOST_ENUMERROR_ControlError;
				break;
			}

			USB_ControlPipeSize = DataBuffer[offsetof(USB_Descriptor_Device_t, Endpoint0Size)];
    2f94:	88 85       	ldd	r24, Y+8	; 0x08
    2f96:	80 93 70 06 	sts	0x0670, r24
	
			USB_Host_ResetDevice();
    2f9a:	ee de       	rcall	.-548    	; 0x2d78 <USB_Host_ResetDevice>
			
			HOST_TASK_NONBLOCK_WAIT(200, HOST_STATE_Default_PostReset);
    2f9c:	81 e0       	ldi	r24, 0x01	; 1
    2f9e:	80 93 76 11 	sts	0x1176, r24
    2fa2:	88 ec       	ldi	r24, 0xC8	; 200
    2fa4:	90 e0       	ldi	r25, 0x00	; 0
    2fa6:	90 93 9f 0a 	sts	0x0A9F, r25
    2faa:	80 93 9e 0a 	sts	0x0A9E, r24
    2fae:	89 e0       	ldi	r24, 0x09	; 9
    2fb0:	35 c0       	rjmp	.+106    	; 0x301c <USB_Host_ProcessNextHostState+0x228>
			break;
		case HOST_STATE_Default_PostReset:
			Pipe_DisablePipe();
    2fb2:	80 91 a9 00 	lds	r24, 0x00A9
    2fb6:	8e 7f       	andi	r24, 0xFE	; 254
    2fb8:	80 93 a9 00 	sts	0x00A9, r24
			Pipe_DeallocateMemory();		
    2fbc:	80 91 ab 00 	lds	r24, 0x00AB
    2fc0:	8d 7f       	andi	r24, 0xFD	; 253
    2fc2:	80 93 ab 00 	sts	0x00AB, r24
			Pipe_ResetPipe(PIPE_CONTROLPIPE);
    2fc6:	81 e0       	ldi	r24, 0x01	; 1
    2fc8:	80 93 a8 00 	sts	0x00A8, r24
    2fcc:	10 92 a8 00 	sts	0x00A8, r1
			
			Pipe_ConfigurePipe(PIPE_CONTROLPIPE, EP_TYPE_CONTROL,
    2fd0:	00 91 70 06 	lds	r16, 0x0670
    2fd4:	80 e0       	ldi	r24, 0x00	; 0
    2fd6:	60 e0       	ldi	r22, 0x00	; 0
    2fd8:	40 e0       	ldi	r20, 0x00	; 0
    2fda:	20 e0       	ldi	r18, 0x00	; 0
    2fdc:	10 e0       	ldi	r17, 0x00	; 0
    2fde:	ee 24       	eor	r14, r14
    2fe0:	f9 d1       	rcall	.+1010   	; 0x33d4 <Pipe_ConfigurePipe>
			                   PIPE_TOKEN_SETUP, ENDPOINT_CONTROLEP,
			                   USB_ControlPipeSize, PIPE_BANK_SINGLE);

			if (!(Pipe_IsConfigured()))
    2fe2:	80 91 ac 00 	lds	r24, 0x00AC
    2fe6:	87 ff       	sbrs	r24, 7
    2fe8:	33 c0       	rjmp	.+102    	; 0x3050 <USB_Host_ProcessNextHostState+0x25c>
				ErrorCode    = HOST_ENUMERROR_PipeConfigError;
				SubErrorCode = 0;
				break;
			}

			USB_ControlRequest = (USB_Request_Header_t)
    2fea:	ae e6       	ldi	r26, 0x6E	; 110
    2fec:	b1 e1       	ldi	r27, 0x11	; 17
    2fee:	e0 e6       	ldi	r30, 0x60	; 96
    2ff0:	f6 e0       	ldi	r31, 0x06	; 6
    2ff2:	88 e0       	ldi	r24, 0x08	; 8
    2ff4:	01 90       	ld	r0, Z+
    2ff6:	0d 92       	st	X+, r0
    2ff8:	81 50       	subi	r24, 0x01	; 1
    2ffa:	e1 f7       	brne	.-8      	; 0x2ff4 <USB_Host_ProcessNextHostState+0x200>
					.wValue        = USB_HOST_DEVICEADDRESS,
					.wIndex        = 0,
					.wLength       = 0,
				};

			if ((SubErrorCode = USB_Host_SendControlRequest(NULL)) != HOST_SENDCONTROL_Successful)
    2ffc:	80 e0       	ldi	r24, 0x00	; 0
    2ffe:	90 e0       	ldi	r25, 0x00	; 0
    3000:	62 d0       	rcall	.+196    	; 0x30c6 <USB_Host_SendControlRequest>
    3002:	68 2f       	mov	r22, r24
    3004:	88 23       	and	r24, r24
    3006:	11 f5       	brne	.+68     	; 0x304c <USB_Host_ProcessNextHostState+0x258>
			{
				ErrorCode = HOST_ENUMERROR_ControlError;
				break;
			}

			HOST_TASK_NONBLOCK_WAIT(100, HOST_STATE_Default_PostAddressSet);
    3008:	81 e0       	ldi	r24, 0x01	; 1
    300a:	80 93 76 11 	sts	0x1176, r24
    300e:	84 e6       	ldi	r24, 0x64	; 100
    3010:	90 e0       	ldi	r25, 0x00	; 0
    3012:	90 93 9f 0a 	sts	0x0A9F, r25
    3016:	80 93 9e 0a 	sts	0x0A9E, r24
    301a:	8a e0       	ldi	r24, 0x0A	; 10
    301c:	80 93 9d 0a 	sts	0x0A9D, r24
    3020:	1d c0       	rjmp	.+58     	; 0x305c <USB_Host_ProcessNextHostState+0x268>
			break;
		case HOST_STATE_Default_PostAddressSet:
			USB_Host_SetDeviceAddress(USB_HOST_DEVICEADDRESS);
    3022:	81 e0       	ldi	r24, 0x01	; 1
    3024:	80 93 a1 00 	sts	0x00A1, r24

			EVENT_USB_Host_DeviceEnumerationComplete();
    3028:	0e 94 b4 00 	call	0x168	; 0x168 <EVENT_USB_Host_DeviceEnumerationComplete>
			USB_HostState = HOST_STATE_Addressed;
    302c:	8b e0       	ldi	r24, 0x0B	; 11
    302e:	80 93 76 11 	sts	0x1176, r24
    3032:	14 c0       	rjmp	.+40     	; 0x305c <USB_Host_ProcessNextHostState+0x268>
			break;
	}

	if ((ErrorCode != HOST_ENUMERROR_NoError) && (USB_HostState != HOST_STATE_Unattached))
	{
		EVENT_USB_Host_DeviceEnumerationFailed(ErrorCode, SubErrorCode);
    3034:	89 2f       	mov	r24, r25
    3036:	0e 94 ac 00 	call	0x158	; 0x158 <EVENT_USB_Host_DeviceEnumerationFailed>

		USB_Host_VBUS_Auto_Off();
    303a:	80 91 dd 00 	lds	r24, 0x00DD
    303e:	81 60       	ori	r24, 0x01	; 1
    3040:	80 93 dd 00 	sts	0x00DD, r24

		EVENT_USB_Host_DeviceUnattached();
    3044:	0e 94 bc 00 	call	0x178	; 0x178 <EVENT_USB_Host_DeviceUnattached>

		USB_ResetInterface();
    3048:	55 d1       	rcall	.+682    	; 0x32f4 <USB_ResetInterface>
    304a:	08 c0       	rjmp	.+16     	; 0x305c <USB_Host_ProcessNextHostState+0x268>
	}
}
    304c:	93 e0       	ldi	r25, 0x03	; 3
    304e:	02 c0       	rjmp	.+4      	; 0x3054 <USB_Host_ProcessNextHostState+0x260>
    3050:	94 e0       	ldi	r25, 0x04	; 4
    3052:	60 e0       	ldi	r22, 0x00	; 0
			EVENT_USB_Host_DeviceEnumerationComplete();
			USB_HostState = HOST_STATE_Addressed;
			break;
	}

	if ((ErrorCode != HOST_ENUMERROR_NoError) && (USB_HostState != HOST_STATE_Unattached))
    3054:	80 91 76 11 	lds	r24, 0x1176
    3058:	82 30       	cpi	r24, 0x02	; 2
    305a:	61 f7       	brne	.-40     	; 0x3034 <USB_Host_ProcessNextHostState+0x240>

		EVENT_USB_Host_DeviceUnattached();

		USB_ResetInterface();
	}
}
    305c:	28 96       	adiw	r28, 0x08	; 8
    305e:	0f b6       	in	r0, 0x3f	; 63
    3060:	f8 94       	cli
    3062:	de bf       	out	0x3e, r29	; 62
    3064:	0f be       	out	0x3f, r0	; 63
    3066:	cd bf       	out	0x3d, r28	; 61
    3068:	cf 91       	pop	r28
    306a:	df 91       	pop	r29
    306c:	1f 91       	pop	r17
    306e:	0f 91       	pop	r16
    3070:	ef 90       	pop	r14
    3072:	08 95       	ret

00003074 <USB_Host_WaitForIOS>:

	return ReturnStatus;
}

static uint8_t USB_Host_WaitForIOS(const uint8_t WaitType)
{
    3074:	1f 93       	push	r17
    3076:	cf 93       	push	r28
    3078:	df 93       	push	r29
    307a:	18 2f       	mov	r17, r24
    307c:	c8 ee       	ldi	r28, 0xE8	; 232
    307e:	d3 e0       	ldi	r29, 0x03	; 3
    3080:	09 c0       	rjmp	.+18     	; 0x3094 <USB_Host_WaitForIOS+0x20>
	         ((WaitType == USB_HOST_WAITFOR_InReceived) && Pipe_IsINReceived()) ||
	         ((WaitType == USB_HOST_WAITFOR_OutReady)   && Pipe_IsOUTReady())))
	{
		uint8_t ErrorCode;

		if ((ErrorCode = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    3082:	81 e0       	ldi	r24, 0x01	; 1
    3084:	3f de       	rcall	.-898    	; 0x2d04 <USB_Host_WaitMS>
    3086:	88 23       	and	r24, r24
    3088:	d1 f4       	brne	.+52     	; 0x30be <USB_Host_WaitForIOS+0x4a>
		  return ErrorCode;
			
		if (!(TimeoutCounter--))
    308a:	20 97       	sbiw	r28, 0x00	; 0
    308c:	11 f4       	brne	.+4      	; 0x3092 <USB_Host_WaitForIOS+0x1e>
    308e:	84 e0       	ldi	r24, 0x04	; 4
    3090:	16 c0       	rjmp	.+44     	; 0x30be <USB_Host_WaitForIOS+0x4a>
    3092:	21 97       	sbiw	r28, 0x01	; 1
	uint8_t  TimeoutCounter = USB_HOST_TIMEOUT_MS;	
	#else
	uint16_t TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#endif
	
	while (!(((WaitType == USB_HOST_WAITFOR_SetupSent)  && Pipe_IsSETUPSent())  ||
    3094:	11 23       	and	r17, r17
    3096:	29 f4       	brne	.+10     	; 0x30a2 <USB_Host_WaitForIOS+0x2e>
    3098:	80 91 a6 00 	lds	r24, 0x00A6
    309c:	83 ff       	sbrs	r24, 3
    309e:	f1 cf       	rjmp	.-30     	; 0x3082 <USB_Host_WaitForIOS+0xe>
    30a0:	0d c0       	rjmp	.+26     	; 0x30bc <USB_Host_WaitForIOS+0x48>
    30a2:	11 30       	cpi	r17, 0x01	; 1
    30a4:	29 f4       	brne	.+10     	; 0x30b0 <USB_Host_WaitForIOS+0x3c>
    30a6:	80 91 a6 00 	lds	r24, 0x00A6
    30aa:	80 ff       	sbrs	r24, 0
    30ac:	ea cf       	rjmp	.-44     	; 0x3082 <USB_Host_WaitForIOS+0xe>
    30ae:	06 c0       	rjmp	.+12     	; 0x30bc <USB_Host_WaitForIOS+0x48>
    30b0:	12 30       	cpi	r17, 0x02	; 2
    30b2:	39 f7       	brne	.-50     	; 0x3082 <USB_Host_WaitForIOS+0xe>
    30b4:	80 91 a6 00 	lds	r24, 0x00A6
    30b8:	82 ff       	sbrs	r24, 2
    30ba:	e3 cf       	rjmp	.-58     	; 0x3082 <USB_Host_WaitForIOS+0xe>
    30bc:	80 e0       	ldi	r24, 0x00	; 0
		if (!(TimeoutCounter--))
		  return HOST_SENDCONTROL_SoftwareTimeOut;
	}

	return HOST_SENDCONTROL_Successful;
}
    30be:	df 91       	pop	r29
    30c0:	cf 91       	pop	r28
    30c2:	1f 91       	pop	r17
    30c4:	08 95       	ret

000030c6 <USB_Host_SendControlRequest>:

#define  INCLUDE_FROM_HOSTCHAPTER9_C
#include "HostChapter9.h"

uint8_t USB_Host_SendControlRequest(void* BufferPtr)
{
    30c6:	ff 92       	push	r15
    30c8:	0f 93       	push	r16
    30ca:	1f 93       	push	r17
    30cc:	cf 93       	push	r28
    30ce:	df 93       	push	r29
    30d0:	18 2f       	mov	r17, r24
    30d2:	09 2f       	mov	r16, r25
	uint8_t* HeaderStream   = (uint8_t*)&USB_ControlRequest;
	uint8_t* DataStream     = (uint8_t*)BufferPtr;
	bool     BusSuspended   = USB_Host_IsBusSuspended();
    30d4:	f0 90 9e 00 	lds	r15, 0x009E
	uint8_t  ReturnStatus   = HOST_SENDCONTROL_Successful;
	uint16_t DataLen        = USB_ControlRequest.wLength;
    30d8:	c0 91 74 11 	lds	r28, 0x1174
    30dc:	d0 91 75 11 	lds	r29, 0x1175

	USB_Host_ResumeBus();
    30e0:	80 91 9e 00 	lds	r24, 0x009E
    30e4:	81 60       	ori	r24, 0x01	; 1
    30e6:	80 93 9e 00 	sts	0x009E, r24
	
	if ((ReturnStatus = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    30ea:	81 e0       	ldi	r24, 0x01	; 1
    30ec:	0b de       	rcall	.-1002   	; 0x2d04 <USB_Host_WaitMS>
    30ee:	28 2f       	mov	r18, r24
    30f0:	88 23       	and	r24, r24
    30f2:	09 f0       	breq	.+2      	; 0x30f6 <USB_Host_SendControlRequest+0x30>
    30f4:	e7 c0       	rjmp	.+462    	; 0x32c4 <USB_Host_SendControlRequest+0x1fe>
	  goto End_Of_Control_Send;

	Pipe_SetPipeToken(PIPE_TOKEN_SETUP);
    30f6:	80 91 aa 00 	lds	r24, 0x00AA
    30fa:	8f 7c       	andi	r24, 0xCF	; 207
    30fc:	80 93 aa 00 	sts	0x00AA, r24
	Pipe_ClearErrorFlags();
    3100:	10 92 f5 00 	sts	0x00F5, r1

	Pipe_Unfreeze();
    3104:	80 91 a9 00 	lds	r24, 0x00A9
    3108:	8f 7b       	andi	r24, 0xBF	; 191
    310a:	80 93 a9 00 	sts	0x00A9, r24
    310e:	ee e6       	ldi	r30, 0x6E	; 110
    3110:	f1 e1       	ldi	r31, 0x11	; 17

	for (uint8_t HeaderByte = 0; HeaderByte < sizeof(USB_Request_Header_t); HeaderByte++)
	  Pipe_Write_Byte(*(HeaderStream++));
    3112:	81 91       	ld	r24, Z+
			 *  \param[in] Byte  Next byte to write into the the currently selected pipe's FIFO buffer
			 */
			static inline void Pipe_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_Byte(const uint8_t Byte)
			{
				UPDATX = Byte;
    3114:	80 93 af 00 	sts	0x00AF, r24
	Pipe_SetPipeToken(PIPE_TOKEN_SETUP);
	Pipe_ClearErrorFlags();

	Pipe_Unfreeze();

	for (uint8_t HeaderByte = 0; HeaderByte < sizeof(USB_Request_Header_t); HeaderByte++)
    3118:	81 e1       	ldi	r24, 0x11	; 17
    311a:	e6 37       	cpi	r30, 0x76	; 118
    311c:	f8 07       	cpc	r31, r24
    311e:	c9 f7       	brne	.-14     	; 0x3112 <USB_Host_SendControlRequest+0x4c>
	  Pipe_Write_Byte(*(HeaderStream++));

	Pipe_ClearSETUP();
    3120:	80 91 a6 00 	lds	r24, 0x00A6
    3124:	98 2f       	mov	r25, r24
    3126:	97 7f       	andi	r25, 0xF7	; 247
    3128:	90 93 a6 00 	sts	0x00A6, r25
    312c:	8f 77       	andi	r24, 0x7F	; 127
    312e:	80 93 a6 00 	sts	0x00A6, r24
	
	if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_SetupSent)) != HOST_SENDCONTROL_Successful)
    3132:	80 e0       	ldi	r24, 0x00	; 0
    3134:	9f df       	rcall	.-194    	; 0x3074 <USB_Host_WaitForIOS>
    3136:	28 2f       	mov	r18, r24
    3138:	88 23       	and	r24, r24
    313a:	09 f0       	breq	.+2      	; 0x313e <USB_Host_SendControlRequest+0x78>
    313c:	c3 c0       	rjmp	.+390    	; 0x32c4 <USB_Host_SendControlRequest+0x1fe>
	  goto End_Of_Control_Send;

	Pipe_Freeze();
    313e:	80 91 a9 00 	lds	r24, 0x00A9
    3142:	80 64       	ori	r24, 0x40	; 64
    3144:	80 93 a9 00 	sts	0x00A9, r24

	if ((ReturnStatus = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    3148:	81 e0       	ldi	r24, 0x01	; 1
    314a:	dc dd       	rcall	.-1096   	; 0x2d04 <USB_Host_WaitMS>
    314c:	28 2f       	mov	r18, r24
    314e:	88 23       	and	r24, r24
    3150:	09 f0       	breq	.+2      	; 0x3154 <USB_Host_SendControlRequest+0x8e>
    3152:	b8 c0       	rjmp	.+368    	; 0x32c4 <USB_Host_SendControlRequest+0x1fe>
#include "HostChapter9.h"

uint8_t USB_Host_SendControlRequest(void* BufferPtr)
{
	uint8_t* HeaderStream   = (uint8_t*)&USB_ControlRequest;
	uint8_t* DataStream     = (uint8_t*)BufferPtr;
    3154:	21 2f       	mov	r18, r17
    3156:	30 2f       	mov	r19, r16
    3158:	c9 01       	movw	r24, r18
    315a:	8c 01       	movw	r16, r24
	Pipe_Freeze();

	if ((ReturnStatus = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
	  goto End_Of_Control_Send;

	if ((USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_DIRECTION) == REQDIR_DEVICETOHOST)
    315c:	80 91 6e 11 	lds	r24, 0x116E
    3160:	87 ff       	sbrs	r24, 7
    3162:	5a c0       	rjmp	.+180    	; 0x3218 <USB_Host_SendControlRequest+0x152>
	{
		Pipe_SetPipeToken(PIPE_TOKEN_IN);
    3164:	80 91 aa 00 	lds	r24, 0x00AA
    3168:	8f 7c       	andi	r24, 0xCF	; 207
    316a:	80 61       	ori	r24, 0x10	; 16
    316c:	80 93 aa 00 	sts	0x00AA, r24
		
		if (DataStream != NULL)
    3170:	01 15       	cp	r16, r1
    3172:	11 05       	cpc	r17, r1
    3174:	89 f5       	brne	.+98     	; 0x31d8 <USB_Host_SendControlRequest+0x112>
    3176:	32 c0       	rjmp	.+100    	; 0x31dc <USB_Host_SendControlRequest+0x116>
		{
			while (DataLen)
			{
				Pipe_Unfreeze();
    3178:	80 91 a9 00 	lds	r24, 0x00A9
    317c:	8f 7b       	andi	r24, 0xBF	; 191
    317e:	80 93 a9 00 	sts	0x00A9, r24

				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_InReceived)) != HOST_SENDCONTROL_Successful)
    3182:	81 e0       	ldi	r24, 0x01	; 1
    3184:	77 df       	rcall	.-274    	; 0x3074 <USB_Host_WaitForIOS>
    3186:	28 2f       	mov	r18, r24
    3188:	88 23       	and	r24, r24
    318a:	09 f0       	breq	.+2      	; 0x318e <USB_Host_SendControlRequest+0xc8>
    318c:	9b c0       	rjmp	.+310    	; 0x32c4 <USB_Host_SendControlRequest+0x1fe>
				  goto End_Of_Control_Send;
							
				if (!(Pipe_BytesInPipe()))
    318e:	80 91 f6 00 	lds	r24, 0x00F6
    3192:	90 91 f7 00 	lds	r25, 0x00F7
    3196:	89 2b       	or	r24, r25
    3198:	49 f4       	brne	.+18     	; 0x31ac <USB_Host_SendControlRequest+0xe6>
    319a:	c0 e0       	ldi	r28, 0x00	; 0
    319c:	d0 e0       	ldi	r29, 0x00	; 0
    319e:	06 c0       	rjmp	.+12     	; 0x31ac <USB_Host_SendControlRequest+0xe6>
			 *  \return Next byte in the currently selected pipe's FIFO buffer
			 */
			static inline uint8_t Pipe_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_Read_Byte(void)
			{
				return UPDATX;
    31a0:	80 91 af 00 	lds	r24, 0x00AF
				  DataLen = 0;
				
				while (Pipe_BytesInPipe() && DataLen)
				{
					*(DataStream++) = Pipe_Read_Byte();
    31a4:	f8 01       	movw	r30, r16
    31a6:	81 93       	st	Z+, r24
    31a8:	8f 01       	movw	r16, r30
					DataLen--;
    31aa:	21 97       	sbiw	r28, 0x01	; 1
				  goto End_Of_Control_Send;
							
				if (!(Pipe_BytesInPipe()))
				  DataLen = 0;
				
				while (Pipe_BytesInPipe() && DataLen)
    31ac:	80 91 f6 00 	lds	r24, 0x00F6
    31b0:	90 91 f7 00 	lds	r25, 0x00F7
    31b4:	89 2b       	or	r24, r25
    31b6:	11 f0       	breq	.+4      	; 0x31bc <USB_Host_SendControlRequest+0xf6>
    31b8:	20 97       	sbiw	r28, 0x00	; 0
    31ba:	91 f7       	brne	.-28     	; 0x31a0 <USB_Host_SendControlRequest+0xda>
				{
					*(DataStream++) = Pipe_Read_Byte();
					DataLen--;
				}

				Pipe_Freeze();
    31bc:	80 91 a9 00 	lds	r24, 0x00A9
    31c0:	80 64       	ori	r24, 0x40	; 64
    31c2:	80 93 a9 00 	sts	0x00A9, r24
				Pipe_ClearIN();
    31c6:	80 91 a6 00 	lds	r24, 0x00A6
    31ca:	98 2f       	mov	r25, r24
    31cc:	9e 7f       	andi	r25, 0xFE	; 254
    31ce:	90 93 a6 00 	sts	0x00A6, r25
    31d2:	8f 77       	andi	r24, 0x7F	; 127
    31d4:	80 93 a6 00 	sts	0x00A6, r24
	{
		Pipe_SetPipeToken(PIPE_TOKEN_IN);
		
		if (DataStream != NULL)
		{
			while (DataLen)
    31d8:	20 97       	sbiw	r28, 0x00	; 0
    31da:	71 f6       	brne	.-100    	; 0x3178 <USB_Host_SendControlRequest+0xb2>
				Pipe_Freeze();
				Pipe_ClearIN();
			}
		}

		Pipe_SetPipeToken(PIPE_TOKEN_OUT);
    31dc:	80 91 aa 00 	lds	r24, 0x00AA
    31e0:	8f 7c       	andi	r24, 0xCF	; 207
    31e2:	80 62       	ori	r24, 0x20	; 32
    31e4:	80 93 aa 00 	sts	0x00AA, r24
		Pipe_Unfreeze();
    31e8:	80 91 a9 00 	lds	r24, 0x00A9
    31ec:	8f 7b       	andi	r24, 0xBF	; 191
    31ee:	80 93 a9 00 	sts	0x00A9, r24
		
		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    31f2:	82 e0       	ldi	r24, 0x02	; 2
    31f4:	3f df       	rcall	.-386    	; 0x3074 <USB_Host_WaitForIOS>
    31f6:	28 2f       	mov	r18, r24
    31f8:	88 23       	and	r24, r24
    31fa:	09 f0       	breq	.+2      	; 0x31fe <USB_Host_SendControlRequest+0x138>
    31fc:	63 c0       	rjmp	.+198    	; 0x32c4 <USB_Host_SendControlRequest+0x1fe>
		  goto End_Of_Control_Send;

		Pipe_ClearOUT();
    31fe:	80 91 a6 00 	lds	r24, 0x00A6
    3202:	98 2f       	mov	r25, r24
    3204:	9b 7f       	andi	r25, 0xFB	; 251
    3206:	90 93 a6 00 	sts	0x00A6, r25
    320a:	8f 77       	andi	r24, 0x7F	; 127
    320c:	80 93 a6 00 	sts	0x00A6, r24

		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    3210:	82 e0       	ldi	r24, 0x02	; 2
    3212:	30 df       	rcall	.-416    	; 0x3074 <USB_Host_WaitForIOS>
    3214:	28 2f       	mov	r18, r24
    3216:	56 c0       	rjmp	.+172    	; 0x32c4 <USB_Host_SendControlRequest+0x1fe>
		  goto End_Of_Control_Send;
	}
	else
	{
		if (DataStream != NULL)
    3218:	01 15       	cp	r16, r1
    321a:	11 05       	cpc	r17, r1
    321c:	d1 f1       	breq	.+116    	; 0x3292 <USB_Host_SendControlRequest+0x1cc>
		{
			Pipe_SetPipeToken(PIPE_TOKEN_OUT);
    321e:	80 91 aa 00 	lds	r24, 0x00AA
    3222:	8f 7c       	andi	r24, 0xCF	; 207
    3224:	80 62       	ori	r24, 0x20	; 32
    3226:	80 93 aa 00 	sts	0x00AA, r24
			Pipe_Unfreeze();	
    322a:	80 91 a9 00 	lds	r24, 0x00A9
    322e:	8f 7b       	andi	r24, 0xBF	; 191
    3230:	80 93 a9 00 	sts	0x00A9, r24
    3234:	22 c0       	rjmp	.+68     	; 0x327a <USB_Host_SendControlRequest+0x1b4>

			while (DataLen)
			{
				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    3236:	82 e0       	ldi	r24, 0x02	; 2
    3238:	1d df       	rcall	.-454    	; 0x3074 <USB_Host_WaitForIOS>
    323a:	28 2f       	mov	r18, r24
    323c:	88 23       	and	r24, r24
    323e:	09 f0       	breq	.+2      	; 0x3242 <USB_Host_SendControlRequest+0x17c>
    3240:	41 c0       	rjmp	.+130    	; 0x32c4 <USB_Host_SendControlRequest+0x1fe>
				  goto End_Of_Control_Send;

				while (DataLen && (Pipe_BytesInPipe() < USB_ControlPipeSize))
    3242:	80 91 70 06 	lds	r24, 0x0670
    3246:	28 2f       	mov	r18, r24
    3248:	30 e0       	ldi	r19, 0x00	; 0
    324a:	07 c0       	rjmp	.+14     	; 0x325a <USB_Host_SendControlRequest+0x194>
				{					
					Pipe_Write_Byte(*(DataStream++));
    324c:	f8 01       	movw	r30, r16
    324e:	81 91       	ld	r24, Z+
    3250:	8f 01       	movw	r16, r30
			 *  \param[in] Byte  Next byte to write into the the currently selected pipe's FIFO buffer
			 */
			static inline void Pipe_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_Byte(const uint8_t Byte)
			{
				UPDATX = Byte;
    3252:	80 93 af 00 	sts	0x00AF, r24
					DataLen--;
    3256:	21 97       	sbiw	r28, 0x01	; 1
			while (DataLen)
			{
				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
				  goto End_Of_Control_Send;

				while (DataLen && (Pipe_BytesInPipe() < USB_ControlPipeSize))
    3258:	39 f0       	breq	.+14     	; 0x3268 <USB_Host_SendControlRequest+0x1a2>
    325a:	80 91 f6 00 	lds	r24, 0x00F6
    325e:	90 91 f7 00 	lds	r25, 0x00F7
    3262:	82 17       	cp	r24, r18
    3264:	93 07       	cpc	r25, r19
    3266:	90 f3       	brcs	.-28     	; 0x324c <USB_Host_SendControlRequest+0x186>
				{					
					Pipe_Write_Byte(*(DataStream++));
					DataLen--;
				}
				
				Pipe_ClearOUT();
    3268:	80 91 a6 00 	lds	r24, 0x00A6
    326c:	98 2f       	mov	r25, r24
    326e:	9b 7f       	andi	r25, 0xFB	; 251
    3270:	90 93 a6 00 	sts	0x00A6, r25
    3274:	8f 77       	andi	r24, 0x7F	; 127
    3276:	80 93 a6 00 	sts	0x00A6, r24
		if (DataStream != NULL)
		{
			Pipe_SetPipeToken(PIPE_TOKEN_OUT);
			Pipe_Unfreeze();	

			while (DataLen)
    327a:	20 97       	sbiw	r28, 0x00	; 0
    327c:	e1 f6       	brne	.-72     	; 0x3236 <USB_Host_SendControlRequest+0x170>
				}
				
				Pipe_ClearOUT();
			}

			if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    327e:	82 e0       	ldi	r24, 0x02	; 2
    3280:	f9 de       	rcall	.-526    	; 0x3074 <USB_Host_WaitForIOS>
    3282:	28 2f       	mov	r18, r24
    3284:	88 23       	and	r24, r24
    3286:	f1 f4       	brne	.+60     	; 0x32c4 <USB_Host_SendControlRequest+0x1fe>
			  goto End_Of_Control_Send;

			Pipe_Freeze();
    3288:	80 91 a9 00 	lds	r24, 0x00A9
    328c:	80 64       	ori	r24, 0x40	; 64
    328e:	80 93 a9 00 	sts	0x00A9, r24
		}
		
		Pipe_SetPipeToken(PIPE_TOKEN_IN);
    3292:	80 91 aa 00 	lds	r24, 0x00AA
    3296:	8f 7c       	andi	r24, 0xCF	; 207
    3298:	80 61       	ori	r24, 0x10	; 16
    329a:	80 93 aa 00 	sts	0x00AA, r24
		Pipe_Unfreeze();
    329e:	80 91 a9 00 	lds	r24, 0x00A9
    32a2:	8f 7b       	andi	r24, 0xBF	; 191
    32a4:	80 93 a9 00 	sts	0x00A9, r24

		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_InReceived)) != HOST_SENDCONTROL_Successful)
    32a8:	81 e0       	ldi	r24, 0x01	; 1
    32aa:	e4 de       	rcall	.-568    	; 0x3074 <USB_Host_WaitForIOS>
    32ac:	28 2f       	mov	r18, r24
    32ae:	88 23       	and	r24, r24
    32b0:	49 f4       	brne	.+18     	; 0x32c4 <USB_Host_SendControlRequest+0x1fe>
		  goto End_Of_Control_Send;

		Pipe_ClearIN();
    32b2:	80 91 a6 00 	lds	r24, 0x00A6
    32b6:	98 2f       	mov	r25, r24
    32b8:	9e 7f       	andi	r25, 0xFE	; 254
    32ba:	90 93 a6 00 	sts	0x00A6, r25
    32be:	8f 77       	andi	r24, 0x7F	; 127
    32c0:	80 93 a6 00 	sts	0x00A6, r24
	}

End_Of_Control_Send:
	Pipe_Freeze();
    32c4:	80 91 a9 00 	lds	r24, 0x00A9
    32c8:	80 64       	ori	r24, 0x40	; 64
    32ca:	80 93 a9 00 	sts	0x00A9, r24
	
	if (BusSuspended)
    32ce:	f0 fc       	sbrc	r15, 0
    32d0:	05 c0       	rjmp	.+10     	; 0x32dc <USB_Host_SendControlRequest+0x216>
	  USB_Host_SuspendBus();
    32d2:	80 91 9e 00 	lds	r24, 0x009E
    32d6:	8e 7f       	andi	r24, 0xFE	; 254
    32d8:	80 93 9e 00 	sts	0x009E, r24

	Pipe_ResetPipe(PIPE_CONTROLPIPE);
    32dc:	81 e0       	ldi	r24, 0x01	; 1
    32de:	80 93 a8 00 	sts	0x00A8, r24
    32e2:	10 92 a8 00 	sts	0x00A8, r1

	return ReturnStatus;
}
    32e6:	82 2f       	mov	r24, r18
    32e8:	df 91       	pop	r29
    32ea:	cf 91       	pop	r28
    32ec:	1f 91       	pop	r17
    32ee:	0f 91       	pop	r16
    32f0:	ff 90       	pop	r15
    32f2:	08 95       	ret

000032f4 <USB_ResetInterface>:
	#endif
}

void USB_ResetInterface(void)
{
	USB_INT_DisableAllInterrupts();
    32f4:	95 d1       	rcall	.+810    	; 0x3620 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    32f6:	9e d1       	rcall	.+828    	; 0x3634 <USB_INT_ClearAllInterrupts>
	
	#if defined(USB_CAN_BE_HOST)
	USB_HostState   = HOST_STATE_Unattached;
    32f8:	82 e0       	ldi	r24, 0x02	; 2
    32fa:	80 93 76 11 	sts	0x1176, r24
	{
		#if defined(USB_SERIES_4_AVR)
		PLLFRQ = ((1 << PLLUSB) | (1 << PDIV3) | (1 << PDIV1));
		#endif

		USB_PLL_On();
    32fe:	8c e0       	ldi	r24, 0x0C	; 12
    3300:	89 bd       	out	0x29, r24	; 41
    3302:	89 b5       	in	r24, 0x29	; 41
    3304:	82 60       	ori	r24, 0x02	; 2
    3306:	89 bd       	out	0x29, r24	; 41
		while (!(USB_PLL_IsReady()));
    3308:	09 b4       	in	r0, 0x29	; 41
    330a:	00 fe       	sbrs	r0, 0
    330c:	fd cf       	rjmp	.-6      	; 0x3308 <USB_ResetInterface+0x14>
	}
	
	USB_Controller_Reset();
    330e:	80 91 d8 00 	lds	r24, 0x00D8
    3312:	98 2f       	mov	r25, r24
    3314:	9f 77       	andi	r25, 0x7F	; 127
    3316:	90 93 d8 00 	sts	0x00D8, r25
    331a:	80 68       	ori	r24, 0x80	; 128
    331c:	80 93 d8 00 	sts	0x00D8, r24
		USB_CurrentMode = USB_GetUSBModeFromUID();
	}
	#endif
		
	if (!(USB_Options & USB_OPT_REG_DISABLED))
	  USB_REG_On();
    3320:	80 91 d7 00 	lds	r24, 0x00D7
    3324:	81 60       	ori	r24, 0x01	; 1
    3326:	80 93 d7 00 	sts	0x00D7, r24
	else
	  USB_REG_Off();
	
	USB_CLK_Unfreeze();
    332a:	80 91 d8 00 	lds	r24, 0x00D8
    332e:	8f 7d       	andi	r24, 0xDF	; 223
    3330:	80 93 d8 00 	sts	0x00D8, r24
			#endif
		}
	}
	#endif

	USB_Attach();
    3334:	80 91 e0 00 	lds	r24, 0x00E0
    3338:	8e 7f       	andi	r24, 0xFE	; 254
    333a:	80 93 e0 00 	sts	0x00E0, r24

		#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
		USB_INT_Enable(USB_INT_VBUS);
		#endif
	#elif defined(USB_HOST_ONLY)
	USB_Host_HostMode_On();
    333e:	80 91 d8 00 	lds	r24, 0x00D8
    3342:	80 64       	ori	r24, 0x40	; 64
    3344:	80 93 d8 00 	sts	0x00D8, r24
	
	USB_Host_VBUS_Auto_Off();
    3348:	80 91 dd 00 	lds	r24, 0x00DD
    334c:	81 60       	ori	r24, 0x01	; 1
    334e:	80 93 dd 00 	sts	0x00DD, r24
	USB_OTGPAD_Off();
    3352:	80 91 d8 00 	lds	r24, 0x00D8
    3356:	8f 7e       	andi	r24, 0xEF	; 239
    3358:	80 93 d8 00 	sts	0x00D8, r24

	USB_Host_VBUS_Manual_Enable();
    335c:	80 91 dd 00 	lds	r24, 0x00DD
    3360:	84 60       	ori	r24, 0x04	; 4
    3362:	80 93 dd 00 	sts	0x00DD, r24
    3366:	80 91 d7 00 	lds	r24, 0x00D7
    336a:	8f 7e       	andi	r24, 0xEF	; 239
    336c:	80 93 d7 00 	sts	0x00D7, r24
    3370:	6f 9a       	sbi	0x0d, 7	; 13
	USB_Host_VBUS_Manual_On();
    3372:	77 9a       	sbi	0x0e, 7	; 14
	
	USB_INT_Enable(USB_INT_SRPI);
    3374:	80 91 de 00 	lds	r24, 0x00DE
    3378:	81 60       	ori	r24, 0x01	; 1
    337a:	80 93 de 00 	sts	0x00DE, r24
	USB_INT_Enable(USB_INT_BCERRI);
    337e:	80 91 de 00 	lds	r24, 0x00DE
    3382:	84 60       	ori	r24, 0x04	; 4
    3384:	80 93 de 00 	sts	0x00DE, r24
		
		USB_INT_Enable(USB_INT_SRPI);
		USB_INT_Enable(USB_INT_BCERRI);
	}
	#endif
}
    3388:	08 95       	ret

0000338a <USB_ShutDown>:
	sei();
}

void USB_ShutDown(void)
{
	USB_ResetInterface();
    338a:	b4 df       	rcall	.-152    	; 0x32f4 <USB_ResetInterface>
	USB_Detach();
    338c:	e0 ee       	ldi	r30, 0xE0	; 224
    338e:	f0 e0       	ldi	r31, 0x00	; 0
    3390:	80 81       	ld	r24, Z
    3392:	81 60       	ori	r24, 0x01	; 1
    3394:	80 83       	st	Z, r24
	USB_Controller_Disable();
    3396:	e8 ed       	ldi	r30, 0xD8	; 216
    3398:	f0 e0       	ldi	r31, 0x00	; 0
    339a:	80 81       	ld	r24, Z
    339c:	8f 77       	andi	r24, 0x7F	; 127
    339e:	80 83       	st	Z, r24
	
	if (!(USB_Options & USB_OPT_MANUAL_PLL))
	  USB_PLL_Off();
    33a0:	19 bc       	out	0x29, r1	; 41
	
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USB_OTGPAD_Off();
    33a2:	80 81       	ld	r24, Z
    33a4:	8f 7e       	andi	r24, 0xEF	; 239
    33a6:	80 83       	st	Z, r24

	#if defined(USB_CAN_BE_BOTH)
	UHWCON &= ~(1 << UIDE);
	#endif

	USB_IsInitialized = false;
    33a8:	10 92 6d 11 	sts	0x116D, r1

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_NONE;
	#endif
}
    33ac:	08 95       	ret

000033ae <USB_Init>:
	#if !defined(USE_STATIC_OPTIONS)
	USB_Options = Options;
	#endif

	#if defined(USB_CAN_BE_HOST)
	USB_ControlPipeSize = PIPE_CONTROLPIPE_DEFAULT_SIZE;
    33ae:	80 e4       	ldi	r24, 0x40	; 64
    33b0:	80 93 70 06 	sts	0x0670, r24
	#endif
	
	#if defined(USB_DEVICE_ONLY) && (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	UHWCON |= (1 << UIMOD);
	#elif defined(USB_HOST_ONLY)
	UHWCON &= ~(1 << UIMOD);
    33b4:	e7 ed       	ldi	r30, 0xD7	; 215
    33b6:	f0 e0       	ldi	r31, 0x00	; 0
    33b8:	80 81       	ld	r24, Z
    33ba:	8f 77       	andi	r24, 0x7F	; 127
    33bc:	80 83       	st	Z, r24
		EVENT_USB_InitFailure(USB_INITERROR_NoUSBModeSpecified);
		return;
	}
	#endif
	
	USB_ResetInterface();
    33be:	9a df       	rcall	.-204    	; 0x32f4 <USB_ResetInterface>

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USB_OTGPAD_On();
    33c0:	e8 ed       	ldi	r30, 0xD8	; 216
    33c2:	f0 e0       	ldi	r31, 0x00	; 0
    33c4:	80 81       	ld	r24, Z
    33c6:	80 61       	ori	r24, 0x10	; 16
    33c8:	80 83       	st	Z, r24
	#endif

	USB_IsInitialized = true;
    33ca:	81 e0       	ldi	r24, 0x01	; 1
    33cc:	80 93 6d 11 	sts	0x116D, r24

	sei();
    33d0:	78 94       	sei
}
    33d2:	08 95       	ret

000033d4 <Pipe_ConfigurePipe>:

uint8_t USB_ControlPipeSize = PIPE_CONTROLPIPE_DEFAULT_SIZE;

bool Pipe_ConfigurePipe(const uint8_t Number, const uint8_t Type, const uint8_t Token, const uint8_t EndpointNumber,
						const uint16_t Size, const uint8_t Banks)
{
    33d4:	ef 92       	push	r14
    33d6:	0f 93       	push	r16
    33d8:	1f 93       	push	r17
    33da:	9e 2d       	mov	r25, r14
	Pipe_SelectPipe(Number);
    33dc:	80 93 a7 00 	sts	0x00A7, r24
	Pipe_EnablePipe();
    33e0:	80 91 a9 00 	lds	r24, 0x00A9
    33e4:	81 60       	ori	r24, 0x01	; 1
    33e6:	80 93 a9 00 	sts	0x00A9, r24

	UPCFG1X = 0;
    33ea:	10 92 ab 00 	sts	0x00AB, r1
	
	UPCFG0X = ((Type << EPTYPE0) | Token | ((EndpointNumber & PIPE_EPNUM_MASK) << PEPNUM0));
    33ee:	62 95       	swap	r22
    33f0:	66 0f       	add	r22, r22
    33f2:	66 0f       	add	r22, r22
    33f4:	60 7c       	andi	r22, 0xC0	; 192
    33f6:	64 2b       	or	r22, r20
    33f8:	2f 70       	andi	r18, 0x0F	; 15
    33fa:	62 2b       	or	r22, r18
    33fc:	60 93 aa 00 	sts	0x00AA, r22

		/* Inline Functions: */
			static inline uint8_t Pipe_BytesToEPSizeMask(uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_BytesToEPSizeMask(uint16_t Bytes)
			{
				if (Bytes <= 8)
    3400:	09 30       	cpi	r16, 0x09	; 9
    3402:	11 05       	cpc	r17, r1
    3404:	10 f4       	brcc	.+4      	; 0x340a <Pipe_ConfigurePipe+0x36>
    3406:	80 e0       	ldi	r24, 0x00	; 0
    3408:	15 c0       	rjmp	.+42     	; 0x3434 <Pipe_ConfigurePipe+0x60>
				  return (0 << EPSIZE0);
				else if (Bytes <= 16)
    340a:	01 31       	cpi	r16, 0x11	; 17
    340c:	11 05       	cpc	r17, r1
    340e:	10 f4       	brcc	.+4      	; 0x3414 <Pipe_ConfigurePipe+0x40>
    3410:	80 e1       	ldi	r24, 0x10	; 16
    3412:	10 c0       	rjmp	.+32     	; 0x3434 <Pipe_ConfigurePipe+0x60>
				  return (1 << EPSIZE0);
				else if (Bytes <= 32)
    3414:	01 32       	cpi	r16, 0x21	; 33
    3416:	11 05       	cpc	r17, r1
    3418:	10 f4       	brcc	.+4      	; 0x341e <Pipe_ConfigurePipe+0x4a>
    341a:	80 e2       	ldi	r24, 0x20	; 32
    341c:	0b c0       	rjmp	.+22     	; 0x3434 <Pipe_ConfigurePipe+0x60>
				  return (2 << EPSIZE0);
				else if (Bytes <= 64)
    341e:	01 34       	cpi	r16, 0x41	; 65
    3420:	11 05       	cpc	r17, r1
    3422:	10 f4       	brcc	.+4      	; 0x3428 <Pipe_ConfigurePipe+0x54>
    3424:	80 e3       	ldi	r24, 0x30	; 48
    3426:	06 c0       	rjmp	.+12     	; 0x3434 <Pipe_ConfigurePipe+0x60>
				  return (3 << EPSIZE0);
				else if (Bytes <= 128)
    3428:	01 38       	cpi	r16, 0x81	; 129
    342a:	11 05       	cpc	r17, r1
    342c:	10 f0       	brcs	.+4      	; 0x3432 <Pipe_ConfigurePipe+0x5e>
    342e:	80 e5       	ldi	r24, 0x50	; 80
    3430:	01 c0       	rjmp	.+2      	; 0x3434 <Pipe_ConfigurePipe+0x60>
    3432:	80 e4       	ldi	r24, 0x40	; 64
	UPCFG1X = ((1 << ALLOC) | Banks | Pipe_BytesToEPSizeMask(Size));
    3434:	92 60       	ori	r25, 0x02	; 2
    3436:	89 2b       	or	r24, r25
    3438:	80 93 ab 00 	sts	0x00AB, r24

	Pipe_SetInfiniteINRequests();
    343c:	80 91 a9 00 	lds	r24, 0x00A9
    3440:	80 62       	ori	r24, 0x20	; 32
    3442:	80 93 a9 00 	sts	0x00A9, r24

	return Pipe_IsConfigured();
    3446:	80 91 ac 00 	lds	r24, 0x00AC
}
    344a:	88 1f       	adc	r24, r24
    344c:	88 27       	eor	r24, r24
    344e:	88 1f       	adc	r24, r24
    3450:	1f 91       	pop	r17
    3452:	0f 91       	pop	r16
    3454:	ef 90       	pop	r14
    3456:	08 95       	ret

00003458 <Pipe_ClearPipes>:

void Pipe_ClearPipes(void)
{
	UPINT = 0;
    3458:	10 92 f8 00 	sts	0x00F8, r1
    345c:	20 e0       	ldi	r18, 0x00	; 0
    345e:	30 e0       	ldi	r19, 0x00	; 0

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
	{
		Pipe_ResetPipe(PNum);
    3460:	41 e0       	ldi	r20, 0x01	; 1
    3462:	50 e0       	ldi	r21, 0x00	; 0
    3464:	ca 01       	movw	r24, r20
    3466:	02 2e       	mov	r0, r18
    3468:	02 c0       	rjmp	.+4      	; 0x346e <Pipe_ClearPipes+0x16>
    346a:	88 0f       	add	r24, r24
    346c:	99 1f       	adc	r25, r25
    346e:	0a 94       	dec	r0
    3470:	e2 f7       	brpl	.-8      	; 0x346a <Pipe_ClearPipes+0x12>
    3472:	80 93 a8 00 	sts	0x00A8, r24
    3476:	10 92 a8 00 	sts	0x00A8, r1
		Pipe_SelectPipe(PNum);
    347a:	20 93 a7 00 	sts	0x00A7, r18
		UPIENX = 0;
    347e:	10 92 ae 00 	sts	0x00AE, r1
		UPINTX = 0;
    3482:	10 92 a6 00 	sts	0x00A6, r1
		Pipe_ClearError();
    3486:	80 91 a6 00 	lds	r24, 0x00A6
    348a:	8f 7e       	andi	r24, 0xEF	; 239
    348c:	80 93 a6 00 	sts	0x00A6, r24
		Pipe_ClearErrorFlags();
    3490:	10 92 f5 00 	sts	0x00F5, r1
		Pipe_DeallocateMemory();
    3494:	80 91 ab 00 	lds	r24, 0x00AB
    3498:	8d 7f       	andi	r24, 0xFD	; 253
    349a:	80 93 ab 00 	sts	0x00AB, r24
		Pipe_DisablePipe();
    349e:	80 91 a9 00 	lds	r24, 0x00A9
    34a2:	8e 7f       	andi	r24, 0xFE	; 254
    34a4:	80 93 a9 00 	sts	0x00A9, r24
    34a8:	2f 5f       	subi	r18, 0xFF	; 255
    34aa:	3f 4f       	sbci	r19, 0xFF	; 255

void Pipe_ClearPipes(void)
{
	UPINT = 0;

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    34ac:	27 30       	cpi	r18, 0x07	; 7
    34ae:	31 05       	cpc	r19, r1
    34b0:	c9 f6       	brne	.-78     	; 0x3464 <Pipe_ClearPipes+0xc>
		Pipe_ClearError();
		Pipe_ClearErrorFlags();
		Pipe_DeallocateMemory();
		Pipe_DisablePipe();
	}
}
    34b2:	08 95       	ret

000034b4 <Pipe_IsEndpointBound>:

bool Pipe_IsEndpointBound(const uint8_t EndpointAddress)
{
	uint8_t PrevPipeNumber = Pipe_GetCurrentPipe();
    34b4:	30 91 a7 00 	lds	r19, 0x00A7
    34b8:	20 e0       	ldi	r18, 0x00	; 0

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
	{
		Pipe_SelectPipe(PNum);
		
		if (Pipe_IsConfigured() && (Pipe_BoundEndpointNumber() == (EndpointAddress & PIPE_EPNUM_MASK)))
    34ba:	48 2f       	mov	r20, r24
    34bc:	50 e0       	ldi	r21, 0x00	; 0
{
	uint8_t PrevPipeNumber = Pipe_GetCurrentPipe();

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
	{
		Pipe_SelectPipe(PNum);
    34be:	20 93 a7 00 	sts	0x00A7, r18
		
		if (Pipe_IsConfigured() && (Pipe_BoundEndpointNumber() == (EndpointAddress & PIPE_EPNUM_MASK)))
    34c2:	80 91 ac 00 	lds	r24, 0x00AC
    34c6:	87 ff       	sbrs	r24, 7
    34c8:	0b c0       	rjmp	.+22     	; 0x34e0 <Pipe_IsEndpointBound+0x2c>
    34ca:	80 91 aa 00 	lds	r24, 0x00AA
    34ce:	90 e0       	ldi	r25, 0x00	; 0
    34d0:	84 27       	eor	r24, r20
    34d2:	95 27       	eor	r25, r21
    34d4:	8f 70       	andi	r24, 0x0F	; 15
    34d6:	90 70       	andi	r25, 0x00	; 0
    34d8:	89 2b       	or	r24, r25
    34da:	11 f4       	brne	.+4      	; 0x34e0 <Pipe_IsEndpointBound+0x2c>
    34dc:	81 e0       	ldi	r24, 0x01	; 1
    34de:	08 95       	ret

bool Pipe_IsEndpointBound(const uint8_t EndpointAddress)
{
	uint8_t PrevPipeNumber = Pipe_GetCurrentPipe();

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    34e0:	2f 5f       	subi	r18, 0xFF	; 255
    34e2:	27 30       	cpi	r18, 0x07	; 7
    34e4:	61 f7       	brne	.-40     	; 0x34be <Pipe_IsEndpointBound+0xa>
	}
}

bool Pipe_IsEndpointBound(const uint8_t EndpointAddress)
{
	uint8_t PrevPipeNumber = Pipe_GetCurrentPipe();
    34e6:	37 70       	andi	r19, 0x07	; 7
		
		if (Pipe_IsConfigured() && (Pipe_BoundEndpointNumber() == (EndpointAddress & PIPE_EPNUM_MASK)))
		  return true;
	}
	
	Pipe_SelectPipe(PrevPipeNumber);
    34e8:	30 93 a7 00 	sts	0x00A7, r19
    34ec:	80 e0       	ldi	r24, 0x00	; 0
	return false;
}
    34ee:	08 95       	ret

000034f0 <Pipe_WaitUntilReady>:

uint8_t Pipe_WaitUntilReady(void)
{
    34f0:	94 e6       	ldi	r25, 0x64	; 100
	uint16_t TimeoutMSRem = USB_STREAM_TIMEOUT_MS;
	#endif
	
	for (;;)
	{
		if (Pipe_GetPipeToken() == PIPE_TOKEN_IN)
    34f2:	80 91 aa 00 	lds	r24, 0x00AA
    34f6:	80 73       	andi	r24, 0x30	; 48
    34f8:	80 31       	cpi	r24, 0x10	; 16
    34fa:	29 f4       	brne	.+10     	; 0x3506 <Pipe_WaitUntilReady+0x16>
		{
			if (Pipe_IsINReceived())
    34fc:	80 91 a6 00 	lds	r24, 0x00A6
    3500:	80 ff       	sbrs	r24, 0
    3502:	05 c0       	rjmp	.+10     	; 0x350e <Pipe_WaitUntilReady+0x1e>
    3504:	1d c0       	rjmp	.+58     	; 0x3540 <Pipe_WaitUntilReady+0x50>
			  return PIPE_READYWAIT_NoError;
		}
		else
		{
			if (Pipe_IsOUTReady())
    3506:	80 91 a6 00 	lds	r24, 0x00A6
    350a:	82 fd       	sbrc	r24, 2
    350c:	19 c0       	rjmp	.+50     	; 0x3540 <Pipe_WaitUntilReady+0x50>
			  return PIPE_READYWAIT_NoError;		
		}

		if (Pipe_IsStalled())
    350e:	80 91 a6 00 	lds	r24, 0x00A6
    3512:	81 ff       	sbrs	r24, 1
    3514:	02 c0       	rjmp	.+4      	; 0x351a <Pipe_WaitUntilReady+0x2a>
    3516:	81 e0       	ldi	r24, 0x01	; 1
    3518:	08 95       	ret
		  return PIPE_READYWAIT_PipeStalled;
		else if (USB_HostState == HOST_STATE_Unattached)
    351a:	80 91 76 11 	lds	r24, 0x1176
    351e:	82 30       	cpi	r24, 0x02	; 2
    3520:	81 f0       	breq	.+32     	; 0x3542 <Pipe_WaitUntilReady+0x52>
		  return PIPE_READYWAIT_DeviceDisconnected;
			  
		if (USB_INT_HasOccurred(USB_INT_HSOFI))
    3522:	80 91 9f 00 	lds	r24, 0x009F
    3526:	85 ff       	sbrs	r24, 5
    3528:	e4 cf       	rjmp	.-56     	; 0x34f2 <Pipe_WaitUntilReady+0x2>
		{
			USB_INT_Clear(USB_INT_HSOFI);
    352a:	80 91 9f 00 	lds	r24, 0x009F
    352e:	8f 7d       	andi	r24, 0xDF	; 223
    3530:	80 93 9f 00 	sts	0x009F, r24

			if (!(TimeoutMSRem--))
    3534:	99 23       	and	r25, r25
    3536:	11 f4       	brne	.+4      	; 0x353c <Pipe_WaitUntilReady+0x4c>
    3538:	83 e0       	ldi	r24, 0x03	; 3
    353a:	08 95       	ret
    353c:	91 50       	subi	r25, 0x01	; 1
    353e:	d9 cf       	rjmp	.-78     	; 0x34f2 <Pipe_WaitUntilReady+0x2>
    3540:	80 e0       	ldi	r24, 0x00	; 0
			  return PIPE_READYWAIT_Timeout;
		}
	}
}
    3542:	08 95       	ret

00003544 <Pipe_Write_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer, uint16_t Length __CALLBACK_PARAM)
{
    3544:	ff 92       	push	r15
    3546:	0f 93       	push	r16
    3548:	1f 93       	push	r17
    354a:	cf 93       	push	r28
    354c:	df 93       	push	r29
    354e:	18 2f       	mov	r17, r24
    3550:	09 2f       	mov	r16, r25
    3552:	eb 01       	movw	r28, r22
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint8_t  ErrorCode;
	
	Pipe_SetPipeToken(TEMPLATE_TOKEN);
    3554:	80 91 aa 00 	lds	r24, 0x00AA
    3558:	8f 7c       	andi	r24, 0xCF	; 207
    355a:	80 62       	ori	r24, 0x20	; 32
    355c:	80 93 aa 00 	sts	0x00AA, r24

	if ((ErrorCode = Pipe_WaitUntilReady()))
    3560:	c7 df       	rcall	.-114    	; 0x34f0 <Pipe_WaitUntilReady>
    3562:	f8 2e       	mov	r15, r24
    3564:	88 23       	and	r24, r24
    3566:	f1 f4       	brne	.+60     	; 0x35a4 <Pipe_Write_Stream_LE+0x60>
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer, uint16_t Length __CALLBACK_PARAM)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    3568:	81 2f       	mov	r24, r17
    356a:	90 2f       	mov	r25, r16
    356c:	9c 01       	movw	r18, r24
    356e:	89 01       	movw	r16, r18
    3570:	17 c0       	rjmp	.+46     	; 0x35a0 <Pipe_Write_Stream_LE+0x5c>
	}
	#endif

	while (Length)
	{
		if (!(Pipe_IsReadWriteAllowed()))
    3572:	80 91 a6 00 	lds	r24, 0x00A6
    3576:	85 fd       	sbrc	r24, 5
    3578:	0d c0       	rjmp	.+26     	; 0x3594 <Pipe_Write_Stream_LE+0x50>
		{
			TEMPLATE_CLEAR_PIPE();
    357a:	80 91 a6 00 	lds	r24, 0x00A6
    357e:	98 2f       	mov	r25, r24
    3580:	9b 7f       	andi	r25, 0xFB	; 251
    3582:	90 93 a6 00 	sts	0x00A6, r25
    3586:	8f 77       	andi	r24, 0x7F	; 127
    3588:	80 93 a6 00 	sts	0x00A6, r24
			#if !defined(NO_STREAM_CALLBACKS)
			if ((Callback != NULL) && (Callback() == STREAMCALLBACK_Abort))
			  return PIPE_RWSTREAM_CallbackAborted;
			#endif

			if ((ErrorCode = Pipe_WaitUntilReady()))
    358c:	b1 df       	rcall	.-158    	; 0x34f0 <Pipe_WaitUntilReady>
    358e:	88 23       	and	r24, r24
    3590:	39 f0       	breq	.+14     	; 0x35a0 <Pipe_Write_Stream_LE+0x5c>
    3592:	09 c0       	rjmp	.+18     	; 0x35a6 <Pipe_Write_Stream_LE+0x62>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    3594:	f8 01       	movw	r30, r16
    3596:	81 91       	ld	r24, Z+
    3598:	8f 01       	movw	r16, r30
			 *  \param[in] Byte  Next byte to write into the the currently selected pipe's FIFO buffer
			 */
			static inline void Pipe_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_Byte(const uint8_t Byte)
			{
				UPDATX = Byte;
    359a:	80 93 af 00 	sts	0x00AF, r24
			Length--;
    359e:	21 97       	sbiw	r28, 0x01	; 1
				} while (Length >= 8);	
		}
	}
	#endif

	while (Length)
    35a0:	20 97       	sbiw	r28, 0x00	; 0
    35a2:	39 f7       	brne	.-50     	; 0x3572 <Pipe_Write_Stream_LE+0x2e>
    35a4:	8f 2d       	mov	r24, r15
			Length--;
		}
	}
	
	return PIPE_RWSTREAM_NoError;
}
    35a6:	df 91       	pop	r29
    35a8:	cf 91       	pop	r28
    35aa:	1f 91       	pop	r17
    35ac:	0f 91       	pop	r16
    35ae:	ff 90       	pop	r15
    35b0:	08 95       	ret

000035b2 <Pipe_Read_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer, uint16_t Length __CALLBACK_PARAM)
{
    35b2:	ff 92       	push	r15
    35b4:	0f 93       	push	r16
    35b6:	1f 93       	push	r17
    35b8:	cf 93       	push	r28
    35ba:	df 93       	push	r29
    35bc:	18 2f       	mov	r17, r24
    35be:	09 2f       	mov	r16, r25
    35c0:	eb 01       	movw	r28, r22
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint8_t  ErrorCode;
	
	Pipe_SetPipeToken(TEMPLATE_TOKEN);
    35c2:	80 91 aa 00 	lds	r24, 0x00AA
    35c6:	8f 7c       	andi	r24, 0xCF	; 207
    35c8:	80 61       	ori	r24, 0x10	; 16
    35ca:	80 93 aa 00 	sts	0x00AA, r24

	if ((ErrorCode = Pipe_WaitUntilReady()))
    35ce:	90 df       	rcall	.-224    	; 0x34f0 <Pipe_WaitUntilReady>
    35d0:	f8 2e       	mov	r15, r24
    35d2:	88 23       	and	r24, r24
    35d4:	f1 f4       	brne	.+60     	; 0x3612 <Pipe_Read_Stream_LE+0x60>
uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE Buffer, uint16_t Length __CALLBACK_PARAM)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    35d6:	81 2f       	mov	r24, r17
    35d8:	90 2f       	mov	r25, r16
    35da:	9c 01       	movw	r18, r24
    35dc:	89 01       	movw	r16, r18
    35de:	17 c0       	rjmp	.+46     	; 0x360e <Pipe_Read_Stream_LE+0x5c>
	}
	#endif

	while (Length)
	{
		if (!(Pipe_IsReadWriteAllowed()))
    35e0:	80 91 a6 00 	lds	r24, 0x00A6
    35e4:	85 fd       	sbrc	r24, 5
    35e6:	0d c0       	rjmp	.+26     	; 0x3602 <Pipe_Read_Stream_LE+0x50>
		{
			TEMPLATE_CLEAR_PIPE();
    35e8:	80 91 a6 00 	lds	r24, 0x00A6
    35ec:	98 2f       	mov	r25, r24
    35ee:	9e 7f       	andi	r25, 0xFE	; 254
    35f0:	90 93 a6 00 	sts	0x00A6, r25
    35f4:	8f 77       	andi	r24, 0x7F	; 127
    35f6:	80 93 a6 00 	sts	0x00A6, r24
			#if !defined(NO_STREAM_CALLBACKS)
			if ((Callback != NULL) && (Callback() == STREAMCALLBACK_Abort))
			  return PIPE_RWSTREAM_CallbackAborted;
			#endif

			if ((ErrorCode = Pipe_WaitUntilReady()))
    35fa:	7a df       	rcall	.-268    	; 0x34f0 <Pipe_WaitUntilReady>
    35fc:	88 23       	and	r24, r24
    35fe:	39 f0       	breq	.+14     	; 0x360e <Pipe_Read_Stream_LE+0x5c>
    3600:	09 c0       	rjmp	.+18     	; 0x3614 <Pipe_Read_Stream_LE+0x62>
			 *  \return Next byte in the currently selected pipe's FIFO buffer
			 */
			static inline uint8_t Pipe_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_Read_Byte(void)
			{
				return UPDATX;
    3602:	80 91 af 00 	lds	r24, 0x00AF
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    3606:	f8 01       	movw	r30, r16
    3608:	81 93       	st	Z+, r24
    360a:	8f 01       	movw	r16, r30
			Length--;
    360c:	21 97       	sbiw	r28, 0x01	; 1
				} while (Length >= 8);	
		}
	}
	#endif

	while (Length)
    360e:	20 97       	sbiw	r28, 0x00	; 0
    3610:	39 f7       	brne	.-50     	; 0x35e0 <Pipe_Read_Stream_LE+0x2e>
    3612:	8f 2d       	mov	r24, r15
			Length--;
		}
	}
	
	return PIPE_RWSTREAM_NoError;
}
    3614:	df 91       	pop	r29
    3616:	cf 91       	pop	r28
    3618:	1f 91       	pop	r17
    361a:	0f 91       	pop	r16
    361c:	ff 90       	pop	r15
    361e:	08 95       	ret

00003620 <USB_INT_DisableAllInterrupts>:
#include "USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));				
    3620:	e8 ed       	ldi	r30, 0xD8	; 216
    3622:	f0 e0       	ldi	r31, 0x00	; 0
    3624:	80 81       	ld	r24, Z
    3626:	8c 7f       	andi	r24, 0xFC	; 252
    3628:	80 83       	st	Z, r24
	#elif defined(USB_SERIES_4_AVR)
	USBCON &= ~(1 << VBUSTE);					
	#endif
	
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
    362a:	10 92 a0 00 	sts	0x00A0, r1
	OTGIEN  = 0;
    362e:	10 92 de 00 	sts	0x00DE, r1
	#endif
	
	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
	#endif
}
    3632:	08 95       	ret

00003634 <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT  = 0;
    3634:	10 92 da 00 	sts	0x00DA, r1
	#endif
	
	#if defined(USB_CAN_BE_HOST)
	UHINT   = 0;
    3638:	10 92 9f 00 	sts	0x009F, r1
	OTGINT  = 0;
    363c:	10 92 df 00 	sts	0x00DF, r1
	#endif
	
	#if defined(USB_CAN_BE_DEVICE)
	UDINT   = 0;
	#endif
}
    3640:	08 95       	ret

00003642 <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
    3642:	1f 92       	push	r1
    3644:	0f 92       	push	r0
    3646:	0f b6       	in	r0, 0x3f	; 63
    3648:	0f 92       	push	r0
    364a:	0b b6       	in	r0, 0x3b	; 59
    364c:	0f 92       	push	r0
    364e:	11 24       	eor	r1, r1
    3650:	2f 93       	push	r18
    3652:	3f 93       	push	r19
    3654:	4f 93       	push	r20
    3656:	5f 93       	push	r21
    3658:	6f 93       	push	r22
    365a:	7f 93       	push	r23
    365c:	8f 93       	push	r24
    365e:	9f 93       	push	r25
    3660:	af 93       	push	r26
    3662:	bf 93       	push	r27
    3664:	ef 93       	push	r30
    3666:	ff 93       	push	r31
		EVENT_USB_Device_StartOfFrame();
	}
	#endif
	
	#if defined(USB_CAN_BE_HOST)
	if (USB_INT_HasOccurred(USB_INT_DDISCI) && USB_INT_IsEnabled(USB_INT_DDISCI))
    3668:	80 91 9f 00 	lds	r24, 0x009F
    366c:	81 ff       	sbrs	r24, 1
    366e:	16 c0       	rjmp	.+44     	; 0x369c <__vector_10+0x5a>
    3670:	80 91 a0 00 	lds	r24, 0x00A0
    3674:	81 ff       	sbrs	r24, 1
    3676:	12 c0       	rjmp	.+36     	; 0x369c <__vector_10+0x5a>
	{
		USB_INT_Clear(USB_INT_DDISCI);
    3678:	80 91 9f 00 	lds	r24, 0x009F
    367c:	8d 7f       	andi	r24, 0xFD	; 253
    367e:	80 93 9f 00 	sts	0x009F, r24
		USB_INT_Clear(USB_INT_DCONNI);
    3682:	80 91 9f 00 	lds	r24, 0x009F
    3686:	8e 7f       	andi	r24, 0xFE	; 254
    3688:	80 93 9f 00 	sts	0x009F, r24
		USB_INT_Disable(USB_INT_DDISCI);
    368c:	80 91 a0 00 	lds	r24, 0x00A0
    3690:	8d 7f       	andi	r24, 0xFD	; 253
    3692:	80 93 a0 00 	sts	0x00A0, r24
			
		EVENT_USB_Host_DeviceUnattached();
    3696:	0e 94 bc 00 	call	0x178	; 0x178 <EVENT_USB_Host_DeviceUnattached>

		USB_ResetInterface();
    369a:	2c de       	rcall	.-936    	; 0x32f4 <USB_ResetInterface>
	}
	
	if (USB_INT_HasOccurred(USB_INT_VBERRI) && USB_INT_IsEnabled(USB_INT_VBERRI))
    369c:	80 91 df 00 	lds	r24, 0x00DF
    36a0:	81 ff       	sbrs	r24, 1
    36a2:	17 c0       	rjmp	.+46     	; 0x36d2 <__vector_10+0x90>
    36a4:	80 91 de 00 	lds	r24, 0x00DE
    36a8:	81 ff       	sbrs	r24, 1
    36aa:	13 c0       	rjmp	.+38     	; 0x36d2 <__vector_10+0x90>
	{
		USB_INT_Clear(USB_INT_VBERRI);
    36ac:	80 91 df 00 	lds	r24, 0x00DF
    36b0:	8d 7f       	andi	r24, 0xFD	; 253
    36b2:	80 93 df 00 	sts	0x00DF, r24

		USB_Host_VBUS_Manual_Off();
    36b6:	77 98       	cbi	0x0e, 7	; 14
		USB_Host_VBUS_Auto_Off();
    36b8:	80 91 dd 00 	lds	r24, 0x00DD
    36bc:	81 60       	ori	r24, 0x01	; 1
    36be:	80 93 dd 00 	sts	0x00DD, r24

		EVENT_USB_Host_HostError(HOST_ERROR_VBusVoltageDip);
    36c2:	80 e0       	ldi	r24, 0x00	; 0
    36c4:	0e 94 70 02 	call	0x4e0	; 0x4e0 <EVENT_USB_Host_HostError>
		EVENT_USB_Host_DeviceUnattached();
    36c8:	0e 94 bc 00 	call	0x178	; 0x178 <EVENT_USB_Host_DeviceUnattached>

		USB_HostState = HOST_STATE_Unattached;
    36cc:	82 e0       	ldi	r24, 0x02	; 2
    36ce:	80 93 76 11 	sts	0x1176, r24
	}

	if (USB_INT_HasOccurred(USB_INT_SRPI) && USB_INT_IsEnabled(USB_INT_SRPI))
    36d2:	80 91 df 00 	lds	r24, 0x00DF
    36d6:	80 ff       	sbrs	r24, 0
    36d8:	18 c0       	rjmp	.+48     	; 0x370a <__vector_10+0xc8>
    36da:	80 91 de 00 	lds	r24, 0x00DE
    36de:	80 ff       	sbrs	r24, 0
    36e0:	14 c0       	rjmp	.+40     	; 0x370a <__vector_10+0xc8>
	{
		USB_INT_Clear(USB_INT_SRPI);
    36e2:	80 91 df 00 	lds	r24, 0x00DF
    36e6:	8e 7f       	andi	r24, 0xFE	; 254
    36e8:	80 93 df 00 	sts	0x00DF, r24
		USB_INT_Disable(USB_INT_SRPI);
    36ec:	80 91 de 00 	lds	r24, 0x00DE
    36f0:	8e 7f       	andi	r24, 0xFE	; 254
    36f2:	80 93 de 00 	sts	0x00DE, r24
	
		EVENT_USB_Host_DeviceAttached();
    36f6:	0e 94 c6 00 	call	0x18c	; 0x18c <EVENT_USB_Host_DeviceAttached>

		USB_INT_Enable(USB_INT_DDISCI);
    36fa:	80 91 a0 00 	lds	r24, 0x00A0
    36fe:	82 60       	ori	r24, 0x02	; 2
    3700:	80 93 a0 00 	sts	0x00A0, r24
		
		USB_HostState = HOST_STATE_Powered;
    3704:	83 e0       	ldi	r24, 0x03	; 3
    3706:	80 93 76 11 	sts	0x1176, r24
	}

	if (USB_INT_HasOccurred(USB_INT_BCERRI) && USB_INT_IsEnabled(USB_INT_BCERRI))
    370a:	80 91 df 00 	lds	r24, 0x00DF
    370e:	82 ff       	sbrs	r24, 2
    3710:	10 c0       	rjmp	.+32     	; 0x3732 <__vector_10+0xf0>
    3712:	80 91 de 00 	lds	r24, 0x00DE
    3716:	82 ff       	sbrs	r24, 2
    3718:	0c c0       	rjmp	.+24     	; 0x3732 <__vector_10+0xf0>
	{
		USB_INT_Clear(USB_INT_BCERRI);
    371a:	80 91 df 00 	lds	r24, 0x00DF
    371e:	8b 7f       	andi	r24, 0xFB	; 251
    3720:	80 93 df 00 	sts	0x00DF, r24
		
		EVENT_USB_Host_DeviceEnumerationFailed(HOST_ENUMERROR_NoDeviceDetected, 0);
    3724:	82 e0       	ldi	r24, 0x02	; 2
    3726:	60 e0       	ldi	r22, 0x00	; 0
    3728:	0e 94 ac 00 	call	0x158	; 0x158 <EVENT_USB_Host_DeviceEnumerationFailed>
		EVENT_USB_Host_DeviceUnattached();
    372c:	0e 94 bc 00 	call	0x178	; 0x178 <EVENT_USB_Host_DeviceUnattached>

		USB_ResetInterface();
    3730:	e1 dd       	rcall	.-1086   	; 0x32f4 <USB_ResetInterface>
		EVENT_USB_UIDChange();

		USB_ResetInterface();
	}
	#endif
}
    3732:	ff 91       	pop	r31
    3734:	ef 91       	pop	r30
    3736:	bf 91       	pop	r27
    3738:	af 91       	pop	r26
    373a:	9f 91       	pop	r25
    373c:	8f 91       	pop	r24
    373e:	7f 91       	pop	r23
    3740:	6f 91       	pop	r22
    3742:	5f 91       	pop	r21
    3744:	4f 91       	pop	r20
    3746:	3f 91       	pop	r19
    3748:	2f 91       	pop	r18
    374a:	0f 90       	pop	r0
    374c:	0b be       	out	0x3b, r0	; 59
    374e:	0f 90       	pop	r0
    3750:	0f be       	out	0x3f, r0	; 63
    3752:	0f 90       	pop	r0
    3754:	1f 90       	pop	r1
    3756:	18 95       	reti

00003758 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    3758:	ff 92       	push	r15
    375a:	0f 93       	push	r16
    375c:	1f 93       	push	r17
#endif

#if defined(USB_CAN_BE_HOST)
static void USB_HostTask(void)
{
	uint8_t PrevPipe = Pipe_GetCurrentPipe();
    375e:	07 ea       	ldi	r16, 0xA7	; 167
    3760:	10 e0       	ldi	r17, 0x00	; 0
    3762:	f8 01       	movw	r30, r16
    3764:	f0 80       	ld	r15, Z
    3766:	f7 e0       	ldi	r31, 0x07	; 7
    3768:	ff 22       	and	r15, r31
	
	Pipe_SelectPipe(PIPE_CONTROLPIPE);
    376a:	f8 01       	movw	r30, r16
    376c:	10 82       	st	Z, r1

	USB_Host_ProcessNextHostState();
    376e:	42 db       	rcall	.-2428   	; 0x2df4 <USB_Host_ProcessNextHostState>
	
	Pipe_SelectPipe(PrevPipe);
    3770:	f8 01       	movw	r30, r16
    3772:	f0 82       	st	Z, r15
		if (USB_CurrentMode == USB_MODE_DEVICE)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_HOST)
		  USB_HostTask();
	#endif
}
    3774:	1f 91       	pop	r17
    3776:	0f 91       	pop	r16
    3778:	ff 90       	pop	r15
    377a:	08 95       	ret

0000377c <USB_GetNextDescriptorComp>:
			
uint8_t USB_GetNextDescriptorComp(uint16_t* BytesRem, void** CurrConfigLoc, ConfigComparatorPtr_t ComparatorRoutine)
{
    377c:	af 92       	push	r10
    377e:	bf 92       	push	r11
    3780:	cf 92       	push	r12
    3782:	df 92       	push	r13
    3784:	ef 92       	push	r14
    3786:	ff 92       	push	r15
    3788:	0f 93       	push	r16
    378a:	1f 93       	push	r17
    378c:	cf 93       	push	r28
    378e:	df 93       	push	r29
    3790:	6c 01       	movw	r12, r24
    3792:	8b 01       	movw	r16, r22
    3794:	5a 01       	movw	r10, r20
    3796:	1d c0       	rjmp	.+58     	; 0x37d2 <USB_GetNextDescriptorComp+0x56>
	uint8_t ErrorCode;
		
	while (*BytesRem)
	{
		uint8_t*  PrevDescLoc  = *CurrConfigLoc;
    3798:	f8 01       	movw	r30, r16
    379a:	c0 81       	ld	r28, Z
    379c:	d1 81       	ldd	r29, Z+1	; 0x01
			                                         void** const CurrConfigLoc) 
			                                         ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(2);									  
			static inline void USB_GetNextDescriptor(uint16_t* const BytesRem,
			                                         void** const CurrConfigLoc)
			{
				uint16_t CurrDescriptorSize = DESCRIPTOR_CAST(*CurrConfigLoc, USB_Descriptor_Header_t).Size;
    379e:	28 81       	ld	r18, Y
    37a0:	30 e0       	ldi	r19, 0x00	; 0

				*CurrConfigLoc += CurrDescriptorSize;
    37a2:	ce 01       	movw	r24, r28
    37a4:	82 0f       	add	r24, r18
    37a6:	93 1f       	adc	r25, r19
    37a8:	91 83       	std	Z+1, r25	; 0x01
    37aa:	80 83       	st	Z, r24
				*BytesRem      -= CurrDescriptorSize;
    37ac:	a7 01       	movw	r20, r14
    37ae:	42 1b       	sub	r20, r18
    37b0:	53 0b       	sbc	r21, r19
    37b2:	f6 01       	movw	r30, r12
    37b4:	51 83       	std	Z+1, r21	; 0x01
    37b6:	40 83       	st	Z, r20
		uint16_t  PrevBytesRem = *BytesRem;

		USB_GetNextDescriptor(BytesRem, CurrConfigLoc);

		if ((ErrorCode = ComparatorRoutine(*CurrConfigLoc)) != DESCRIPTOR_SEARCH_NotFound)
    37b8:	f5 01       	movw	r30, r10
    37ba:	09 95       	icall
    37bc:	82 30       	cpi	r24, 0x02	; 2
    37be:	49 f0       	breq	.+18     	; 0x37d2 <USB_GetNextDescriptorComp+0x56>
		{
			if (ErrorCode == DESCRIPTOR_SEARCH_Fail)
    37c0:	81 30       	cpi	r24, 0x01	; 1
    37c2:	71 f4       	brne	.+28     	; 0x37e0 <USB_GetNextDescriptorComp+0x64>
			{
				*CurrConfigLoc = PrevDescLoc;
    37c4:	f8 01       	movw	r30, r16
    37c6:	c0 83       	st	Z, r28
    37c8:	d1 83       	std	Z+1, r29	; 0x01
				*BytesRem      = PrevBytesRem;
    37ca:	f6 01       	movw	r30, r12
    37cc:	f1 82       	std	Z+1, r15	; 0x01
    37ce:	e0 82       	st	Z, r14
    37d0:	07 c0       	rjmp	.+14     	; 0x37e0 <USB_GetNextDescriptorComp+0x64>
			
uint8_t USB_GetNextDescriptorComp(uint16_t* BytesRem, void** CurrConfigLoc, ConfigComparatorPtr_t ComparatorRoutine)
{
	uint8_t ErrorCode;
		
	while (*BytesRem)
    37d2:	f6 01       	movw	r30, r12
    37d4:	e0 80       	ld	r14, Z
    37d6:	f1 80       	ldd	r15, Z+1	; 0x01
    37d8:	e1 14       	cp	r14, r1
    37da:	f1 04       	cpc	r15, r1
    37dc:	e9 f6       	brne	.-70     	; 0x3798 <USB_GetNextDescriptorComp+0x1c>
    37de:	82 e0       	ldi	r24, 0x02	; 2
			return ErrorCode;
		}
	}
	
	return DESCRIPTOR_SEARCH_COMP_EndOfDescriptor;
}
    37e0:	df 91       	pop	r29
    37e2:	cf 91       	pop	r28
    37e4:	1f 91       	pop	r17
    37e6:	0f 91       	pop	r16
    37e8:	ff 90       	pop	r15
    37ea:	ef 90       	pop	r14
    37ec:	df 90       	pop	r13
    37ee:	cf 90       	pop	r12
    37f0:	bf 90       	pop	r11
    37f2:	af 90       	pop	r10
    37f4:	08 95       	ret

000037f6 <USB_Host_GetDeviceConfigDescriptor>:
#include "ConfigDescriptor.h"

#if defined(USB_CAN_BE_HOST)
uint8_t USB_Host_GetDeviceConfigDescriptor(uint8_t ConfigNumber, uint16_t* const ConfigSizePtr,
                                           void* BufferPtr, uint16_t BufferSize)
{
    37f6:	cf 92       	push	r12
    37f8:	df 92       	push	r13
    37fa:	ef 92       	push	r14
    37fc:	ff 92       	push	r15
    37fe:	0f 93       	push	r16
    3800:	1f 93       	push	r17
    3802:	df 93       	push	r29
    3804:	cf 93       	push	r28
    3806:	cd b7       	in	r28, 0x3d	; 61
    3808:	de b7       	in	r29, 0x3e	; 62
    380a:	29 97       	sbiw	r28, 0x09	; 9
    380c:	0f b6       	in	r0, 0x3f	; 63
    380e:	f8 94       	cli
    3810:	de bf       	out	0x3e, r29	; 62
    3812:	0f be       	out	0x3f, r0	; 63
    3814:	cd bf       	out	0x3d, r28	; 61
    3816:	6b 01       	movw	r12, r22
    3818:	8a 01       	movw	r16, r20
    381a:	79 01       	movw	r14, r18
	uint8_t ErrorCode;
	uint8_t ConfigHeader[sizeof(USB_Descriptor_Configuration_Header_t)];

	USB_ControlRequest = (USB_Request_Header_t)
    381c:	90 e8       	ldi	r25, 0x80	; 128
    381e:	90 93 6e 11 	sts	0x116E, r25
    3822:	96 e0       	ldi	r25, 0x06	; 6
    3824:	90 93 6f 11 	sts	0x116F, r25
    3828:	90 e0       	ldi	r25, 0x00	; 0
    382a:	01 97       	sbiw	r24, 0x01	; 1
    382c:	92 60       	ori	r25, 0x02	; 2
    382e:	90 93 71 11 	sts	0x1171, r25
    3832:	80 93 70 11 	sts	0x1170, r24
    3836:	10 92 73 11 	sts	0x1173, r1
    383a:	10 92 72 11 	sts	0x1172, r1
    383e:	89 e0       	ldi	r24, 0x09	; 9
    3840:	90 e0       	ldi	r25, 0x00	; 0
    3842:	90 93 75 11 	sts	0x1175, r25
    3846:	80 93 74 11 	sts	0x1174, r24
			.wValue        = ((DTYPE_Configuration << 8) | (ConfigNumber - 1)),
			.wIndex        = 0,
			.wLength       = sizeof(USB_Descriptor_Configuration_Header_t),
		};
	
	Pipe_SelectPipe(PIPE_CONTROLPIPE);
    384a:	10 92 a7 00 	sts	0x00A7, r1

	if ((ErrorCode = USB_Host_SendControlRequest(ConfigHeader)) != HOST_SENDCONTROL_Successful)
    384e:	ce 01       	movw	r24, r28
    3850:	01 96       	adiw	r24, 0x01	; 1
    3852:	39 dc       	rcall	.-1934   	; 0x30c6 <USB_Host_SendControlRequest>
    3854:	28 2f       	mov	r18, r24
    3856:	88 23       	and	r24, r24
    3858:	c1 f4       	brne	.+48     	; 0x388a <USB_Host_GetDeviceConfigDescriptor+0x94>
	  return ErrorCode;

	*ConfigSizePtr = DESCRIPTOR_CAST(ConfigHeader, USB_Descriptor_Configuration_Header_t).TotalConfigurationSize;
    385a:	8b 81       	ldd	r24, Y+3	; 0x03
    385c:	9c 81       	ldd	r25, Y+4	; 0x04
    385e:	f6 01       	movw	r30, r12
    3860:	91 83       	std	Z+1, r25	; 0x01
    3862:	80 83       	st	Z, r24

	if (*ConfigSizePtr > BufferSize)
    3864:	e8 16       	cp	r14, r24
    3866:	f9 06       	cpc	r15, r25
    3868:	10 f4       	brcc	.+4      	; 0x386e <USB_Host_GetDeviceConfigDescriptor+0x78>
    386a:	25 e0       	ldi	r18, 0x05	; 5
    386c:	0e c0       	rjmp	.+28     	; 0x388a <USB_Host_GetDeviceConfigDescriptor+0x94>
	  return HOST_GETCONFIG_BuffOverflow;
	  
	USB_ControlRequest.wLength = *ConfigSizePtr;
    386e:	90 93 75 11 	sts	0x1175, r25
    3872:	80 93 74 11 	sts	0x1174, r24
	
	if ((ErrorCode = USB_Host_SendControlRequest(BufferPtr)) != HOST_SENDCONTROL_Successful)
    3876:	c8 01       	movw	r24, r16
    3878:	26 dc       	rcall	.-1972   	; 0x30c6 <USB_Host_SendControlRequest>
    387a:	28 2f       	mov	r18, r24
    387c:	88 23       	and	r24, r24
    387e:	29 f4       	brne	.+10     	; 0x388a <USB_Host_GetDeviceConfigDescriptor+0x94>
	  return ErrorCode;

	if (DESCRIPTOR_TYPE(BufferPtr) != DTYPE_Configuration)
    3880:	f8 01       	movw	r30, r16
    3882:	81 81       	ldd	r24, Z+1	; 0x01
    3884:	82 30       	cpi	r24, 0x02	; 2
    3886:	09 f0       	breq	.+2      	; 0x388a <USB_Host_GetDeviceConfigDescriptor+0x94>
    3888:	26 e0       	ldi	r18, 0x06	; 6
	  return HOST_GETCONFIG_InvalidData;
	
	return HOST_GETCONFIG_Successful;
}
    388a:	82 2f       	mov	r24, r18
    388c:	29 96       	adiw	r28, 0x09	; 9
    388e:	0f b6       	in	r0, 0x3f	; 63
    3890:	f8 94       	cli
    3892:	de bf       	out	0x3e, r29	; 62
    3894:	0f be       	out	0x3f, r0	; 63
    3896:	cd bf       	out	0x3d, r28	; 61
    3898:	cf 91       	pop	r28
    389a:	df 91       	pop	r29
    389c:	1f 91       	pop	r17
    389e:	0f 91       	pop	r16
    38a0:	ff 90       	pop	r15
    38a2:	ef 90       	pop	r14
    38a4:	df 90       	pop	r13
    38a6:	cf 90       	pop	r12
    38a8:	08 95       	ret

000038aa <_exit>:
    38aa:	f8 94       	cli

000038ac <__stop_program>:
    38ac:	ff cf       	rjmp	.-2      	; 0x38ac <__stop_program>
